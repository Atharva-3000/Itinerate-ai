/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/html2pdf.js";
exports.ids = ["vendor-chunks/html2pdf.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/html2pdf.js/dist/html2pdf.js":
/*!***************************************************!*\
  !*** ./node_modules/html2pdf.js/dist/html2pdf.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * html2pdf.js v0.10.2\n * Copyright (c) 2024 Erik Koopmans\n * Released under the MIT License.\n */ (function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! jspdf */ \"(ssr)/./node_modules/jspdf/dist/jspdf.es.min.js\"), __webpack_require__(/*! html2canvas */ \"(ssr)/./node_modules/html2canvas/dist/html2canvas.esm.js\"));\n    else {}\n})(self, function(__WEBPACK_EXTERNAL_MODULE_jspdf__, __WEBPACK_EXTERNAL_MODULE_html2canvas__) {\n    return /******/ function() {\n        /******/ var __webpack_modules__ = {\n            /***/ \"./src/plugin/hyperlinks.js\": /*!**********************************!*\\\n  !*** ./src/plugin/hyperlinks.js ***!\n  \\**********************************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_1021__) {\n                \"use strict\";\n                __nested_webpack_require_1021__.r(__nested_webpack_exports__);\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1021__(/*! core-js/modules/web.dom-collections.for-each.js */ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_1021__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_string_link_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_1021__(/*! core-js/modules/es.string.link.js */ \"./node_modules/core-js/modules/es.string.link.js\");\n                /* harmony import */ var core_js_modules_es_string_link_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_1021__.n(core_js_modules_es_string_link_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var _worker_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_1021__(/*! ../worker.js */ \"./src/worker.js\");\n                /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_1021__(/*! ../utils.js */ \"./src/utils.js\");\n                // Add hyperlink functionality to the PDF creation.\n                // Main link array, and refs to original functions.\n                var linkInfo = [];\n                var orig = {\n                    toContainer: _worker_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.toContainer,\n                    toPdf: _worker_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.toPdf\n                };\n                _worker_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.toContainer = function toContainer() {\n                    return orig.toContainer.call(this).then(function toContainer_hyperlink() {\n                        // Retrieve hyperlink info if the option is enabled.\n                        if (this.opt.enableLinks) {\n                            // Find all anchor tags and get the container's bounds for reference.\n                            var container = this.prop.container;\n                            var links = container.querySelectorAll(\"a\");\n                            var containerRect = (0, _utils_js__WEBPACK_IMPORTED_MODULE_3__.unitConvert)(container.getBoundingClientRect(), this.prop.pageSize.k);\n                            linkInfo = []; // Loop through each anchor tag.\n                            Array.prototype.forEach.call(links, function(link) {\n                                // Treat each client rect as a separate link (for text-wrapping).\n                                var clientRects = link.getClientRects();\n                                for(var i = 0; i < clientRects.length; i++){\n                                    var clientRect = (0, _utils_js__WEBPACK_IMPORTED_MODULE_3__.unitConvert)(clientRects[i], this.prop.pageSize.k);\n                                    clientRect.left -= containerRect.left;\n                                    clientRect.top -= containerRect.top;\n                                    var page = Math.floor(clientRect.top / this.prop.pageSize.inner.height) + 1;\n                                    var top = this.opt.margin[0] + clientRect.top % this.prop.pageSize.inner.height;\n                                    var left = this.opt.margin[1] + clientRect.left;\n                                    linkInfo.push({\n                                        page: page,\n                                        top: top,\n                                        left: left,\n                                        clientRect: clientRect,\n                                        link: link\n                                    });\n                                }\n                            }, this);\n                        }\n                    });\n                };\n                _worker_js__WEBPACK_IMPORTED_MODULE_2__.default.prototype.toPdf = function toPdf() {\n                    return orig.toPdf.call(this).then(function toPdf_hyperlink() {\n                        // Add hyperlinks if the option is enabled.\n                        if (this.opt.enableLinks) {\n                            // Attach each anchor tag based on info from toContainer().\n                            linkInfo.forEach(function(l) {\n                                this.prop.pdf.setPage(l.page);\n                                this.prop.pdf.link(l.left, l.top, l.clientRect.width, l.clientRect.height, {\n                                    url: l.link.href\n                                });\n                            }, this); // Reset the active page of the PDF to the final page.\n                            var nPages = this.prop.pdf.internal.getNumberOfPages();\n                            this.prop.pdf.setPage(nPages);\n                        }\n                    });\n                };\n            /***/ },\n            /***/ \"./src/plugin/jspdf-plugin.js\": /*!************************************!*\\\n  !*** ./src/plugin/jspdf-plugin.js ***!\n  \\************************************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_6298__) {\n                \"use strict\";\n                __nested_webpack_require_6298__.r(__nested_webpack_exports__);\n                /* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_6298__(/*! core-js/modules/es.symbol.js */ \"./node_modules/core-js/modules/es.symbol.js\");\n                /* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_6298__.n(core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_6298__(/*! core-js/modules/es.symbol.description.js */ \"./node_modules/core-js/modules/es.symbol.description.js\");\n                /* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_6298__.n(core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_6298__(/*! core-js/modules/es.object.to-string.js */ \"./node_modules/core-js/modules/es.object.to-string.js\");\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_6298__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_2__);\n                /* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_6298__(/*! core-js/modules/es.symbol.iterator.js */ \"./node_modules/core-js/modules/es.symbol.iterator.js\");\n                /* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_6298__.n(core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_3__);\n                /* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_6298__(/*! core-js/modules/es.array.iterator.js */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n                /* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_6298__.n(core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_4__);\n                /* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_6298__(/*! core-js/modules/es.string.iterator.js */ \"./node_modules/core-js/modules/es.string.iterator.js\");\n                /* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __nested_webpack_require_6298__.n(core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_5__);\n                /* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_6298__(/*! core-js/modules/web.dom-collections.iterator.js */ \"./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __nested_webpack_require_6298__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6__);\n                /* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_6298__(/*! jspdf */ \"jspdf\");\n                /* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/ __nested_webpack_require_6298__.n(jspdf__WEBPACK_IMPORTED_MODULE_7__);\n                function _typeof(obj) {\n                    \"@babel/helpers - typeof\";\n                    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                        _typeof = function _typeof(obj) {\n                            return typeof obj;\n                        };\n                    } else {\n                        _typeof = function _typeof(obj) {\n                            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                        };\n                    }\n                    return _typeof(obj);\n                }\n                // Import dependencies.\n                // Get dimensions of a PDF page, as determined by jsPDF.\n                jspdf__WEBPACK_IMPORTED_MODULE_7__.jsPDF.getPageSize = function(orientation, unit, format) {\n                    // Decode options object\n                    if (_typeof(orientation) === \"object\") {\n                        var options = orientation;\n                        orientation = options.orientation;\n                        unit = options.unit || unit;\n                        format = options.format || format;\n                    } // Default options\n                    unit = unit || \"mm\";\n                    format = format || \"a4\";\n                    orientation = (\"\" + (orientation || \"P\")).toLowerCase();\n                    var format_as_string = (\"\" + format).toLowerCase(); // Size in pt of various paper formats\n                    var pageFormats = {\n                        \"a0\": [\n                            2383.94,\n                            3370.39\n                        ],\n                        \"a1\": [\n                            1683.78,\n                            2383.94\n                        ],\n                        \"a2\": [\n                            1190.55,\n                            1683.78\n                        ],\n                        \"a3\": [\n                            841.89,\n                            1190.55\n                        ],\n                        \"a4\": [\n                            595.28,\n                            841.89\n                        ],\n                        \"a5\": [\n                            419.53,\n                            595.28\n                        ],\n                        \"a6\": [\n                            297.64,\n                            419.53\n                        ],\n                        \"a7\": [\n                            209.76,\n                            297.64\n                        ],\n                        \"a8\": [\n                            147.40,\n                            209.76\n                        ],\n                        \"a9\": [\n                            104.88,\n                            147.40\n                        ],\n                        \"a10\": [\n                            73.70,\n                            104.88\n                        ],\n                        \"b0\": [\n                            2834.65,\n                            4008.19\n                        ],\n                        \"b1\": [\n                            2004.09,\n                            2834.65\n                        ],\n                        \"b2\": [\n                            1417.32,\n                            2004.09\n                        ],\n                        \"b3\": [\n                            1000.63,\n                            1417.32\n                        ],\n                        \"b4\": [\n                            708.66,\n                            1000.63\n                        ],\n                        \"b5\": [\n                            498.90,\n                            708.66\n                        ],\n                        \"b6\": [\n                            354.33,\n                            498.90\n                        ],\n                        \"b7\": [\n                            249.45,\n                            354.33\n                        ],\n                        \"b8\": [\n                            175.75,\n                            249.45\n                        ],\n                        \"b9\": [\n                            124.72,\n                            175.75\n                        ],\n                        \"b10\": [\n                            87.87,\n                            124.72\n                        ],\n                        \"c0\": [\n                            2599.37,\n                            3676.54\n                        ],\n                        \"c1\": [\n                            1836.85,\n                            2599.37\n                        ],\n                        \"c2\": [\n                            1298.27,\n                            1836.85\n                        ],\n                        \"c3\": [\n                            918.43,\n                            1298.27\n                        ],\n                        \"c4\": [\n                            649.13,\n                            918.43\n                        ],\n                        \"c5\": [\n                            459.21,\n                            649.13\n                        ],\n                        \"c6\": [\n                            323.15,\n                            459.21\n                        ],\n                        \"c7\": [\n                            229.61,\n                            323.15\n                        ],\n                        \"c8\": [\n                            161.57,\n                            229.61\n                        ],\n                        \"c9\": [\n                            113.39,\n                            161.57\n                        ],\n                        \"c10\": [\n                            79.37,\n                            113.39\n                        ],\n                        \"dl\": [\n                            311.81,\n                            623.62\n                        ],\n                        \"letter\": [\n                            612,\n                            792\n                        ],\n                        \"government-letter\": [\n                            576,\n                            756\n                        ],\n                        \"legal\": [\n                            612,\n                            1008\n                        ],\n                        \"junior-legal\": [\n                            576,\n                            360\n                        ],\n                        \"ledger\": [\n                            1224,\n                            792\n                        ],\n                        \"tabloid\": [\n                            792,\n                            1224\n                        ],\n                        \"credit-card\": [\n                            153,\n                            243\n                        ]\n                    }; // Unit conversion\n                    switch(unit){\n                        case \"pt\":\n                            var k = 1;\n                            break;\n                        case \"mm\":\n                            var k = 72 / 25.4;\n                            break;\n                        case \"cm\":\n                            var k = 72 / 2.54;\n                            break;\n                        case \"in\":\n                            var k = 72;\n                            break;\n                        case \"px\":\n                            var k = 72 / 96;\n                            break;\n                        case \"pc\":\n                            var k = 12;\n                            break;\n                        case \"em\":\n                            var k = 12;\n                            break;\n                        case \"ex\":\n                            var k = 6;\n                            break;\n                        default:\n                            throw \"Invalid unit: \" + unit;\n                    } // Dimensions are stored as user units and converted to points on output\n                    if (pageFormats.hasOwnProperty(format_as_string)) {\n                        var pageHeight = pageFormats[format_as_string][1] / k;\n                        var pageWidth = pageFormats[format_as_string][0] / k;\n                    } else {\n                        try {\n                            var pageHeight = format[1];\n                            var pageWidth = format[0];\n                        } catch (err) {\n                            throw new Error(\"Invalid format: \" + format);\n                        }\n                    } // Handle page orientation\n                    if (orientation === \"p\" || orientation === \"portrait\") {\n                        orientation = \"p\";\n                        if (pageWidth > pageHeight) {\n                            var tmp = pageWidth;\n                            pageWidth = pageHeight;\n                            pageHeight = tmp;\n                        }\n                    } else if (orientation === \"l\" || orientation === \"landscape\") {\n                        orientation = \"l\";\n                        if (pageHeight > pageWidth) {\n                            var tmp = pageWidth;\n                            pageWidth = pageHeight;\n                            pageHeight = tmp;\n                        }\n                    } else {\n                        throw \"Invalid orientation: \" + orientation;\n                    } // Return information (k is the unit conversion ratio from pts)\n                    var info = {\n                        \"width\": pageWidth,\n                        \"height\": pageHeight,\n                        \"unit\": unit,\n                        \"k\": k\n                    };\n                    return info;\n                };\n                /* harmony default export */ __nested_webpack_exports__[\"default\"] = jspdf__WEBPACK_IMPORTED_MODULE_7__.jsPDF;\n            /***/ },\n            /***/ \"./src/plugin/pagebreaks.js\": /*!**********************************!*\\\n  !*** ./src/plugin/pagebreaks.js ***!\n  \\**********************************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_20097__) {\n                \"use strict\";\n                __nested_webpack_require_20097__.r(__nested_webpack_exports__);\n                /* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_20097__(/*! core-js/modules/es.array.concat.js */ \"./node_modules/core-js/modules/es.array.concat.js\");\n                /* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_20097__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_20097__(/*! core-js/modules/es.array.slice.js */ \"./node_modules/core-js/modules/es.array.slice.js\");\n                /* harmony import */ var core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_20097__.n(core_js_modules_es_array_slice_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_20097__(/*! core-js/modules/es.array.join.js */ \"./node_modules/core-js/modules/es.array.join.js\");\n                /* harmony import */ var core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_20097__.n(core_js_modules_es_array_join_js__WEBPACK_IMPORTED_MODULE_2__);\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_20097__(/*! core-js/modules/web.dom-collections.for-each.js */ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_20097__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_3__);\n                /* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_20097__(/*! core-js/modules/es.object.keys.js */ \"./node_modules/core-js/modules/es.object.keys.js\");\n                /* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_20097__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_4__);\n                /* harmony import */ var _worker_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_20097__(/*! ../worker.js */ \"./src/worker.js\");\n                /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_20097__(/*! ../utils.js */ \"./src/utils.js\");\n                /* Pagebreak plugin:\n\n    Adds page-break functionality to the html2pdf library. Page-breaks can be\n    enabled by CSS styles, set on individual elements using selectors, or\n    avoided from breaking inside all elements.\n\n    Options on the `opt.pagebreak` object:\n\n    mode:   String or array of strings: 'avoid-all', 'css', and/or 'legacy'\n            Default: ['css', 'legacy']\n\n    before: String or array of CSS selectors for which to add page-breaks\n            before each element. Can be a specific element with an ID\n            ('#myID'), all elements of a type (e.g. 'img'), all of a class\n            ('.myClass'), or even '*' to match every element.\n\n    after:  Like 'before', but adds a page-break immediately after the element.\n\n    avoid:  Like 'before', but avoids page-breaks on these elements. You can\n            enable this feature on every element using the 'avoid-all' mode.\n*/ // Refs to original functions.\n                var orig = {\n                    toContainer: _worker_js__WEBPACK_IMPORTED_MODULE_5__.default.prototype.toContainer\n                }; // Add pagebreak default options to the Worker template.\n                _worker_js__WEBPACK_IMPORTED_MODULE_5__.default.template.opt.pagebreak = {\n                    mode: [\n                        \"css\",\n                        \"legacy\"\n                    ],\n                    before: [],\n                    after: [],\n                    avoid: []\n                };\n                _worker_js__WEBPACK_IMPORTED_MODULE_5__.default.prototype.toContainer = function toContainer() {\n                    return orig.toContainer.call(this).then(function toContainer_pagebreak() {\n                        // Setup root element and inner page height.\n                        var root = this.prop.container;\n                        var pxPageHeight = this.prop.pageSize.inner.px.height; // Check all requested modes.\n                        var modeSrc = [].concat(this.opt.pagebreak.mode);\n                        var mode = {\n                            avoidAll: modeSrc.indexOf(\"avoid-all\") !== -1,\n                            css: modeSrc.indexOf(\"css\") !== -1,\n                            legacy: modeSrc.indexOf(\"legacy\") !== -1\n                        }; // Get arrays of all explicitly requested elements.\n                        var select = {};\n                        var self1 = this;\n                        [\n                            \"before\",\n                            \"after\",\n                            \"avoid\"\n                        ].forEach(function(key) {\n                            var all = mode.avoidAll && key === \"avoid\";\n                            select[key] = all ? [] : [].concat(self1.opt.pagebreak[key] || []);\n                            if (select[key].length > 0) {\n                                select[key] = Array.prototype.slice.call(root.querySelectorAll(select[key].join(\", \")));\n                            }\n                        }); // Get all legacy page-break elements.\n                        var legacyEls = root.querySelectorAll(\".html2pdf__page-break\");\n                        legacyEls = Array.prototype.slice.call(legacyEls); // Loop through all elements.\n                        var els = root.querySelectorAll(\"*\");\n                        Array.prototype.forEach.call(els, function pagebreak_loop(el) {\n                            // Setup pagebreak rules based on legacy and avoidAll modes.\n                            var rules = {\n                                before: false,\n                                after: mode.legacy && legacyEls.indexOf(el) !== -1,\n                                avoid: mode.avoidAll\n                            }; // Add rules for css mode.\n                            if (mode.css) {\n                                // TODO: Check if this is valid with iFrames.\n                                var style = window.getComputedStyle(el); // TODO: Handle 'left' and 'right' correctly.\n                                // TODO: Add support for 'avoid' on breakBefore/After.\n                                var breakOpt = [\n                                    \"always\",\n                                    \"page\",\n                                    \"left\",\n                                    \"right\"\n                                ];\n                                var avoidOpt = [\n                                    \"avoid\",\n                                    \"avoid-page\"\n                                ];\n                                rules = {\n                                    before: rules.before || breakOpt.indexOf(style.breakBefore || style.pageBreakBefore) !== -1,\n                                    after: rules.after || breakOpt.indexOf(style.breakAfter || style.pageBreakAfter) !== -1,\n                                    avoid: rules.avoid || avoidOpt.indexOf(style.breakInside || style.pageBreakInside) !== -1\n                                };\n                            } // Add rules for explicit requests.\n                            Object.keys(rules).forEach(function(key) {\n                                rules[key] = rules[key] || select[key].indexOf(el) !== -1;\n                            }); // Get element position on the screen.\n                            // TODO: Subtract the top of the container from clientRect.top/bottom?\n                            var clientRect = el.getBoundingClientRect(); // Avoid: Check if a break happens mid-element.\n                            if (rules.avoid && !rules.before) {\n                                var startPage = Math.floor(clientRect.top / pxPageHeight);\n                                var endPage = Math.floor(clientRect.bottom / pxPageHeight);\n                                var nPages = Math.abs(clientRect.bottom - clientRect.top) / pxPageHeight; // Turn on rules.before if the el is broken and is at most one page long.\n                                if (endPage !== startPage && nPages <= 1) {\n                                    rules.before = true;\n                                }\n                            } // Before: Create a padding div to push the element to the next page.\n                            if (rules.before) {\n                                var pad = (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.createElement)(\"div\", {\n                                    style: {\n                                        display: \"block\",\n                                        height: pxPageHeight - clientRect.top % pxPageHeight + \"px\"\n                                    }\n                                });\n                                el.parentNode.insertBefore(pad, el);\n                            } // After: Create a padding div to fill the remaining page.\n                            if (rules.after) {\n                                var pad = (0, _utils_js__WEBPACK_IMPORTED_MODULE_6__.createElement)(\"div\", {\n                                    style: {\n                                        display: \"block\",\n                                        height: pxPageHeight - clientRect.bottom % pxPageHeight + \"px\"\n                                    }\n                                });\n                                el.parentNode.insertBefore(pad, el.nextSibling);\n                            }\n                        });\n                    });\n                };\n            /***/ },\n            /***/ \"./src/utils.js\": /*!**********************!*\\\n  !*** ./src/utils.js ***!\n  \\**********************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_30332__) {\n                \"use strict\";\n                __nested_webpack_require_30332__.r(__nested_webpack_exports__);\n                /* harmony export */ __nested_webpack_require_30332__.d(__nested_webpack_exports__, {\n                    /* harmony export */ \"objType\": function() {\n                        return /* binding */ objType;\n                    },\n                    /* harmony export */ \"createElement\": function() {\n                        return /* binding */ createElement;\n                    },\n                    /* harmony export */ \"cloneNode\": function() {\n                        return /* binding */ cloneNode;\n                    },\n                    /* harmony export */ \"unitConvert\": function() {\n                        return /* binding */ unitConvert;\n                    },\n                    /* harmony export */ \"toPx\": function() {\n                        return /* binding */ toPx;\n                    }\n                });\n                /* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_30332__(/*! core-js/modules/es.number.constructor.js */ \"./node_modules/core-js/modules/es.number.constructor.js\");\n                /* harmony import */ var core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_30332__.n(core_js_modules_es_number_constructor_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_30332__(/*! core-js/modules/es.symbol.js */ \"./node_modules/core-js/modules/es.symbol.js\");\n                /* harmony import */ var core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_30332__.n(core_js_modules_es_symbol_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_30332__(/*! core-js/modules/es.symbol.description.js */ \"./node_modules/core-js/modules/es.symbol.description.js\");\n                /* harmony import */ var core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_30332__.n(core_js_modules_es_symbol_description_js__WEBPACK_IMPORTED_MODULE_2__);\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_30332__(/*! core-js/modules/es.object.to-string.js */ \"./node_modules/core-js/modules/es.object.to-string.js\");\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_30332__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_3__);\n                /* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_30332__(/*! core-js/modules/es.symbol.iterator.js */ \"./node_modules/core-js/modules/es.symbol.iterator.js\");\n                /* harmony import */ var core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_30332__.n(core_js_modules_es_symbol_iterator_js__WEBPACK_IMPORTED_MODULE_4__);\n                /* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_30332__(/*! core-js/modules/es.array.iterator.js */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n                /* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __nested_webpack_require_30332__.n(core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5__);\n                /* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_30332__(/*! core-js/modules/es.string.iterator.js */ \"./node_modules/core-js/modules/es.string.iterator.js\");\n                /* harmony import */ var core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __nested_webpack_require_30332__.n(core_js_modules_es_string_iterator_js__WEBPACK_IMPORTED_MODULE_6__);\n                /* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_30332__(/*! core-js/modules/web.dom-collections.iterator.js */ \"./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/ __nested_webpack_require_30332__.n(core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_7__);\n                function _typeof(obj) {\n                    \"@babel/helpers - typeof\";\n                    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                        _typeof = function _typeof(obj) {\n                            return typeof obj;\n                        };\n                    } else {\n                        _typeof = function _typeof(obj) {\n                            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                        };\n                    }\n                    return _typeof(obj);\n                }\n                // Determine the type of a variable/object.\n                var objType = function objType(obj) {\n                    var type = _typeof(obj);\n                    if (type === \"undefined\") return \"undefined\";\n                    else if (type === \"string\" || obj instanceof String) return \"string\";\n                    else if (type === \"number\" || obj instanceof Number) return \"number\";\n                    else if (type === \"function\" || obj instanceof Function) return \"function\";\n                    else if (!!obj && obj.constructor === Array) return \"array\";\n                    else if (obj && obj.nodeType === 1) return \"element\";\n                    else if (type === \"object\") return \"object\";\n                    else return \"unknown\";\n                }; // Create an HTML element with optional className, innerHTML, and style.\n                var createElement = function createElement(tagName, opt) {\n                    var el = document.createElement(tagName);\n                    if (opt.className) el.className = opt.className;\n                    if (opt.innerHTML) {\n                        el.innerHTML = opt.innerHTML;\n                        var scripts = el.getElementsByTagName(\"script\");\n                        for(var i = scripts.length; i-- > 0; null){\n                            scripts[i].parentNode.removeChild(scripts[i]);\n                        }\n                    }\n                    for(var key in opt.style){\n                        el.style[key] = opt.style[key];\n                    }\n                    return el;\n                }; // Deep-clone a node and preserve contents/properties.\n                var cloneNode = function cloneNode(node, javascriptEnabled) {\n                    // Recursively clone the node.\n                    var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false);\n                    for(var child = node.firstChild; child; child = child.nextSibling){\n                        if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== \"SCRIPT\") {\n                            clone.appendChild(cloneNode(child, javascriptEnabled));\n                        }\n                    }\n                    if (node.nodeType === 1) {\n                        // Preserve contents/properties of special nodes.\n                        if (node.nodeName === \"CANVAS\") {\n                            clone.width = node.width;\n                            clone.height = node.height;\n                            clone.getContext(\"2d\").drawImage(node, 0, 0);\n                        } else if (node.nodeName === \"TEXTAREA\" || node.nodeName === \"SELECT\") {\n                            clone.value = node.value;\n                        } // Preserve the node's scroll position when it loads.\n                        clone.addEventListener(\"load\", function() {\n                            clone.scrollTop = node.scrollTop;\n                            clone.scrollLeft = node.scrollLeft;\n                        }, true);\n                    } // Return the cloned node.\n                    return clone;\n                }; // Convert units from px using the conversion value 'k' from jsPDF.\n                var unitConvert = function unitConvert(obj, k) {\n                    if (objType(obj) === \"number\") {\n                        return obj * 72 / 96 / k;\n                    } else {\n                        var newObj = {};\n                        for(var key in obj){\n                            newObj[key] = obj[key] * 72 / 96 / k;\n                        }\n                        return newObj;\n                    }\n                }; // Convert units to px using the conversion value 'k' from jsPDF.\n                var toPx = function toPx(val, k) {\n                    return Math.floor(val * k / 72 * 96);\n                };\n            /***/ },\n            /***/ \"./src/worker.js\": /*!***********************!*\\\n  !*** ./src/worker.js ***!\n  \\***********************/ /***/ function(__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_39690__) {\n                \"use strict\";\n                __nested_webpack_require_39690__.r(__nested_webpack_exports__);\n                /* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_39690__(/*! core-js/modules/es.object.assign.js */ \"./node_modules/core-js/modules/es.object.assign.js\");\n                /* harmony import */ var core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_39690__.n(core_js_modules_es_object_assign_js__WEBPACK_IMPORTED_MODULE_0__);\n                /* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_39690__(/*! core-js/modules/es.array.map.js */ \"./node_modules/core-js/modules/es.array.map.js\");\n                /* harmony import */ var core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_39690__.n(core_js_modules_es_array_map_js__WEBPACK_IMPORTED_MODULE_1__);\n                /* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_39690__(/*! core-js/modules/es.object.keys.js */ \"./node_modules/core-js/modules/es.object.keys.js\");\n                /* harmony import */ var core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_39690__.n(core_js_modules_es_object_keys_js__WEBPACK_IMPORTED_MODULE_2__);\n                /* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_39690__(/*! core-js/modules/es.array.concat.js */ \"./node_modules/core-js/modules/es.array.concat.js\");\n                /* harmony import */ var core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_39690__.n(core_js_modules_es_array_concat_js__WEBPACK_IMPORTED_MODULE_3__);\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_39690__(/*! core-js/modules/es.object.to-string.js */ \"./node_modules/core-js/modules/es.object.to-string.js\");\n                /* harmony import */ var core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_39690__.n(core_js_modules_es_object_to_string_js__WEBPACK_IMPORTED_MODULE_4__);\n                /* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_39690__(/*! core-js/modules/es.regexp.to-string.js */ \"./node_modules/core-js/modules/es.regexp.to-string.js\");\n                /* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __nested_webpack_require_39690__.n(core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_5__);\n                /* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_39690__(/*! core-js/modules/es.function.name.js */ \"./node_modules/core-js/modules/es.function.name.js\");\n                /* harmony import */ var core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __nested_webpack_require_39690__.n(core_js_modules_es_function_name_js__WEBPACK_IMPORTED_MODULE_6__);\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_39690__(/*! core-js/modules/web.dom-collections.for-each.js */ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\");\n                /* harmony import */ var core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/ __nested_webpack_require_39690__.n(core_js_modules_web_dom_collections_for_each_js__WEBPACK_IMPORTED_MODULE_7__);\n                /* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_39690__(/*! jspdf */ \"jspdf\");\n                /* harmony import */ var jspdf__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/ __nested_webpack_require_39690__.n(jspdf__WEBPACK_IMPORTED_MODULE_8__);\n                /* harmony import */ var html2canvas__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_39690__(/*! html2canvas */ \"html2canvas\");\n                /* harmony import */ var html2canvas__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/ __nested_webpack_require_39690__.n(html2canvas__WEBPACK_IMPORTED_MODULE_9__);\n                /* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_39690__(/*! ./utils.js */ \"./src/utils.js\");\n                /* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_39690__(/*! es6-promise */ \"./node_modules/es6-promise/dist/es6-promise.js\");\n                /* harmony import */ var es6_promise__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/ __nested_webpack_require_39690__.n(es6_promise__WEBPACK_IMPORTED_MODULE_11__);\n                var Promise = es6_promise__WEBPACK_IMPORTED_MODULE_11___default().Promise;\n                /* ----- CONSTRUCTOR ----- */ var Worker = function Worker(opt) {\n                    // Create the root parent for the proto chain, and the starting Worker.\n                    var root = Object.assign(Worker.convert(Promise.resolve()), JSON.parse(JSON.stringify(Worker.template)));\n                    var self1 = Worker.convert(Promise.resolve(), root); // Set progress, optional settings, and return.\n                    self1 = self1.setProgress(1, Worker, 1, [\n                        Worker\n                    ]);\n                    self1 = self1.set(opt);\n                    return self1;\n                }; // Boilerplate for subclassing Promise.\n                Worker.prototype = Object.create(Promise.prototype);\n                Worker.prototype.constructor = Worker; // Converts/casts promises into Workers.\n                Worker.convert = function convert(promise, inherit) {\n                    // Uses prototypal inheritance to receive changes made to ancestors' properties.\n                    promise.__proto__ = inherit || Worker.prototype;\n                    return promise;\n                };\n                Worker.template = {\n                    prop: {\n                        src: null,\n                        container: null,\n                        overlay: null,\n                        canvas: null,\n                        img: null,\n                        pdf: null,\n                        pageSize: null\n                    },\n                    progress: {\n                        val: 0,\n                        state: null,\n                        n: 0,\n                        stack: []\n                    },\n                    opt: {\n                        filename: \"file.pdf\",\n                        margin: [\n                            0,\n                            0,\n                            0,\n                            0\n                        ],\n                        image: {\n                            type: \"jpeg\",\n                            quality: 0.95\n                        },\n                        enableLinks: true,\n                        html2canvas: {},\n                        jsPDF: {}\n                    }\n                };\n                /* ----- FROM / TO ----- */ Worker.prototype.from = function from(src, type) {\n                    function getType(src) {\n                        switch((0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.objType)(src)){\n                            case \"string\":\n                                return \"string\";\n                            case \"element\":\n                                return src.nodeName.toLowerCase && src.nodeName.toLowerCase() === \"canvas\" ? \"canvas\" : \"element\";\n                            default:\n                                return \"unknown\";\n                        }\n                    }\n                    return this.then(function from_main() {\n                        type = type || getType(src);\n                        switch(type){\n                            case \"string\":\n                                return this.set({\n                                    src: (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.createElement)(\"div\", {\n                                        innerHTML: src\n                                    })\n                                });\n                            case \"element\":\n                                return this.set({\n                                    src: src\n                                });\n                            case \"canvas\":\n                                return this.set({\n                                    canvas: src\n                                });\n                            case \"img\":\n                                return this.set({\n                                    img: src\n                                });\n                            default:\n                                return this.error(\"Unknown source type.\");\n                        }\n                    });\n                };\n                Worker.prototype.to = function to(target) {\n                    // Route the 'to' request to the appropriate method.\n                    switch(target){\n                        case \"container\":\n                            return this.toContainer();\n                        case \"canvas\":\n                            return this.toCanvas();\n                        case \"img\":\n                            return this.toImg();\n                        case \"pdf\":\n                            return this.toPdf();\n                        default:\n                            return this.error(\"Invalid target.\");\n                    }\n                };\n                Worker.prototype.toContainer = function toContainer() {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkSrc() {\n                            return this.prop.src || this.error(\"Cannot duplicate - no source HTML.\");\n                        },\n                        function checkPageSize() {\n                            return this.prop.pageSize || this.setPageSize();\n                        }\n                    ];\n                    return this.thenList(prereqs).then(function toContainer_main() {\n                        // Define the CSS styles for the container and its overlay parent.\n                        var overlayCSS = {\n                            position: \"fixed\",\n                            overflow: \"hidden\",\n                            zIndex: 1000,\n                            left: 0,\n                            right: 0,\n                            bottom: 0,\n                            top: 0,\n                            backgroundColor: \"rgba(0,0,0,0.8)\"\n                        };\n                        var containerCSS = {\n                            position: \"absolute\",\n                            width: this.prop.pageSize.inner.width + this.prop.pageSize.unit,\n                            left: 0,\n                            right: 0,\n                            top: 0,\n                            height: \"auto\",\n                            margin: \"auto\",\n                            backgroundColor: \"white\"\n                        }; // Set the overlay to hidden (could be changed in the future to provide a print preview).\n                        overlayCSS.opacity = 0; // Create and attach the elements.\n                        var source = (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.cloneNode)(this.prop.src, this.opt.html2canvas.javascriptEnabled);\n                        this.prop.overlay = (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.createElement)(\"div\", {\n                            className: \"html2pdf__overlay\",\n                            style: overlayCSS\n                        });\n                        this.prop.container = (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.createElement)(\"div\", {\n                            className: \"html2pdf__container\",\n                            style: containerCSS\n                        });\n                        this.prop.container.appendChild(source);\n                        this.prop.overlay.appendChild(this.prop.container);\n                        document.body.appendChild(this.prop.overlay);\n                    });\n                };\n                Worker.prototype.toCanvas = function toCanvas() {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkContainer() {\n                            return document.body.contains(this.prop.container) || this.toContainer();\n                        }\n                    ]; // Fulfill prereqs then create the canvas.\n                    return this.thenList(prereqs).then(function toCanvas_main() {\n                        // Handle old-fashioned 'onrendered' argument.\n                        var options = Object.assign({}, this.opt.html2canvas);\n                        delete options.onrendered;\n                        return html2canvas__WEBPACK_IMPORTED_MODULE_9__(this.prop.container, options);\n                    }).then(function toCanvas_post(canvas) {\n                        // Handle old-fashioned 'onrendered' argument.\n                        var onRendered = this.opt.html2canvas.onrendered || function() {};\n                        onRendered(canvas);\n                        this.prop.canvas = canvas;\n                        document.body.removeChild(this.prop.overlay);\n                    });\n                };\n                Worker.prototype.toImg = function toImg() {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkCanvas() {\n                            return this.prop.canvas || this.toCanvas();\n                        }\n                    ]; // Fulfill prereqs then create the image.\n                    return this.thenList(prereqs).then(function toImg_main() {\n                        var imgData = this.prop.canvas.toDataURL(\"image/\" + this.opt.image.type, this.opt.image.quality);\n                        this.prop.img = document.createElement(\"img\");\n                        this.prop.img.src = imgData;\n                    });\n                };\n                Worker.prototype.toPdf = function toPdf() {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkCanvas() {\n                            return this.prop.canvas || this.toCanvas();\n                        },\n                        function checkPageSize() {\n                            return this.prop.pageSize || this.setPageSize();\n                        }\n                    ]; // Fulfill prereqs then create the image.\n                    return this.thenList(prereqs).then(function toPdf_main() {\n                        // Create local copies of frequently used properties.\n                        var canvas = this.prop.canvas;\n                        var opt = this.opt; // Calculate the number of pages.\n                        var pxFullHeight = canvas.height;\n                        var pxPageHeight = Math.floor(canvas.width * this.prop.pageSize.inner.ratio);\n                        var nPages = Math.ceil(pxFullHeight / pxPageHeight); // Define pageHeight separately so it can be trimmed on the final page.\n                        var pageHeight = this.prop.pageSize.inner.height; // Create a one-page canvas to split up the full image.\n                        var pageCanvas = document.createElement(\"canvas\");\n                        var pageCtx = pageCanvas.getContext(\"2d\");\n                        pageCanvas.width = canvas.width;\n                        pageCanvas.height = pxPageHeight; // Initialize the PDF.\n                        this.prop.pdf = this.prop.pdf || new jspdf__WEBPACK_IMPORTED_MODULE_8__.jsPDF(opt.jsPDF);\n                        for(var page = 0; page < nPages; page++){\n                            // Trim the final page to reduce file size.\n                            if (page === nPages - 1 && pxFullHeight % pxPageHeight !== 0) {\n                                pageCanvas.height = pxFullHeight % pxPageHeight;\n                                pageHeight = pageCanvas.height * this.prop.pageSize.inner.width / pageCanvas.width;\n                            } // Display the page.\n                            var w = pageCanvas.width;\n                            var h = pageCanvas.height;\n                            pageCtx.fillStyle = \"white\";\n                            pageCtx.fillRect(0, 0, w, h);\n                            pageCtx.drawImage(canvas, 0, page * pxPageHeight, w, h, 0, 0, w, h); // Add the page to the PDF.\n                            if (page) this.prop.pdf.addPage();\n                            var imgData = pageCanvas.toDataURL(\"image/\" + opt.image.type, opt.image.quality);\n                            this.prop.pdf.addImage(imgData, opt.image.type, opt.margin[1], opt.margin[0], this.prop.pageSize.inner.width, pageHeight);\n                        }\n                    });\n                };\n                /* ----- OUTPUT / SAVE ----- */ Worker.prototype.output = function output(type, options, src) {\n                    // Redirect requests to the correct function (outputPdf / outputImg).\n                    src = src || \"pdf\";\n                    if (src.toLowerCase() === \"img\" || src.toLowerCase() === \"image\") {\n                        return this.outputImg(type, options);\n                    } else {\n                        return this.outputPdf(type, options);\n                    }\n                };\n                Worker.prototype.outputPdf = function outputPdf(type, options) {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkPdf() {\n                            return this.prop.pdf || this.toPdf();\n                        }\n                    ]; // Fulfill prereqs then perform the appropriate output.\n                    return this.thenList(prereqs).then(function outputPdf_main() {\n                        /* Currently implemented output types:\n     *    https://rawgit.com/MrRio/jsPDF/master/docs/jspdf.js.html#line992\n     *  save(options), arraybuffer, blob, bloburi/bloburl,\n     *  datauristring/dataurlstring, dataurlnewwindow, datauri/dataurl\n     */ return this.prop.pdf.output(type, options);\n                    });\n                };\n                Worker.prototype.outputImg = function outputImg(type, options) {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkImg() {\n                            return this.prop.img || this.toImg();\n                        }\n                    ]; // Fulfill prereqs then perform the appropriate output.\n                    return this.thenList(prereqs).then(function outputImg_main() {\n                        switch(type){\n                            case undefined:\n                            case \"img\":\n                                return this.prop.img;\n                            case \"datauristring\":\n                            case \"dataurlstring\":\n                                return this.prop.img.src;\n                            case \"datauri\":\n                            case \"dataurl\":\n                                return document.location.href = this.prop.img.src;\n                            default:\n                                throw 'Image output type \"' + type + '\" is not supported.';\n                        }\n                    });\n                };\n                Worker.prototype.save = function save(filename) {\n                    // Set up function prerequisites.\n                    var prereqs = [\n                        function checkPdf() {\n                            return this.prop.pdf || this.toPdf();\n                        }\n                    ]; // Fulfill prereqs, update the filename (if provided), and save the PDF.\n                    return this.thenList(prereqs).set(filename ? {\n                        filename: filename\n                    } : null).then(function save_main() {\n                        this.prop.pdf.save(this.opt.filename);\n                    });\n                };\n                /* ----- SET / GET ----- */ Worker.prototype.set = function set(opt) {\n                    // TODO: Implement ordered pairs?\n                    // Silently ignore invalid or empty input.\n                    if ((0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.objType)(opt) !== \"object\") {\n                        return this;\n                    } // Build an array of setter functions to queue.\n                    var fns = Object.keys(opt || {}).map(function(key) {\n                        switch(key){\n                            case \"margin\":\n                                return this.setMargin.bind(this, opt.margin);\n                            case \"jsPDF\":\n                                return function set_jsPDF() {\n                                    this.opt.jsPDF = opt.jsPDF;\n                                    return this.setPageSize();\n                                };\n                            case \"pageSize\":\n                                return this.setPageSize.bind(this, opt.pageSize);\n                            default:\n                                if (key in Worker.template.prop) {\n                                    // Set pre-defined properties in prop.\n                                    return function set_prop() {\n                                        this.prop[key] = opt[key];\n                                    };\n                                } else {\n                                    // Set any other properties in opt.\n                                    return function set_opt() {\n                                        this.opt[key] = opt[key];\n                                    };\n                                }\n                        }\n                    }, this); // Set properties within the promise chain.\n                    return this.then(function set_main() {\n                        return this.thenList(fns);\n                    });\n                };\n                Worker.prototype.get = function get(key, cbk) {\n                    return this.then(function get_main() {\n                        // Fetch the requested property, either as a predefined prop or in opt.\n                        var val = key in Worker.template.prop ? this.prop[key] : this.opt[key];\n                        return cbk ? cbk(val) : val;\n                    });\n                };\n                Worker.prototype.setMargin = function setMargin(margin) {\n                    return this.then(function setMargin_main() {\n                        // Parse the margin property: [top, left, bottom, right].\n                        switch((0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.objType)(margin)){\n                            case \"number\":\n                                margin = [\n                                    margin,\n                                    margin,\n                                    margin,\n                                    margin\n                                ];\n                            case \"array\":\n                                if (margin.length === 2) {\n                                    margin = [\n                                        margin[0],\n                                        margin[1],\n                                        margin[0],\n                                        margin[1]\n                                    ];\n                                }\n                                if (margin.length === 4) {\n                                    break;\n                                }\n                            default:\n                                return this.error(\"Invalid margin array.\");\n                        } // Set the margin property, then update pageSize.\n                        this.opt.margin = margin;\n                    }).then(this.setPageSize);\n                };\n                Worker.prototype.setPageSize = function setPageSize(pageSize) {\n                    return this.then(function setPageSize_main() {\n                        // Retrieve page-size based on jsPDF settings, if not explicitly provided.\n                        pageSize = pageSize || jspdf__WEBPACK_IMPORTED_MODULE_8__.jsPDF.getPageSize(this.opt.jsPDF); // Add 'inner' field if not present.\n                        if (!pageSize.hasOwnProperty(\"inner\")) {\n                            pageSize.inner = {\n                                width: pageSize.width - this.opt.margin[1] - this.opt.margin[3],\n                                height: pageSize.height - this.opt.margin[0] - this.opt.margin[2]\n                            };\n                            pageSize.inner.px = {\n                                width: (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.toPx)(pageSize.inner.width, pageSize.k),\n                                height: (0, _utils_js__WEBPACK_IMPORTED_MODULE_10__.toPx)(pageSize.inner.height, pageSize.k)\n                            };\n                            pageSize.inner.ratio = pageSize.inner.height / pageSize.inner.width;\n                        } // Attach pageSize to this.\n                        this.prop.pageSize = pageSize;\n                    });\n                };\n                Worker.prototype.setProgress = function setProgress(val, state, n, stack) {\n                    // Immediately update all progress values.\n                    if (val != null) this.progress.val = val;\n                    if (state != null) this.progress.state = state;\n                    if (n != null) this.progress.n = n;\n                    if (stack != null) this.progress.stack = stack;\n                    this.progress.ratio = this.progress.val / this.progress.state; // Return this for command chaining.\n                    return this;\n                };\n                Worker.prototype.updateProgress = function updateProgress(val, state, n, stack) {\n                    // Immediately update all progress values, using setProgress.\n                    return this.setProgress(val ? this.progress.val + val : null, state ? state : null, n ? this.progress.n + n : null, stack ? this.progress.stack.concat(stack) : null);\n                };\n                /* ----- PROMISE MAPPING ----- */ Worker.prototype.then = function then(onFulfilled, onRejected) {\n                    // Wrap `this` for encapsulation.\n                    var self1 = this;\n                    return this.thenCore(onFulfilled, onRejected, function then_main(onFulfilled, onRejected) {\n                        // Update progress while queuing, calling, and resolving `then`.\n                        self1.updateProgress(null, null, 1, [\n                            onFulfilled\n                        ]);\n                        return Promise.prototype.then.call(this, function then_pre(val) {\n                            self1.updateProgress(null, onFulfilled);\n                            return val;\n                        }).then(onFulfilled, onRejected).then(function then_post(val) {\n                            self1.updateProgress(1);\n                            return val;\n                        });\n                    });\n                };\n                Worker.prototype.thenCore = function thenCore(onFulfilled, onRejected, thenBase) {\n                    // Handle optional thenBase parameter.\n                    thenBase = thenBase || Promise.prototype.then; // Wrap `this` for encapsulation and bind it to the promise handlers.\n                    var self1 = this;\n                    if (onFulfilled) {\n                        onFulfilled = onFulfilled.bind(self1);\n                    }\n                    if (onRejected) {\n                        onRejected = onRejected.bind(self1);\n                    } // Cast self into a Promise to avoid polyfills recursively defining `then`.\n                    var isNative = Promise.toString().indexOf(\"[native code]\") !== -1 && Promise.name === \"Promise\";\n                    var selfPromise = isNative ? self1 : Worker.convert(Object.assign({}, self1), Promise.prototype); // Return the promise, after casting it into a Worker and preserving props.\n                    var returnVal = thenBase.call(selfPromise, onFulfilled, onRejected);\n                    return Worker.convert(returnVal, self1.__proto__);\n                };\n                Worker.prototype.thenExternal = function thenExternal(onFulfilled, onRejected) {\n                    // Call `then` and return a standard promise (exits the Worker chain).\n                    return Promise.prototype.then.call(this, onFulfilled, onRejected);\n                };\n                Worker.prototype.thenList = function thenList(fns) {\n                    // Queue a series of promise 'factories' into the promise chain.\n                    var self1 = this;\n                    fns.forEach(function thenList_forEach(fn) {\n                        self1 = self1.thenCore(fn);\n                    });\n                    return self1;\n                };\n                Worker.prototype[\"catch\"] = function(onRejected) {\n                    // Bind `this` to the promise handler, call `catch`, and return a Worker.\n                    if (onRejected) {\n                        onRejected = onRejected.bind(this);\n                    }\n                    var returnVal = Promise.prototype[\"catch\"].call(this, onRejected);\n                    return Worker.convert(returnVal, this);\n                };\n                Worker.prototype.catchExternal = function catchExternal(onRejected) {\n                    // Call `catch` and return a standard promise (exits the Worker chain).\n                    return Promise.prototype[\"catch\"].call(this, onRejected);\n                };\n                Worker.prototype.error = function error(msg) {\n                    // Throw the error in the Promise chain.\n                    return this.then(function error_main() {\n                        throw new Error(msg);\n                    });\n                };\n                /* ----- ALIASES ----- */ Worker.prototype.using = Worker.prototype.set;\n                Worker.prototype.saveAs = Worker.prototype.save;\n                Worker.prototype.export = Worker.prototype.output;\n                Worker.prototype.run = Worker.prototype.then;\n                /* ----- FINISHING ----- */ // Expose the Worker class.\n                /* harmony default export */ __nested_webpack_exports__[\"default\"] = Worker;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/a-function.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/a-function.js ***!\n  \\******************************************************/ /***/ function(module1) {\n                module1.exports = function(it) {\n                    if (typeof it != \"function\") {\n                        throw TypeError(String(it) + \" is not a function\");\n                    }\n                    return it;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/a-possible-prototype.js\": /*!****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!\n  \\****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_71232__) {\n                var isObject = __nested_webpack_require_71232__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                module1.exports = function(it) {\n                    if (!isObject(it) && it !== null) {\n                        throw TypeError(\"Can't set \" + String(it) + \" as a prototype\");\n                    }\n                    return it;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/add-to-unscopables.js\": /*!**************************************************************!*\\\n  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!\n  \\**************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_72001__) {\n                var wellKnownSymbol = __nested_webpack_require_72001__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var create = __nested_webpack_require_72001__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\n                var definePropertyModule = __nested_webpack_require_72001__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var UNSCOPABLES = wellKnownSymbol(\"unscopables\");\n                var ArrayPrototype = Array.prototype;\n                // Array.prototype[@@unscopables]\n                // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n                if (ArrayPrototype[UNSCOPABLES] == undefined) {\n                    definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {\n                        configurable: true,\n                        value: create(null)\n                    });\n                }\n                // add a key to Array.prototype[@@unscopables]\n                module1.exports = function(key) {\n                    ArrayPrototype[UNSCOPABLES][key] = true;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/an-object.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/an-object.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_73507__) {\n                var isObject = __nested_webpack_require_73507__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                module1.exports = function(it) {\n                    if (!isObject(it)) {\n                        throw TypeError(String(it) + \" is not an object\");\n                    }\n                    return it;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-for-each.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-for-each.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_74232__) {\n                \"use strict\";\n                var $forEach = __nested_webpack_require_74232__(/*! ../internals/array-iteration */ \"./node_modules/core-js/internals/array-iteration.js\").forEach;\n                var arrayMethodIsStrict = __nested_webpack_require_74232__(/*! ../internals/array-method-is-strict */ \"./node_modules/core-js/internals/array-method-is-strict.js\");\n                var STRICT_METHOD = arrayMethodIsStrict(\"forEach\");\n                // `Array.prototype.forEach` method implementation\n                // https://tc39.es/ecma262/#sec-array.prototype.foreach\n                module1.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */ ) {\n                    return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n                // eslint-disable-next-line es/no-array-prototype-foreach -- safe\n                } : [].forEach;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-includes.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-includes.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_75462__) {\n                var toIndexedObject = __nested_webpack_require_75462__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var toLength = __nested_webpack_require_75462__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\n                var toAbsoluteIndex = __nested_webpack_require_75462__(/*! ../internals/to-absolute-index */ \"./node_modules/core-js/internals/to-absolute-index.js\");\n                // `Array.prototype.{ indexOf, includes }` methods implementation\n                var createMethod = function(IS_INCLUDES) {\n                    return function($this, el, fromIndex) {\n                        var O = toIndexedObject($this);\n                        var length = toLength(O.length);\n                        var index = toAbsoluteIndex(fromIndex, length);\n                        var value;\n                        // Array#includes uses SameValueZero equality algorithm\n                        // eslint-disable-next-line no-self-compare -- NaN check\n                        if (IS_INCLUDES && el != el) while(length > index){\n                            value = O[index++];\n                            // eslint-disable-next-line no-self-compare -- NaN check\n                            if (value != value) return true;\n                        // Array#indexOf ignores holes, Array#includes - not\n                        }\n                        else for(; length > index; index++){\n                            if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n                        }\n                        return !IS_INCLUDES && -1;\n                    };\n                };\n                module1.exports = {\n                    // `Array.prototype.includes` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.includes\n                    includes: createMethod(true),\n                    // `Array.prototype.indexOf` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.indexof\n                    indexOf: createMethod(false)\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-iteration.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-iteration.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_77931__) {\n                var bind = __nested_webpack_require_77931__(/*! ../internals/function-bind-context */ \"./node_modules/core-js/internals/function-bind-context.js\");\n                var IndexedObject = __nested_webpack_require_77931__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\n                var toObject = __nested_webpack_require_77931__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var toLength = __nested_webpack_require_77931__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\n                var arraySpeciesCreate = __nested_webpack_require_77931__(/*! ../internals/array-species-create */ \"./node_modules/core-js/internals/array-species-create.js\");\n                var push = [].push;\n                // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\n                var createMethod = function(TYPE) {\n                    var IS_MAP = TYPE == 1;\n                    var IS_FILTER = TYPE == 2;\n                    var IS_SOME = TYPE == 3;\n                    var IS_EVERY = TYPE == 4;\n                    var IS_FIND_INDEX = TYPE == 6;\n                    var IS_FILTER_REJECT = TYPE == 7;\n                    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n                    return function($this, callbackfn, that, specificCreate) {\n                        var O = toObject($this);\n                        var self1 = IndexedObject(O);\n                        var boundFunction = bind(callbackfn, that, 3);\n                        var length = toLength(self1.length);\n                        var index = 0;\n                        var create = specificCreate || arraySpeciesCreate;\n                        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n                        var value, result;\n                        for(; length > index; index++)if (NO_HOLES || index in self1) {\n                            value = self1[index];\n                            result = boundFunction(value, index, O);\n                            if (TYPE) {\n                                if (IS_MAP) target[index] = result; // map\n                                else if (result) switch(TYPE){\n                                    case 3:\n                                        return true; // some\n                                    case 5:\n                                        return value; // find\n                                    case 6:\n                                        return index; // findIndex\n                                    case 2:\n                                        push.call(target, value); // filter\n                                }\n                                else switch(TYPE){\n                                    case 4:\n                                        return false; // every\n                                    case 7:\n                                        push.call(target, value); // filterReject\n                                }\n                            }\n                        }\n                        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n                    };\n                };\n                module1.exports = {\n                    // `Array.prototype.forEach` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.foreach\n                    forEach: createMethod(0),\n                    // `Array.prototype.map` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.map\n                    map: createMethod(1),\n                    // `Array.prototype.filter` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.filter\n                    filter: createMethod(2),\n                    // `Array.prototype.some` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.some\n                    some: createMethod(3),\n                    // `Array.prototype.every` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.every\n                    every: createMethod(4),\n                    // `Array.prototype.find` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.find\n                    find: createMethod(5),\n                    // `Array.prototype.findIndex` method\n                    // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n                    findIndex: createMethod(6),\n                    // `Array.prototype.filterReject` method\n                    // https://github.com/tc39/proposal-array-filtering\n                    filterReject: createMethod(7)\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-method-has-species-support.js\": /*!****************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!\n  \\****************************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_83073__) {\n                var fails = __nested_webpack_require_83073__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var wellKnownSymbol = __nested_webpack_require_83073__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var V8_VERSION = __nested_webpack_require_83073__(/*! ../internals/engine-v8-version */ \"./node_modules/core-js/internals/engine-v8-version.js\");\n                var SPECIES = wellKnownSymbol(\"species\");\n                module1.exports = function(METHOD_NAME) {\n                    // We can't use this feature detection in V8 since it causes\n                    // deoptimization and serious performance degradation\n                    // https://github.com/zloirock/core-js/issues/677\n                    return V8_VERSION >= 51 || !fails(function() {\n                        var array = [];\n                        var constructor = array.constructor = {};\n                        constructor[SPECIES] = function() {\n                            return {\n                                foo: 1\n                            };\n                        };\n                        return array[METHOD_NAME](Boolean).foo !== 1;\n                    });\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-method-is-strict.js\": /*!******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-method-is-strict.js ***!\n  \\******************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_84706__) {\n                \"use strict\";\n                var fails = __nested_webpack_require_84706__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                module1.exports = function(METHOD_NAME, argument) {\n                    var method = [][METHOD_NAME];\n                    return !!method && fails(function() {\n                        // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing\n                        method.call(null, argument || function() {\n                            throw 1;\n                        }, 1);\n                    });\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-species-constructor.js\": /*!*********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-species-constructor.js ***!\n  \\*********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_85720__) {\n                var isObject = __nested_webpack_require_85720__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var isArray = __nested_webpack_require_85720__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n                var wellKnownSymbol = __nested_webpack_require_85720__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var SPECIES = wellKnownSymbol(\"species\");\n                // a part of `ArraySpeciesCreate` abstract operation\n                // https://tc39.es/ecma262/#sec-arrayspeciescreate\n                module1.exports = function(originalArray) {\n                    var C;\n                    if (isArray(originalArray)) {\n                        C = originalArray.constructor;\n                        // cross-realm fallback\n                        if (typeof C == \"function\" && (C === Array || isArray(C.prototype))) C = undefined;\n                        else if (isObject(C)) {\n                            C = C[SPECIES];\n                            if (C === null) C = undefined;\n                        }\n                    }\n                    return C === undefined ? Array : C;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/array-species-create.js\": /*!****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/array-species-create.js ***!\n  \\****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_87330__) {\n                var arraySpeciesConstructor = __nested_webpack_require_87330__(/*! ../internals/array-species-constructor */ \"./node_modules/core-js/internals/array-species-constructor.js\");\n                // `ArraySpeciesCreate` abstract operation\n                // https://tc39.es/ecma262/#sec-arrayspeciescreate\n                module1.exports = function(originalArray, length) {\n                    return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/classof-raw.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/classof-raw.js ***!\n  \\*******************************************************/ /***/ function(module1) {\n                var toString = {}.toString;\n                module1.exports = function(it) {\n                    return toString.call(it).slice(8, -1);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/classof.js\": /*!***************************************************!*\\\n  !*** ./node_modules/core-js/internals/classof.js ***!\n  \\***************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_88619__) {\n                var TO_STRING_TAG_SUPPORT = __nested_webpack_require_88619__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\n                var classofRaw = __nested_webpack_require_88619__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n                var wellKnownSymbol = __nested_webpack_require_88619__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n                // ES3 wrong here\n                var CORRECT_ARGUMENTS = classofRaw(function() {\n                    return arguments;\n                }()) == \"Arguments\";\n                // fallback for IE11 Script Access Denied error\n                var tryGet = function(it, key) {\n                    try {\n                        return it[key];\n                    } catch (error) {}\n                };\n                // getting tag from ES6+ `Object.prototype.toString`\n                module1.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {\n                    var O, tag, result;\n                    return it === undefined ? \"Undefined\" : it === null ? \"Null\" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == \"string\" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == \"Object\" && typeof O.callee == \"function\" ? \"Arguments\" : result;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/copy-constructor-properties.js\": /*!***********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!\n  \\***********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_90465__) {\n                var has = __nested_webpack_require_90465__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var ownKeys = __nested_webpack_require_90465__(/*! ../internals/own-keys */ \"./node_modules/core-js/internals/own-keys.js\");\n                var getOwnPropertyDescriptorModule = __nested_webpack_require_90465__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\");\n                var definePropertyModule = __nested_webpack_require_90465__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                module1.exports = function(target, source) {\n                    var keys = ownKeys(source);\n                    var defineProperty = definePropertyModule.f;\n                    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n                    for(var i = 0; i < keys.length; i++){\n                        var key = keys[i];\n                        if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n                    }\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/correct-prototype-getter.js\": /*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!\n  \\********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_91992__) {\n                var fails = __nested_webpack_require_91992__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                module1.exports = !fails(function() {\n                    function F() {}\n                    F.prototype.constructor = null;\n                    // eslint-disable-next-line es/no-object-getprototypeof -- required for testing\n                    return Object.getPrototypeOf(new F()) !== F.prototype;\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-html.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-html.js ***!\n  \\*******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_92794__) {\n                var requireObjectCoercible = __nested_webpack_require_92794__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                var toString = __nested_webpack_require_92794__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var quot = /\"/g;\n                // `CreateHTML` abstract operation\n                // https://tc39.es/ecma262/#sec-createhtml\n                module1.exports = function(string, tag, attribute, value) {\n                    var S = toString(requireObjectCoercible(string));\n                    var p1 = \"<\" + tag;\n                    if (attribute !== \"\") p1 += \" \" + attribute + '=\"' + toString(value).replace(quot, \"&quot;\") + '\"';\n                    return p1 + \">\" + S + \"</\" + tag + \">\";\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-iterator-constructor.js\": /*!***********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!\n  \\***********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_94037__) {\n                \"use strict\";\n                var IteratorPrototype = __nested_webpack_require_94037__(/*! ../internals/iterators-core */ \"./node_modules/core-js/internals/iterators-core.js\").IteratorPrototype;\n                var create = __nested_webpack_require_94037__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\n                var createPropertyDescriptor = __nested_webpack_require_94037__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                var setToStringTag = __nested_webpack_require_94037__(/*! ../internals/set-to-string-tag */ \"./node_modules/core-js/internals/set-to-string-tag.js\");\n                var Iterators = __nested_webpack_require_94037__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\n                var returnThis = function() {\n                    return this;\n                };\n                module1.exports = function(IteratorConstructor, NAME, next) {\n                    var TO_STRING_TAG = NAME + \" Iterator\";\n                    IteratorConstructor.prototype = create(IteratorPrototype, {\n                        next: createPropertyDescriptor(1, next)\n                    });\n                    setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n                    Iterators[TO_STRING_TAG] = returnThis;\n                    return IteratorConstructor;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-non-enumerable-property.js\": /*!**************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!\n  \\**************************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_95874__) {\n                var DESCRIPTORS = __nested_webpack_require_95874__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var definePropertyModule = __nested_webpack_require_95874__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var createPropertyDescriptor = __nested_webpack_require_95874__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                module1.exports = DESCRIPTORS ? function(object, key, value) {\n                    return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n                } : function(object, key, value) {\n                    object[key] = value;\n                    return object;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-property-descriptor.js\": /*!**********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!\n  \\**********************************************************************/ /***/ function(module1) {\n                module1.exports = function(bitmap, value) {\n                    return {\n                        enumerable: !(bitmap & 1),\n                        configurable: !(bitmap & 2),\n                        writable: !(bitmap & 4),\n                        value: value\n                    };\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/create-property.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/create-property.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_97727__) {\n                \"use strict\";\n                var toPropertyKey = __nested_webpack_require_97727__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n                var definePropertyModule = __nested_webpack_require_97727__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var createPropertyDescriptor = __nested_webpack_require_97727__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                module1.exports = function(object, key, value) {\n                    var propertyKey = toPropertyKey(key);\n                    if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n                    else object[propertyKey] = value;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/define-iterator.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/define-iterator.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_98940__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_98940__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var createIteratorConstructor = __nested_webpack_require_98940__(/*! ../internals/create-iterator-constructor */ \"./node_modules/core-js/internals/create-iterator-constructor.js\");\n                var getPrototypeOf = __nested_webpack_require_98940__(/*! ../internals/object-get-prototype-of */ \"./node_modules/core-js/internals/object-get-prototype-of.js\");\n                var setPrototypeOf = __nested_webpack_require_98940__(/*! ../internals/object-set-prototype-of */ \"./node_modules/core-js/internals/object-set-prototype-of.js\");\n                var setToStringTag = __nested_webpack_require_98940__(/*! ../internals/set-to-string-tag */ \"./node_modules/core-js/internals/set-to-string-tag.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_98940__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var redefine = __nested_webpack_require_98940__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var wellKnownSymbol = __nested_webpack_require_98940__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var IS_PURE = __nested_webpack_require_98940__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n                var Iterators = __nested_webpack_require_98940__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\n                var IteratorsCore = __nested_webpack_require_98940__(/*! ../internals/iterators-core */ \"./node_modules/core-js/internals/iterators-core.js\");\n                var IteratorPrototype = IteratorsCore.IteratorPrototype;\n                var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\n                var ITERATOR = wellKnownSymbol(\"iterator\");\n                var KEYS = \"keys\";\n                var VALUES = \"values\";\n                var ENTRIES = \"entries\";\n                var returnThis = function() {\n                    return this;\n                };\n                module1.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n                    createIteratorConstructor(IteratorConstructor, NAME, next);\n                    var getIterationMethod = function(KIND) {\n                        if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n                        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n                        switch(KIND){\n                            case KEYS:\n                                return function keys() {\n                                    return new IteratorConstructor(this, KIND);\n                                };\n                            case VALUES:\n                                return function values() {\n                                    return new IteratorConstructor(this, KIND);\n                                };\n                            case ENTRIES:\n                                return function entries() {\n                                    return new IteratorConstructor(this, KIND);\n                                };\n                        }\n                        return function() {\n                            return new IteratorConstructor(this);\n                        };\n                    };\n                    var TO_STRING_TAG = NAME + \" Iterator\";\n                    var INCORRECT_VALUES_NAME = false;\n                    var IterablePrototype = Iterable.prototype;\n                    var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype[\"@@iterator\"] || DEFAULT && IterablePrototype[DEFAULT];\n                    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n                    var anyNativeIterator = NAME == \"Array\" ? IterablePrototype.entries || nativeIterator : nativeIterator;\n                    var CurrentIteratorPrototype, methods, KEY;\n                    // fix native\n                    if (anyNativeIterator) {\n                        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n                        if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n                            if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n                                if (setPrototypeOf) {\n                                    setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n                                } else if (typeof CurrentIteratorPrototype[ITERATOR] != \"function\") {\n                                    createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);\n                                }\n                            }\n                            // Set @@toStringTag to native iterators\n                            setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n                            if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;\n                        }\n                    }\n                    // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n                    if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n                        INCORRECT_VALUES_NAME = true;\n                        defaultIterator = function values() {\n                            return nativeIterator.call(this);\n                        };\n                    }\n                    // define iterator\n                    if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n                        createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);\n                    }\n                    Iterators[NAME] = defaultIterator;\n                    // export additional methods\n                    if (DEFAULT) {\n                        methods = {\n                            values: getIterationMethod(VALUES),\n                            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n                            entries: getIterationMethod(ENTRIES)\n                        };\n                        if (FORCED) for(KEY in methods){\n                            if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n                                redefine(IterablePrototype, KEY, methods[KEY]);\n                            }\n                        }\n                        else $({\n                            target: NAME,\n                            proto: true,\n                            forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME\n                        }, methods);\n                    }\n                    return methods;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/define-well-known-symbol.js\": /*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/define-well-known-symbol.js ***!\n  \\********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_106241__) {\n                var path = __nested_webpack_require_106241__(/*! ../internals/path */ \"./node_modules/core-js/internals/path.js\");\n                var has = __nested_webpack_require_106241__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var wrappedWellKnownSymbolModule = __nested_webpack_require_106241__(/*! ../internals/well-known-symbol-wrapped */ \"./node_modules/core-js/internals/well-known-symbol-wrapped.js\");\n                var defineProperty = __nested_webpack_require_106241__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                module1.exports = function(NAME) {\n                    var Symbol1 = path.Symbol || (path.Symbol = {});\n                    if (!has(Symbol1, NAME)) defineProperty(Symbol1, NAME, {\n                        value: wrappedWellKnownSymbolModule.f(NAME)\n                    });\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/descriptors.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/descriptors.js ***!\n  \\*******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_107473__) {\n                var fails = __nested_webpack_require_107473__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                // Detect IE8's incomplete defineProperty implementation\n                module1.exports = !fails(function() {\n                    // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n                    return Object.defineProperty({}, 1, {\n                        get: function() {\n                            return 7;\n                        }\n                    })[1] != 7;\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/document-create-element.js\": /*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/document-create-element.js ***!\n  \\*******************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_108429__) {\n                var global1 = __nested_webpack_require_108429__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var isObject = __nested_webpack_require_108429__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var document1 = global1.document;\n                // typeof document.createElement is 'object' in old IE\n                var EXISTS = isObject(document1) && isObject(document1.createElement);\n                module1.exports = function(it) {\n                    return EXISTS ? document1.createElement(it) : {};\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/dom-iterables.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/dom-iterables.js ***!\n  \\*********************************************************/ /***/ function(module1) {\n                // iterable DOM collections\n                // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\n                module1.exports = {\n                    CSSRuleList: 0,\n                    CSSStyleDeclaration: 0,\n                    CSSValueList: 0,\n                    ClientRectList: 0,\n                    DOMRectList: 0,\n                    DOMStringList: 0,\n                    DOMTokenList: 1,\n                    DataTransferItemList: 0,\n                    FileList: 0,\n                    HTMLAllCollection: 0,\n                    HTMLCollection: 0,\n                    HTMLFormElement: 0,\n                    HTMLSelectElement: 0,\n                    MediaList: 0,\n                    MimeTypeArray: 0,\n                    NamedNodeMap: 0,\n                    NodeList: 1,\n                    PaintRequestList: 0,\n                    Plugin: 0,\n                    PluginArray: 0,\n                    SVGLengthList: 0,\n                    SVGNumberList: 0,\n                    SVGPathSegList: 0,\n                    SVGPointList: 0,\n                    SVGStringList: 0,\n                    SVGTransformList: 0,\n                    SourceBufferList: 0,\n                    StyleSheetList: 0,\n                    TextTrackCueList: 0,\n                    TextTrackList: 0,\n                    TouchList: 0\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/engine-user-agent.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/engine-user-agent.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_111081__) {\n                var getBuiltIn = __nested_webpack_require_111081__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                module1.exports = getBuiltIn(\"navigator\", \"userAgent\") || \"\";\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/engine-v8-version.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/engine-v8-version.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_111667__) {\n                var global1 = __nested_webpack_require_111667__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var userAgent = __nested_webpack_require_111667__(/*! ../internals/engine-user-agent */ \"./node_modules/core-js/internals/engine-user-agent.js\");\n                var process1 = global1.process;\n                var Deno = global1.Deno;\n                var versions = process1 && process1.versions || Deno && Deno.version;\n                var v8 = versions && versions.v8;\n                var match, version;\n                if (v8) {\n                    match = v8.split(\".\");\n                    version = match[0] < 4 ? 1 : match[0] + match[1];\n                } else if (userAgent) {\n                    match = userAgent.match(/Edge\\/(\\d+)/);\n                    if (!match || match[1] >= 74) {\n                        match = userAgent.match(/Chrome\\/(\\d+)/);\n                        if (match) version = match[1];\n                    }\n                }\n                module1.exports = version && +version;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/enum-bug-keys.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!\n  \\*********************************************************/ /***/ function(module1) {\n                // IE8- don't enum bug keys\n                module1.exports = [\n                    \"constructor\",\n                    \"hasOwnProperty\",\n                    \"isPrototypeOf\",\n                    \"propertyIsEnumerable\",\n                    \"toLocaleString\",\n                    \"toString\",\n                    \"valueOf\"\n                ];\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/export.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/export.js ***!\n  \\**************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_113691__) {\n                var global1 = __nested_webpack_require_113691__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var getOwnPropertyDescriptor = __nested_webpack_require_113691__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\").f;\n                var createNonEnumerableProperty = __nested_webpack_require_113691__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var redefine = __nested_webpack_require_113691__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var setGlobal = __nested_webpack_require_113691__(/*! ../internals/set-global */ \"./node_modules/core-js/internals/set-global.js\");\n                var copyConstructorProperties = __nested_webpack_require_113691__(/*! ../internals/copy-constructor-properties */ \"./node_modules/core-js/internals/copy-constructor-properties.js\");\n                var isForced = __nested_webpack_require_113691__(/*! ../internals/is-forced */ \"./node_modules/core-js/internals/is-forced.js\");\n                /*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/ module1.exports = function(options, source) {\n                    var TARGET = options.target;\n                    var GLOBAL = options.global;\n                    var STATIC = options.stat;\n                    var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n                    if (GLOBAL) {\n                        target = global1;\n                    } else if (STATIC) {\n                        target = global1[TARGET] || setGlobal(TARGET, {});\n                    } else {\n                        target = (global1[TARGET] || {}).prototype;\n                    }\n                    if (target) for(key in source){\n                        sourceProperty = source[key];\n                        if (options.noTargetGet) {\n                            descriptor = getOwnPropertyDescriptor(target, key);\n                            targetProperty = descriptor && descriptor.value;\n                        } else targetProperty = target[key];\n                        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? \".\" : \"#\") + key, options.forced);\n                        // contained in target\n                        if (!FORCED && targetProperty !== undefined) {\n                            if (typeof sourceProperty === typeof targetProperty) continue;\n                            copyConstructorProperties(sourceProperty, targetProperty);\n                        }\n                        // add a flag to not completely full polyfills\n                        if (options.sham || targetProperty && targetProperty.sham) {\n                            createNonEnumerableProperty(sourceProperty, \"sham\", true);\n                        }\n                        // extend global\n                        redefine(target, key, sourceProperty, options);\n                    }\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/fails.js\": /*!*************************************************!*\\\n  !*** ./node_modules/core-js/internals/fails.js ***!\n  \\*************************************************/ /***/ function(module1) {\n                module1.exports = function(exec) {\n                    try {\n                        return !!exec();\n                    } catch (error) {\n                        return true;\n                    }\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/function-bind-context.js\": /*!*****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/function-bind-context.js ***!\n  \\*****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_118352__) {\n                var aFunction = __nested_webpack_require_118352__(/*! ../internals/a-function */ \"./node_modules/core-js/internals/a-function.js\");\n                // optional / simple context binding\n                module1.exports = function(fn, that, length) {\n                    aFunction(fn);\n                    if (that === undefined) return fn;\n                    switch(length){\n                        case 0:\n                            return function() {\n                                return fn.call(that);\n                            };\n                        case 1:\n                            return function(a) {\n                                return fn.call(that, a);\n                            };\n                        case 2:\n                            return function(a, b) {\n                                return fn.call(that, a, b);\n                            };\n                        case 3:\n                            return function(a, b, c) {\n                                return fn.call(that, a, b, c);\n                            };\n                    }\n                    return function() {\n                        return fn.apply(that, arguments);\n                    };\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/get-built-in.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/get-built-in.js ***!\n  \\********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_119929__) {\n                var global1 = __nested_webpack_require_119929__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var aFunction = function(variable) {\n                    return typeof variable == \"function\" ? variable : undefined;\n                };\n                module1.exports = function(namespace, method) {\n                    return arguments.length < 2 ? aFunction(global1[namespace]) : global1[namespace] && global1[namespace][method];\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/global.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/global.js ***!\n  \\**************************************************/ /***/ function(module1) {\n                var check = function(it) {\n                    return it && it.Math == Math && it;\n                };\n                // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n                module1.exports = // eslint-disable-next-line es/no-global-this -- safe\n                check(typeof globalThis == \"object\" && globalThis) || check( false && 0) || // eslint-disable-next-line no-restricted-globals -- safe\n                check(typeof self == \"object\" && self) || check(typeof global == \"object\" && global) || // eslint-disable-next-line no-new-func -- fallback\n                function() {\n                    return this;\n                }() || Function(\"return this\")();\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/has.js\": /*!***********************************************!*\\\n  !*** ./node_modules/core-js/internals/has.js ***!\n  \\***********************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_121746__) {\n                var toObject = __nested_webpack_require_121746__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var hasOwnProperty = {}.hasOwnProperty;\n                module1.exports = Object.hasOwn || function hasOwn(it, key) {\n                    return hasOwnProperty.call(toObject(it), key);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/hidden-keys.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/hidden-keys.js ***!\n  \\*******************************************************/ /***/ function(module1) {\n                module1.exports = {};\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/html.js\": /*!************************************************!*\\\n  !*** ./node_modules/core-js/internals/html.js ***!\n  \\************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_122750__) {\n                var getBuiltIn = __nested_webpack_require_122750__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                module1.exports = getBuiltIn(\"document\", \"documentElement\");\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/ie8-dom-define.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_123323__) {\n                var DESCRIPTORS = __nested_webpack_require_123323__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var fails = __nested_webpack_require_123323__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var createElement = __nested_webpack_require_123323__(/*! ../internals/document-create-element */ \"./node_modules/core-js/internals/document-create-element.js\");\n                // Thank's IE8 for his funny defineProperty\n                module1.exports = !DESCRIPTORS && !fails(function() {\n                    // eslint-disable-next-line es/no-object-defineproperty -- requied for testing\n                    return Object.defineProperty(createElement(\"div\"), \"a\", {\n                        get: function() {\n                            return 7;\n                        }\n                    }).a != 7;\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/indexed-object.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/indexed-object.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_124566__) {\n                var fails = __nested_webpack_require_124566__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var classof = __nested_webpack_require_124566__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n                var split = \"\".split;\n                // fallback for non-array-like ES3 and non-enumerable old V8 strings\n                module1.exports = fails(function() {\n                    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n                    // eslint-disable-next-line no-prototype-builtins -- safe\n                    return !Object(\"z\").propertyIsEnumerable(0);\n                }) ? function(it) {\n                    return classof(it) == \"String\" ? split.call(it, \"\") : Object(it);\n                } : Object;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/inherit-if-required.js\": /*!***************************************************************!*\\\n  !*** ./node_modules/core-js/internals/inherit-if-required.js ***!\n  \\***************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_125763__) {\n                var isObject = __nested_webpack_require_125763__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var setPrototypeOf = __nested_webpack_require_125763__(/*! ../internals/object-set-prototype-of */ \"./node_modules/core-js/internals/object-set-prototype-of.js\");\n                // makes subclassing work correct for wrapped built-ins\n                module1.exports = function($this, dummy, Wrapper) {\n                    var NewTarget, NewTargetPrototype;\n                    if (// it can work only with native `setPrototypeOf`\n                    setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n                    typeof (NewTarget = dummy.constructor) == \"function\" && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);\n                    return $this;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/inspect-source.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/inspect-source.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_127098__) {\n                var store = __nested_webpack_require_127098__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n                var functionToString = Function.toString;\n                // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\n                if (typeof store.inspectSource != \"function\") {\n                    store.inspectSource = function(it) {\n                        return functionToString.call(it);\n                    };\n                }\n                module1.exports = store.inspectSource;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/internal-state.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/internal-state.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_128018__) {\n                var NATIVE_WEAK_MAP = __nested_webpack_require_128018__(/*! ../internals/native-weak-map */ \"./node_modules/core-js/internals/native-weak-map.js\");\n                var global1 = __nested_webpack_require_128018__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var isObject = __nested_webpack_require_128018__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_128018__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var objectHas = __nested_webpack_require_128018__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var shared = __nested_webpack_require_128018__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n                var sharedKey = __nested_webpack_require_128018__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n                var hiddenKeys = __nested_webpack_require_128018__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n                var OBJECT_ALREADY_INITIALIZED = \"Object already initialized\";\n                var WeakMap = global1.WeakMap;\n                var set, get, has;\n                var enforce = function(it) {\n                    return has(it) ? get(it) : set(it, {});\n                };\n                var getterFor = function(TYPE) {\n                    return function(it) {\n                        var state;\n                        if (!isObject(it) || (state = get(it)).type !== TYPE) {\n                            throw TypeError(\"Incompatible receiver, \" + TYPE + \" required\");\n                        }\n                        return state;\n                    };\n                };\n                if (NATIVE_WEAK_MAP || shared.state) {\n                    var store = shared.state || (shared.state = new WeakMap());\n                    var wmget = store.get;\n                    var wmhas = store.has;\n                    var wmset = store.set;\n                    set = function(it, metadata) {\n                        if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n                        metadata.facade = it;\n                        wmset.call(store, it, metadata);\n                        return metadata;\n                    };\n                    get = function(it) {\n                        return wmget.call(store, it) || {};\n                    };\n                    has = function(it) {\n                        return wmhas.call(store, it);\n                    };\n                } else {\n                    var STATE = sharedKey(\"state\");\n                    hiddenKeys[STATE] = true;\n                    set = function(it, metadata) {\n                        if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n                        metadata.facade = it;\n                        createNonEnumerableProperty(it, STATE, metadata);\n                        return metadata;\n                    };\n                    get = function(it) {\n                        return objectHas(it, STATE) ? it[STATE] : {};\n                    };\n                    has = function(it) {\n                        return objectHas(it, STATE);\n                    };\n                }\n                module1.exports = {\n                    set: set,\n                    get: get,\n                    has: has,\n                    enforce: enforce,\n                    getterFor: getterFor\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-array.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-array.js ***!\n  \\****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_131938__) {\n                var classof = __nested_webpack_require_131938__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n                // `IsArray` abstract operation\n                // https://tc39.es/ecma262/#sec-isarray\n                // eslint-disable-next-line es/no-array-isarray -- safe\n                module1.exports = Array.isArray || function isArray(arg) {\n                    return classof(arg) == \"Array\";\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-forced.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-forced.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_132731__) {\n                var fails = __nested_webpack_require_132731__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var replacement = /#|\\.prototype\\./;\n                var isForced = function(feature, detection) {\n                    var value = data[normalize(feature)];\n                    return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == \"function\" ? fails(detection) : !!detection;\n                };\n                var normalize = isForced.normalize = function(string) {\n                    return String(string).replace(replacement, \".\").toLowerCase();\n                };\n                var data = isForced.data = {};\n                var NATIVE = isForced.NATIVE = \"N\";\n                var POLYFILL = isForced.POLYFILL = \"P\";\n                module1.exports = isForced;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-object.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-object.js ***!\n  \\*****************************************************/ /***/ function(module1) {\n                module1.exports = function(it) {\n                    return typeof it === \"object\" ? it !== null : typeof it === \"function\";\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-pure.js\": /*!***************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-pure.js ***!\n  \\***************************************************/ /***/ function(module1) {\n                module1.exports = false;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/is-symbol.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/is-symbol.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_134671__) {\n                var getBuiltIn = __nested_webpack_require_134671__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                var USE_SYMBOL_AS_UID = __nested_webpack_require_134671__(/*! ../internals/use-symbol-as-uid */ \"./node_modules/core-js/internals/use-symbol-as-uid.js\");\n                module1.exports = USE_SYMBOL_AS_UID ? function(it) {\n                    return typeof it == \"symbol\";\n                } : function(it) {\n                    var $Symbol = getBuiltIn(\"Symbol\");\n                    return typeof $Symbol == \"function\" && Object(it) instanceof $Symbol;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/iterators-core.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/internals/iterators-core.js ***!\n  \\**********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_135642__) {\n                \"use strict\";\n                var fails = __nested_webpack_require_135642__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var getPrototypeOf = __nested_webpack_require_135642__(/*! ../internals/object-get-prototype-of */ \"./node_modules/core-js/internals/object-get-prototype-of.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_135642__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var has = __nested_webpack_require_135642__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var wellKnownSymbol = __nested_webpack_require_135642__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var IS_PURE = __nested_webpack_require_135642__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n                var ITERATOR = wellKnownSymbol(\"iterator\");\n                var BUGGY_SAFARI_ITERATORS = false;\n                var returnThis = function() {\n                    return this;\n                };\n                // `%IteratorPrototype%` object\n                // https://tc39.es/ecma262/#sec-%iteratorprototype%-object\n                var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\n                /* eslint-disable es/no-array-prototype-keys -- safe */ if ([].keys) {\n                    arrayIterator = [].keys();\n                    // Safari 8 has buggy iterators w/o `next`\n                    if (!(\"next\" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;\n                    else {\n                        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n                        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n                    }\n                }\n                var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function() {\n                    var test = {};\n                    // FF44- legacy iterators case\n                    return IteratorPrototype[ITERATOR].call(test) !== test;\n                });\n                if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};\n                // `%IteratorPrototype%[@@iterator]()` method\n                // https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\n                if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {\n                    createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\n                }\n                module1.exports = {\n                    IteratorPrototype: IteratorPrototype,\n                    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/iterators.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/iterators.js ***!\n  \\*****************************************************/ /***/ function(module1) {\n                module1.exports = {};\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/native-symbol.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/native-symbol.js ***!\n  \\*********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_139113__) {\n                /* eslint-disable es/no-symbol -- required for testing */ var V8_VERSION = __nested_webpack_require_139113__(/*! ../internals/engine-v8-version */ \"./node_modules/core-js/internals/engine-v8-version.js\");\n                var fails = __nested_webpack_require_139113__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                // eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\n                module1.exports = !!Object.getOwnPropertySymbols && !fails(function() {\n                    var symbol = Symbol();\n                    // Chrome 38 Symbol has incorrect toString conversion\n                    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n                    return !String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n                    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/native-weak-map.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/native-weak-map.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_140480__) {\n                var global1 = __nested_webpack_require_140480__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var inspectSource = __nested_webpack_require_140480__(/*! ../internals/inspect-source */ \"./node_modules/core-js/internals/inspect-source.js\");\n                var WeakMap = global1.WeakMap;\n                module1.exports = typeof WeakMap === \"function\" && /native code/.test(inspectSource(WeakMap));\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-assign.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-assign.js ***!\n  \\*********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_141261__) {\n                \"use strict\";\n                var DESCRIPTORS = __nested_webpack_require_141261__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var fails = __nested_webpack_require_141261__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var objectKeys = __nested_webpack_require_141261__(/*! ../internals/object-keys */ \"./node_modules/core-js/internals/object-keys.js\");\n                var getOwnPropertySymbolsModule = __nested_webpack_require_141261__(/*! ../internals/object-get-own-property-symbols */ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\");\n                var propertyIsEnumerableModule = __nested_webpack_require_141261__(/*! ../internals/object-property-is-enumerable */ \"./node_modules/core-js/internals/object-property-is-enumerable.js\");\n                var toObject = __nested_webpack_require_141261__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var IndexedObject = __nested_webpack_require_141261__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\n                // eslint-disable-next-line es/no-object-assign -- safe\n                var $assign = Object.assign;\n                // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n                var defineProperty = Object.defineProperty;\n                // `Object.assign` method\n                // https://tc39.es/ecma262/#sec-object.assign\n                module1.exports = !$assign || fails(function() {\n                    // should have correct order of operations (Edge bug)\n                    if (DESCRIPTORS && $assign({\n                        b: 1\n                    }, $assign(defineProperty({}, \"a\", {\n                        enumerable: true,\n                        get: function() {\n                            defineProperty(this, \"b\", {\n                                value: 3,\n                                enumerable: false\n                            });\n                        }\n                    }), {\n                        b: 2\n                    })).b !== 1) return true;\n                    // should work with symbols and should have deterministic property order (V8 bug)\n                    var A = {};\n                    var B = {};\n                    // eslint-disable-next-line es/no-symbol -- safe\n                    var symbol = Symbol();\n                    var alphabet = \"abcdefghijklmnopqrst\";\n                    A[symbol] = 7;\n                    alphabet.split(\"\").forEach(function(chr) {\n                        B[chr] = chr;\n                    });\n                    return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join(\"\") != alphabet;\n                }) ? function assign(target, source) {\n                    var T = toObject(target);\n                    var argumentsLength = arguments.length;\n                    var index = 1;\n                    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n                    var propertyIsEnumerable = propertyIsEnumerableModule.f;\n                    while(argumentsLength > index){\n                        var S = IndexedObject(arguments[index++]);\n                        var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n                        var length = keys.length;\n                        var j = 0;\n                        var key;\n                        while(length > j){\n                            key = keys[j++];\n                            if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n                        }\n                    }\n                    return T;\n                } : $assign;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-create.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-create.js ***!\n  \\*********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_145352__) {\n                /* global ActiveXObject -- old IE, WSH */ var anObject = __nested_webpack_require_145352__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var defineProperties = __nested_webpack_require_145352__(/*! ../internals/object-define-properties */ \"./node_modules/core-js/internals/object-define-properties.js\");\n                var enumBugKeys = __nested_webpack_require_145352__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n                var hiddenKeys = __nested_webpack_require_145352__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n                var html = __nested_webpack_require_145352__(/*! ../internals/html */ \"./node_modules/core-js/internals/html.js\");\n                var documentCreateElement = __nested_webpack_require_145352__(/*! ../internals/document-create-element */ \"./node_modules/core-js/internals/document-create-element.js\");\n                var sharedKey = __nested_webpack_require_145352__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n                var GT = \">\";\n                var LT = \"<\";\n                var PROTOTYPE = \"prototype\";\n                var SCRIPT = \"script\";\n                var IE_PROTO = sharedKey(\"IE_PROTO\");\n                var EmptyConstructor = function() {};\n                var scriptTag = function(content) {\n                    return LT + SCRIPT + GT + content + LT + \"/\" + SCRIPT + GT;\n                };\n                // Create object with fake `null` prototype: use ActiveX Object with cleared prototype\n                var NullProtoObjectViaActiveX = function(activeXDocument) {\n                    activeXDocument.write(scriptTag(\"\"));\n                    activeXDocument.close();\n                    var temp = activeXDocument.parentWindow.Object;\n                    activeXDocument = null; // avoid memory leak\n                    return temp;\n                };\n                // Create object with fake `null` prototype: use iframe Object with cleared prototype\n                var NullProtoObjectViaIFrame = function() {\n                    // Thrash, waste and sodomy: IE GC bug\n                    var iframe = documentCreateElement(\"iframe\");\n                    var JS = \"java\" + SCRIPT + \":\";\n                    var iframeDocument;\n                    if (iframe.style) {\n                        iframe.style.display = \"none\";\n                        html.appendChild(iframe);\n                        // https://github.com/zloirock/core-js/issues/475\n                        iframe.src = String(JS);\n                        iframeDocument = iframe.contentWindow.document;\n                        iframeDocument.open();\n                        iframeDocument.write(scriptTag(\"document.F=Object\"));\n                        iframeDocument.close();\n                        return iframeDocument.F;\n                    }\n                };\n                // Check for document.domain and active x support\n                // No need to use active x approach when document.domain is not set\n                // see https://github.com/es-shims/es5-shim/issues/150\n                // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n                // avoid IE GC bug\n                var activeXDocument;\n                var NullProtoObject = function() {\n                    try {\n                        activeXDocument = new ActiveXObject(\"htmlfile\");\n                    } catch (error) {}\n                    NullProtoObject = document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() || NullProtoObjectViaActiveX(activeXDocument); // WSH\n                    var length = enumBugKeys.length;\n                    while(length--)delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n                    return NullProtoObject();\n                };\n                hiddenKeys[IE_PROTO] = true;\n                // `Object.create` method\n                // https://tc39.es/ecma262/#sec-object.create\n                module1.exports = Object.create || function create(O, Properties) {\n                    var result;\n                    if (O !== null) {\n                        EmptyConstructor[PROTOTYPE] = anObject(O);\n                        result = new EmptyConstructor();\n                        EmptyConstructor[PROTOTYPE] = null;\n                        // add \"__proto__\" for Object.getPrototypeOf polyfill\n                        result[IE_PROTO] = O;\n                    } else result = NullProtoObject();\n                    return Properties === undefined ? result : defineProperties(result, Properties);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-define-properties.js\": /*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-define-properties.js ***!\n  \\********************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_150417__) {\n                var DESCRIPTORS = __nested_webpack_require_150417__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var definePropertyModule = __nested_webpack_require_150417__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var anObject = __nested_webpack_require_150417__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var objectKeys = __nested_webpack_require_150417__(/*! ../internals/object-keys */ \"./node_modules/core-js/internals/object-keys.js\");\n                // `Object.defineProperties` method\n                // https://tc39.es/ecma262/#sec-object.defineproperties\n                // eslint-disable-next-line es/no-object-defineproperties -- safe\n                module1.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n                    anObject(O);\n                    var keys = objectKeys(Properties);\n                    var length = keys.length;\n                    var index = 0;\n                    var key;\n                    while(length > index)definePropertyModule.f(O, key = keys[index++], Properties[key]);\n                    return O;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-define-property.js\": /*!******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-define-property.js ***!\n  \\******************************************************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_152057__) {\n                var DESCRIPTORS = __nested_webpack_require_152057__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var IE8_DOM_DEFINE = __nested_webpack_require_152057__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\n                var anObject = __nested_webpack_require_152057__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var toPropertyKey = __nested_webpack_require_152057__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n                // eslint-disable-next-line es/no-object-defineproperty -- safe\n                var $defineProperty = Object.defineProperty;\n                // `Object.defineProperty` method\n                // https://tc39.es/ecma262/#sec-object.defineproperty\n                exports1.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {\n                    anObject(O);\n                    P = toPropertyKey(P);\n                    anObject(Attributes);\n                    if (IE8_DOM_DEFINE) try {\n                        return $defineProperty(O, P, Attributes);\n                    } catch (error) {}\n                    if (\"get\" in Attributes || \"set\" in Attributes) throw TypeError(\"Accessors not supported\");\n                    if (\"value\" in Attributes) O[P] = Attributes.value;\n                    return O;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\": /*!******************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!\n  \\******************************************************************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_153925__) {\n                var DESCRIPTORS = __nested_webpack_require_153925__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var propertyIsEnumerableModule = __nested_webpack_require_153925__(/*! ../internals/object-property-is-enumerable */ \"./node_modules/core-js/internals/object-property-is-enumerable.js\");\n                var createPropertyDescriptor = __nested_webpack_require_153925__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                var toIndexedObject = __nested_webpack_require_153925__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var toPropertyKey = __nested_webpack_require_153925__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n                var has = __nested_webpack_require_153925__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var IE8_DOM_DEFINE = __nested_webpack_require_153925__(/*! ../internals/ie8-dom-define */ \"./node_modules/core-js/internals/ie8-dom-define.js\");\n                // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n                var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n                // `Object.getOwnPropertyDescriptor` method\n                // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n                exports1.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n                    O = toIndexedObject(O);\n                    P = toPropertyKey(P);\n                    if (IE8_DOM_DEFINE) try {\n                        return $getOwnPropertyDescriptor(O, P);\n                    } catch (error) {}\n                    if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-own-property-names-external.js\": /*!**********************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!\n  \\**********************************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_156243__) {\n                /* eslint-disable es/no-object-getownpropertynames -- safe */ var toIndexedObject = __nested_webpack_require_156243__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var $getOwnPropertyNames = __nested_webpack_require_156243__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\").f;\n                var toString = {}.toString;\n                var windowNames =  false ? 0 : [];\n                var getWindowNames = function(it) {\n                    try {\n                        return $getOwnPropertyNames(it);\n                    } catch (error) {\n                        return windowNames.slice();\n                    }\n                };\n                // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n                module1.exports.f = function getOwnPropertyNames(it) {\n                    return windowNames && toString.call(it) == \"[object Window]\" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-own-property-names.js\": /*!*************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!\n  \\*************************************************************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_157842__) {\n                var internalObjectKeys = __nested_webpack_require_157842__(/*! ../internals/object-keys-internal */ \"./node_modules/core-js/internals/object-keys-internal.js\");\n                var enumBugKeys = __nested_webpack_require_157842__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n                var hiddenKeys = enumBugKeys.concat(\"length\", \"prototype\");\n                // `Object.getOwnPropertyNames` method\n                // https://tc39.es/ecma262/#sec-object.getownpropertynames\n                // eslint-disable-next-line es/no-object-getownpropertynames -- safe\n                exports1.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n                    return internalObjectKeys(O, hiddenKeys);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\": /*!***************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!\n  \\***************************************************************************/ /***/ function(__unused_webpack_module, exports1) {\n                // eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\n                exports1.f = Object.getOwnPropertySymbols;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-get-prototype-of.js\": /*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!\n  \\*******************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_159555__) {\n                var has = __nested_webpack_require_159555__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var toObject = __nested_webpack_require_159555__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var sharedKey = __nested_webpack_require_159555__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n                var CORRECT_PROTOTYPE_GETTER = __nested_webpack_require_159555__(/*! ../internals/correct-prototype-getter */ \"./node_modules/core-js/internals/correct-prototype-getter.js\");\n                var IE_PROTO = sharedKey(\"IE_PROTO\");\n                var ObjectPrototype = Object.prototype;\n                // `Object.getPrototypeOf` method\n                // https://tc39.es/ecma262/#sec-object.getprototypeof\n                // eslint-disable-next-line es/no-object-getprototypeof -- safe\n                module1.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {\n                    O = toObject(O);\n                    if (has(O, IE_PROTO)) return O[IE_PROTO];\n                    if (typeof O.constructor == \"function\" && O instanceof O.constructor) {\n                        return O.constructor.prototype;\n                    }\n                    return O instanceof Object ? ObjectPrototype : null;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-keys-internal.js\": /*!****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!\n  \\****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_161262__) {\n                var has = __nested_webpack_require_161262__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var toIndexedObject = __nested_webpack_require_161262__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var indexOf = __nested_webpack_require_161262__(/*! ../internals/array-includes */ \"./node_modules/core-js/internals/array-includes.js\").indexOf;\n                var hiddenKeys = __nested_webpack_require_161262__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n                module1.exports = function(object, names) {\n                    var O = toIndexedObject(object);\n                    var i = 0;\n                    var result = [];\n                    var key;\n                    for(key in O)!has(hiddenKeys, key) && has(O, key) && result.push(key);\n                    // Don't enum bug & hidden keys\n                    while(names.length > i)if (has(O, key = names[i++])) {\n                        ~indexOf(result, key) || result.push(key);\n                    }\n                    return result;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-keys.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-keys.js ***!\n  \\*******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_162731__) {\n                var internalObjectKeys = __nested_webpack_require_162731__(/*! ../internals/object-keys-internal */ \"./node_modules/core-js/internals/object-keys-internal.js\");\n                var enumBugKeys = __nested_webpack_require_162731__(/*! ../internals/enum-bug-keys */ \"./node_modules/core-js/internals/enum-bug-keys.js\");\n                // `Object.keys` method\n                // https://tc39.es/ecma262/#sec-object.keys\n                // eslint-disable-next-line es/no-object-keys -- safe\n                module1.exports = Object.keys || function keys(O) {\n                    return internalObjectKeys(O, enumBugKeys);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-property-is-enumerable.js\": /*!*************************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!\n  \\*************************************************************************/ /***/ function(__unused_webpack_module, exports1) {\n                \"use strict\";\n                var $propertyIsEnumerable = {}.propertyIsEnumerable;\n                // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n                var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n                // Nashorn ~ JDK8 bug\n                var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({\n                    1: 2\n                }, 1);\n                // `Object.prototype.propertyIsEnumerable` method implementation\n                // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\n                exports1.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n                    var descriptor = getOwnPropertyDescriptor(this, V);\n                    return !!descriptor && descriptor.enumerable;\n                } : $propertyIsEnumerable;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-set-prototype-of.js\": /*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!\n  \\*******************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_165018__) {\n                /* eslint-disable no-proto -- safe */ var anObject = __nested_webpack_require_165018__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var aPossiblePrototype = __nested_webpack_require_165018__(/*! ../internals/a-possible-prototype */ \"./node_modules/core-js/internals/a-possible-prototype.js\");\n                // `Object.setPrototypeOf` method\n                // https://tc39.es/ecma262/#sec-object.setprototypeof\n                // Works with __proto__ only. Old v8 can't work with null proto objects.\n                // eslint-disable-next-line es/no-object-setprototypeof -- safe\n                module1.exports = Object.setPrototypeOf || (\"__proto__\" in {} ? function() {\n                    var CORRECT_SETTER = false;\n                    var test = {};\n                    var setter;\n                    try {\n                        // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n                        setter = Object.getOwnPropertyDescriptor(Object.prototype, \"__proto__\").set;\n                        setter.call(test, []);\n                        CORRECT_SETTER = test instanceof Array;\n                    } catch (error) {}\n                    return function setPrototypeOf(O, proto) {\n                        anObject(O);\n                        aPossiblePrototype(proto);\n                        if (CORRECT_SETTER) setter.call(O, proto);\n                        else O.__proto__ = proto;\n                        return O;\n                    };\n                }() : undefined);\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/object-to-string.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/internals/object-to-string.js ***!\n  \\************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_166946__) {\n                \"use strict\";\n                var TO_STRING_TAG_SUPPORT = __nested_webpack_require_166946__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\n                var classof = __nested_webpack_require_166946__(/*! ../internals/classof */ \"./node_modules/core-js/internals/classof.js\");\n                // `Object.prototype.toString` method implementation\n                // https://tc39.es/ecma262/#sec-object.prototype.tostring\n                module1.exports = TO_STRING_TAG_SUPPORT ? ({}).toString : function toString() {\n                    return \"[object \" + classof(this) + \"]\";\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/ordinary-to-primitive.js\": /*!*****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!\n  \\*****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_167974__) {\n                var isObject = __nested_webpack_require_167974__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                // `OrdinaryToPrimitive` abstract operation\n                // https://tc39.es/ecma262/#sec-ordinarytoprimitive\n                module1.exports = function(input, pref) {\n                    var fn, val;\n                    if (pref === \"string\" && typeof (fn = input.toString) == \"function\" && !isObject(val = fn.call(input))) return val;\n                    if (typeof (fn = input.valueOf) == \"function\" && !isObject(val = fn.call(input))) return val;\n                    if (pref !== \"string\" && typeof (fn = input.toString) == \"function\" && !isObject(val = fn.call(input))) return val;\n                    throw TypeError(\"Can't convert object to primitive value\");\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/own-keys.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/internals/own-keys.js ***!\n  \\****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_169142__) {\n                var getBuiltIn = __nested_webpack_require_169142__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                var getOwnPropertyNamesModule = __nested_webpack_require_169142__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\");\n                var getOwnPropertySymbolsModule = __nested_webpack_require_169142__(/*! ../internals/object-get-own-property-symbols */ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\");\n                var anObject = __nested_webpack_require_169142__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                // all object keys, includes non-enumerable and symbols\n                module1.exports = getBuiltIn(\"Reflect\", \"ownKeys\") || function ownKeys(it) {\n                    var keys = getOwnPropertyNamesModule.f(anObject(it));\n                    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n                    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/path.js\": /*!************************************************!*\\\n  !*** ./node_modules/core-js/internals/path.js ***!\n  \\************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_170546__) {\n                var global1 = __nested_webpack_require_170546__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                module1.exports = global1;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/redefine.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/internals/redefine.js ***!\n  \\****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_171046__) {\n                var global1 = __nested_webpack_require_171046__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_171046__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var has = __nested_webpack_require_171046__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var setGlobal = __nested_webpack_require_171046__(/*! ../internals/set-global */ \"./node_modules/core-js/internals/set-global.js\");\n                var inspectSource = __nested_webpack_require_171046__(/*! ../internals/inspect-source */ \"./node_modules/core-js/internals/inspect-source.js\");\n                var InternalStateModule = __nested_webpack_require_171046__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n                var getInternalState = InternalStateModule.get;\n                var enforceInternalState = InternalStateModule.enforce;\n                var TEMPLATE = String(String).split(\"String\");\n                (module1.exports = function(O, key, value, options) {\n                    var unsafe = options ? !!options.unsafe : false;\n                    var simple = options ? !!options.enumerable : false;\n                    var noTargetGet = options ? !!options.noTargetGet : false;\n                    var state;\n                    if (typeof value == \"function\") {\n                        if (typeof key == \"string\" && !has(value, \"name\")) {\n                            createNonEnumerableProperty(value, \"name\", key);\n                        }\n                        state = enforceInternalState(value);\n                        if (!state.source) {\n                            state.source = TEMPLATE.join(typeof key == \"string\" ? key : \"\");\n                        }\n                    }\n                    if (O === global1) {\n                        if (simple) O[key] = value;\n                        else setGlobal(key, value);\n                        return;\n                    } else if (!unsafe) {\n                        delete O[key];\n                    } else if (!noTargetGet && O[key]) {\n                        simple = true;\n                    }\n                    if (simple) O[key] = value;\n                    else createNonEnumerableProperty(O, key, value);\n                // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n                })(Function.prototype, \"toString\", function toString() {\n                    return typeof this == \"function\" && getInternalState(this).source || inspectSource(this);\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/regexp-flags.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/regexp-flags.js ***!\n  \\********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_174083__) {\n                \"use strict\";\n                var anObject = __nested_webpack_require_174083__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                // `RegExp.prototype.flags` getter implementation\n                // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\n                module1.exports = function() {\n                    var that = anObject(this);\n                    var result = \"\";\n                    if (that.global) result += \"g\";\n                    if (that.ignoreCase) result += \"i\";\n                    if (that.multiline) result += \"m\";\n                    if (that.dotAll) result += \"s\";\n                    if (that.unicode) result += \"u\";\n                    if (that.sticky) result += \"y\";\n                    return result;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/require-object-coercible.js\": /*!********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!\n  \\********************************************************************/ /***/ function(module1) {\n                // `RequireObjectCoercible` abstract operation\n                // https://tc39.es/ecma262/#sec-requireobjectcoercible\n                module1.exports = function(it) {\n                    if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n                    return it;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/set-global.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/set-global.js ***!\n  \\******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_175902__) {\n                var global1 = __nested_webpack_require_175902__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                module1.exports = function(key, value) {\n                    try {\n                        // eslint-disable-next-line es/no-object-defineproperty -- safe\n                        Object.defineProperty(global1, key, {\n                            value: value,\n                            configurable: true,\n                            writable: true\n                        });\n                    } catch (error) {\n                        global1[key] = value;\n                    }\n                    return value;\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/set-to-string-tag.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_176948__) {\n                var defineProperty = __nested_webpack_require_176948__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                var has = __nested_webpack_require_176948__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var wellKnownSymbol = __nested_webpack_require_176948__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n                module1.exports = function(it, TAG, STATIC) {\n                    if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n                        defineProperty(it, TO_STRING_TAG, {\n                            configurable: true,\n                            value: TAG\n                        });\n                    }\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/shared-key.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/shared-key.js ***!\n  \\******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_178154__) {\n                var shared = __nested_webpack_require_178154__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\n                var uid = __nested_webpack_require_178154__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\n                var keys = shared(\"keys\");\n                module1.exports = function(key) {\n                    return keys[key] || (keys[key] = uid(key));\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/shared-store.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/shared-store.js ***!\n  \\********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_178916__) {\n                var global1 = __nested_webpack_require_178916__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var setGlobal = __nested_webpack_require_178916__(/*! ../internals/set-global */ \"./node_modules/core-js/internals/set-global.js\");\n                var SHARED = \"__core-js_shared__\";\n                var store = global1[SHARED] || setGlobal(SHARED, {});\n                module1.exports = store;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/shared.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/internals/shared.js ***!\n  \\**************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_179661__) {\n                var IS_PURE = __nested_webpack_require_179661__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n                var store = __nested_webpack_require_179661__(/*! ../internals/shared-store */ \"./node_modules/core-js/internals/shared-store.js\");\n                (module1.exports = function(key, value) {\n                    return store[key] || (store[key] = value !== undefined ? value : {});\n                })(\"versions\", []).push({\n                    version: \"3.16.0\",\n                    mode: IS_PURE ? \"pure\" : \"global\",\n                    copyright: \"\\xa9 2021 Denis Pushkarev (zloirock.ru)\"\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/string-html-forced.js\": /*!**************************************************************!*\\\n  !*** ./node_modules/core-js/internals/string-html-forced.js ***!\n  \\**************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_180671__) {\n                var fails = __nested_webpack_require_180671__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                // check the existence of a method, lowercase\n                // of a tag and escaping quotes in arguments\n                module1.exports = function(METHOD_NAME) {\n                    return fails(function() {\n                        var test = \"\"[METHOD_NAME]('\"');\n                        return test !== test.toLowerCase() || test.split('\"').length > 3;\n                    });\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/string-multibyte.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/internals/string-multibyte.js ***!\n  \\************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_181573__) {\n                var toInteger = __nested_webpack_require_181573__(/*! ../internals/to-integer */ \"./node_modules/core-js/internals/to-integer.js\");\n                var toString = __nested_webpack_require_181573__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var requireObjectCoercible = __nested_webpack_require_181573__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                // `String.prototype.codePointAt` methods implementation\n                var createMethod = function(CONVERT_TO_STRING) {\n                    return function($this, pos) {\n                        var S = toString(requireObjectCoercible($this));\n                        var position = toInteger(pos);\n                        var size = S.length;\n                        var first, second;\n                        if (position < 0 || position >= size) return CONVERT_TO_STRING ? \"\" : undefined;\n                        first = S.charCodeAt(position);\n                        return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n                    };\n                };\n                module1.exports = {\n                    // `String.prototype.codePointAt` method\n                    // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n                    codeAt: createMethod(false),\n                    // `String.prototype.at` method\n                    // https://github.com/mathiasbynens/String.prototype.at\n                    charAt: createMethod(true)\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/string-trim.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/string-trim.js ***!\n  \\*******************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_183703__) {\n                var requireObjectCoercible = __nested_webpack_require_183703__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                var toString = __nested_webpack_require_183703__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var whitespaces = __nested_webpack_require_183703__(/*! ../internals/whitespaces */ \"./node_modules/core-js/internals/whitespaces.js\");\n                var whitespace = \"[\" + whitespaces + \"]\";\n                var ltrim = RegExp(\"^\" + whitespace + whitespace + \"*\");\n                var rtrim = RegExp(whitespace + whitespace + \"*$\");\n                // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\n                var createMethod = function(TYPE) {\n                    return function($this) {\n                        var string = toString(requireObjectCoercible($this));\n                        if (TYPE & 1) string = string.replace(ltrim, \"\");\n                        if (TYPE & 2) string = string.replace(rtrim, \"\");\n                        return string;\n                    };\n                };\n                module1.exports = {\n                    // `String.prototype.{ trimLeft, trimStart }` methods\n                    // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n                    start: createMethod(1),\n                    // `String.prototype.{ trimRight, trimEnd }` methods\n                    // https://tc39.es/ecma262/#sec-string.prototype.trimend\n                    end: createMethod(2),\n                    // `String.prototype.trim` method\n                    // https://tc39.es/ecma262/#sec-string.prototype.trim\n                    trim: createMethod(3)\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-absolute-index.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_185844__) {\n                var toInteger = __nested_webpack_require_185844__(/*! ../internals/to-integer */ \"./node_modules/core-js/internals/to-integer.js\");\n                var max = Math.max;\n                var min = Math.min;\n                // Helper for a popular repeating case of the spec:\n                // Let integer be ? ToInteger(index).\n                // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\n                module1.exports = function(index, length) {\n                    var integer = toInteger(index);\n                    return integer < 0 ? max(integer + length, 0) : min(integer, length);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-indexed-object.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_186880__) {\n                // toObject with fallback for non-array-like ES3 strings\n                var IndexedObject = __nested_webpack_require_186880__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\n                var requireObjectCoercible = __nested_webpack_require_186880__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                module1.exports = function(it) {\n                    return IndexedObject(requireObjectCoercible(it));\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-integer.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-integer.js ***!\n  \\******************************************************/ /***/ function(module1) {\n                var ceil = Math.ceil;\n                var floor = Math.floor;\n                // `ToInteger` abstract operation\n                // https://tc39.es/ecma262/#sec-tointeger\n                module1.exports = function(argument) {\n                    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-length.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-length.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_188405__) {\n                var toInteger = __nested_webpack_require_188405__(/*! ../internals/to-integer */ \"./node_modules/core-js/internals/to-integer.js\");\n                var min = Math.min;\n                // `ToLength` abstract operation\n                // https://tc39.es/ecma262/#sec-tolength\n                module1.exports = function(argument) {\n                    return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-object.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-object.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_189217__) {\n                var requireObjectCoercible = __nested_webpack_require_189217__(/*! ../internals/require-object-coercible */ \"./node_modules/core-js/internals/require-object-coercible.js\");\n                // `ToObject` abstract operation\n                // https://tc39.es/ecma262/#sec-toobject\n                module1.exports = function(argument) {\n                    return Object(requireObjectCoercible(argument));\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-primitive.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-primitive.js ***!\n  \\********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_189990__) {\n                var isObject = __nested_webpack_require_189990__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var isSymbol = __nested_webpack_require_189990__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                var ordinaryToPrimitive = __nested_webpack_require_189990__(/*! ../internals/ordinary-to-primitive */ \"./node_modules/core-js/internals/ordinary-to-primitive.js\");\n                var wellKnownSymbol = __nested_webpack_require_189990__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var TO_PRIMITIVE = wellKnownSymbol(\"toPrimitive\");\n                // `ToPrimitive` abstract operation\n                // https://tc39.es/ecma262/#sec-toprimitive\n                module1.exports = function(input, pref) {\n                    if (!isObject(input) || isSymbol(input)) return input;\n                    var exoticToPrim = input[TO_PRIMITIVE];\n                    var result;\n                    if (exoticToPrim !== undefined) {\n                        if (pref === undefined) pref = \"default\";\n                        result = exoticToPrim.call(input, pref);\n                        if (!isObject(result) || isSymbol(result)) return result;\n                        throw TypeError(\"Can't convert object to primitive value\");\n                    }\n                    if (pref === undefined) pref = \"number\";\n                    return ordinaryToPrimitive(input, pref);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-property-key.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-property-key.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_191851__) {\n                var toPrimitive = __nested_webpack_require_191851__(/*! ../internals/to-primitive */ \"./node_modules/core-js/internals/to-primitive.js\");\n                var isSymbol = __nested_webpack_require_191851__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                // `ToPropertyKey` abstract operation\n                // https://tc39.es/ecma262/#sec-topropertykey\n                module1.exports = function(argument) {\n                    var key = toPrimitive(argument, \"string\");\n                    return isSymbol(key) ? key : String(key);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-string-tag-support.js\": /*!*****************************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!\n  \\*****************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_192822__) {\n                var wellKnownSymbol = __nested_webpack_require_192822__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n                var test = {};\n                test[TO_STRING_TAG] = \"z\";\n                module1.exports = String(test) === \"[object z]\";\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/to-string.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/internals/to-string.js ***!\n  \\*****************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_193520__) {\n                var isSymbol = __nested_webpack_require_193520__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                module1.exports = function(argument) {\n                    if (isSymbol(argument)) throw TypeError(\"Cannot convert a Symbol value to a string\");\n                    return String(argument);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/uid.js\": /*!***********************************************!*\\\n  !*** ./node_modules/core-js/internals/uid.js ***!\n  \\***********************************************/ /***/ function(module1) {\n                var id = 0;\n                var postfix = Math.random();\n                module1.exports = function(key) {\n                    return \"Symbol(\" + String(key === undefined ? \"\" : key) + \")_\" + (++id + postfix).toString(36);\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/use-symbol-as-uid.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_194769__) {\n                /* eslint-disable es/no-symbol -- required for testing */ var NATIVE_SYMBOL = __nested_webpack_require_194769__(/*! ../internals/native-symbol */ \"./node_modules/core-js/internals/native-symbol.js\");\n                module1.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == \"symbol\";\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/well-known-symbol-wrapped.js\": /*!*********************************************************************!*\\\n  !*** ./node_modules/core-js/internals/well-known-symbol-wrapped.js ***!\n  \\*********************************************************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_195475__) {\n                var wellKnownSymbol = __nested_webpack_require_195475__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                exports1.f = wellKnownSymbol;\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/well-known-symbol.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!\n  \\*************************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_196044__) {\n                var global1 = __nested_webpack_require_196044__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var shared = __nested_webpack_require_196044__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\n                var has = __nested_webpack_require_196044__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var uid = __nested_webpack_require_196044__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\n                var NATIVE_SYMBOL = __nested_webpack_require_196044__(/*! ../internals/native-symbol */ \"./node_modules/core-js/internals/native-symbol.js\");\n                var USE_SYMBOL_AS_UID = __nested_webpack_require_196044__(/*! ../internals/use-symbol-as-uid */ \"./node_modules/core-js/internals/use-symbol-as-uid.js\");\n                var WellKnownSymbolsStore = shared(\"wks\");\n                var Symbol1 = global1.Symbol;\n                var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol1 : Symbol1 && Symbol1.withoutSetter || uid;\n                module1.exports = function(name) {\n                    if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == \"string\")) {\n                        if (NATIVE_SYMBOL && has(Symbol1, name)) {\n                            WellKnownSymbolsStore[name] = Symbol1[name];\n                        } else {\n                            WellKnownSymbolsStore[name] = createWellKnownSymbol(\"Symbol.\" + name);\n                        }\n                    }\n                    return WellKnownSymbolsStore[name];\n                };\n            /***/ },\n            /***/ \"./node_modules/core-js/internals/whitespaces.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/internals/whitespaces.js ***!\n  \\*******************************************************/ /***/ function(module1) {\n                // a string of all valid unicode whitespaces\n                module1.exports = \"\t\\n\\v\\f\\r \\xa0\" + \"\\u2028\\u2029\\uFEFF\";\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.concat.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.concat.js ***!\n  \\*********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_198434__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_198434__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var fails = __nested_webpack_require_198434__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var isArray = __nested_webpack_require_198434__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n                var isObject = __nested_webpack_require_198434__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var toObject = __nested_webpack_require_198434__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var toLength = __nested_webpack_require_198434__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\n                var createProperty = __nested_webpack_require_198434__(/*! ../internals/create-property */ \"./node_modules/core-js/internals/create-property.js\");\n                var arraySpeciesCreate = __nested_webpack_require_198434__(/*! ../internals/array-species-create */ \"./node_modules/core-js/internals/array-species-create.js\");\n                var arrayMethodHasSpeciesSupport = __nested_webpack_require_198434__(/*! ../internals/array-method-has-species-support */ \"./node_modules/core-js/internals/array-method-has-species-support.js\");\n                var wellKnownSymbol = __nested_webpack_require_198434__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var V8_VERSION = __nested_webpack_require_198434__(/*! ../internals/engine-v8-version */ \"./node_modules/core-js/internals/engine-v8-version.js\");\n                var IS_CONCAT_SPREADABLE = wellKnownSymbol(\"isConcatSpreadable\");\n                var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\n                var MAXIMUM_ALLOWED_INDEX_EXCEEDED = \"Maximum allowed index exceeded\";\n                // We can't use this feature detection in V8 since it causes\n                // deoptimization and serious performance degradation\n                // https://github.com/zloirock/core-js/issues/679\n                var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {\n                    var array = [];\n                    array[IS_CONCAT_SPREADABLE] = false;\n                    return array.concat()[0] !== array;\n                });\n                var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport(\"concat\");\n                var isConcatSpreadable = function(O) {\n                    if (!isObject(O)) return false;\n                    var spreadable = O[IS_CONCAT_SPREADABLE];\n                    return spreadable !== undefined ? !!spreadable : isArray(O);\n                };\n                var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;\n                // `Array.prototype.concat` method\n                // https://tc39.es/ecma262/#sec-array.prototype.concat\n                // with adding support of @@isConcatSpreadable and @@species\n                $({\n                    target: \"Array\",\n                    proto: true,\n                    forced: FORCED\n                }, {\n                    // eslint-disable-next-line no-unused-vars -- required for `.length`\n                    concat: function concat(arg) {\n                        var O = toObject(this);\n                        var A = arraySpeciesCreate(O, 0);\n                        var n = 0;\n                        var i, k, length, len, E;\n                        for(i = -1, length = arguments.length; i < length; i++){\n                            E = i === -1 ? O : arguments[i];\n                            if (isConcatSpreadable(E)) {\n                                len = toLength(E.length);\n                                if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n                                for(k = 0; k < len; k++, n++)if (k in E) createProperty(A, n, E[k]);\n                            } else {\n                                if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n                                createProperty(A, n++, E);\n                            }\n                        }\n                        A.length = n;\n                        return A;\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.iterator.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!\n  \\***********************************************************/ /***/ function(module1, __unused_webpack_exports, __nested_webpack_require_203043__) {\n                \"use strict\";\n                var toIndexedObject = __nested_webpack_require_203043__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var addToUnscopables = __nested_webpack_require_203043__(/*! ../internals/add-to-unscopables */ \"./node_modules/core-js/internals/add-to-unscopables.js\");\n                var Iterators = __nested_webpack_require_203043__(/*! ../internals/iterators */ \"./node_modules/core-js/internals/iterators.js\");\n                var InternalStateModule = __nested_webpack_require_203043__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n                var defineIterator = __nested_webpack_require_203043__(/*! ../internals/define-iterator */ \"./node_modules/core-js/internals/define-iterator.js\");\n                var ARRAY_ITERATOR = \"Array Iterator\";\n                var setInternalState = InternalStateModule.set;\n                var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\n                // `Array.prototype.entries` method\n                // https://tc39.es/ecma262/#sec-array.prototype.entries\n                // `Array.prototype.keys` method\n                // https://tc39.es/ecma262/#sec-array.prototype.keys\n                // `Array.prototype.values` method\n                // https://tc39.es/ecma262/#sec-array.prototype.values\n                // `Array.prototype[@@iterator]` method\n                // https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n                // `CreateArrayIterator` internal method\n                // https://tc39.es/ecma262/#sec-createarrayiterator\n                module1.exports = defineIterator(Array, \"Array\", function(iterated, kind) {\n                    setInternalState(this, {\n                        type: ARRAY_ITERATOR,\n                        target: toIndexedObject(iterated),\n                        index: 0,\n                        kind: kind // kind\n                    });\n                // `%ArrayIteratorPrototype%.next` method\n                // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n                }, function() {\n                    var state = getInternalState(this);\n                    var target = state.target;\n                    var kind = state.kind;\n                    var index = state.index++;\n                    if (!target || index >= target.length) {\n                        state.target = undefined;\n                        return {\n                            value: undefined,\n                            done: true\n                        };\n                    }\n                    if (kind == \"keys\") return {\n                        value: index,\n                        done: false\n                    };\n                    if (kind == \"values\") return {\n                        value: target[index],\n                        done: false\n                    };\n                    return {\n                        value: [\n                            index,\n                            target[index]\n                        ],\n                        done: false\n                    };\n                }, \"values\");\n                // argumentsList[@@iterator] is %ArrayProto_values%\n                // https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n                // https://tc39.es/ecma262/#sec-createmappedargumentsobject\n                Iterators.Arguments = Iterators.Array;\n                // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\n                addToUnscopables(\"keys\");\n                addToUnscopables(\"values\");\n                addToUnscopables(\"entries\");\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.join.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.join.js ***!\n  \\*******************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_207028__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_207028__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var IndexedObject = __nested_webpack_require_207028__(/*! ../internals/indexed-object */ \"./node_modules/core-js/internals/indexed-object.js\");\n                var toIndexedObject = __nested_webpack_require_207028__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var arrayMethodIsStrict = __nested_webpack_require_207028__(/*! ../internals/array-method-is-strict */ \"./node_modules/core-js/internals/array-method-is-strict.js\");\n                var nativeJoin = [].join;\n                var ES3_STRINGS = IndexedObject != Object;\n                var STRICT_METHOD = arrayMethodIsStrict(\"join\", \",\");\n                // `Array.prototype.join` method\n                // https://tc39.es/ecma262/#sec-array.prototype.join\n                $({\n                    target: \"Array\",\n                    proto: true,\n                    forced: ES3_STRINGS || !STRICT_METHOD\n                }, {\n                    join: function join(separator) {\n                        return nativeJoin.call(toIndexedObject(this), separator === undefined ? \",\" : separator);\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.map.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.map.js ***!\n  \\******************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_208668__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_208668__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var $map = __nested_webpack_require_208668__(/*! ../internals/array-iteration */ \"./node_modules/core-js/internals/array-iteration.js\").map;\n                var arrayMethodHasSpeciesSupport = __nested_webpack_require_208668__(/*! ../internals/array-method-has-species-support */ \"./node_modules/core-js/internals/array-method-has-species-support.js\");\n                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport(\"map\");\n                // `Array.prototype.map` method\n                // https://tc39.es/ecma262/#sec-array.prototype.map\n                // with adding support of @@species\n                $({\n                    target: \"Array\",\n                    proto: true,\n                    forced: !HAS_SPECIES_SUPPORT\n                }, {\n                    map: function map(callbackfn /* , thisArg */ ) {\n                        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.array.slice.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.array.slice.js ***!\n  \\********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_210143__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_210143__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var isObject = __nested_webpack_require_210143__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var isArray = __nested_webpack_require_210143__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n                var toAbsoluteIndex = __nested_webpack_require_210143__(/*! ../internals/to-absolute-index */ \"./node_modules/core-js/internals/to-absolute-index.js\");\n                var toLength = __nested_webpack_require_210143__(/*! ../internals/to-length */ \"./node_modules/core-js/internals/to-length.js\");\n                var toIndexedObject = __nested_webpack_require_210143__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var createProperty = __nested_webpack_require_210143__(/*! ../internals/create-property */ \"./node_modules/core-js/internals/create-property.js\");\n                var wellKnownSymbol = __nested_webpack_require_210143__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var arrayMethodHasSpeciesSupport = __nested_webpack_require_210143__(/*! ../internals/array-method-has-species-support */ \"./node_modules/core-js/internals/array-method-has-species-support.js\");\n                var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport(\"slice\");\n                var SPECIES = wellKnownSymbol(\"species\");\n                var nativeSlice = [].slice;\n                var max = Math.max;\n                // `Array.prototype.slice` method\n                // https://tc39.es/ecma262/#sec-array.prototype.slice\n                // fallback for not array-like ES3 strings and DOM objects\n                $({\n                    target: \"Array\",\n                    proto: true,\n                    forced: !HAS_SPECIES_SUPPORT\n                }, {\n                    slice: function slice(start, end) {\n                        var O = toIndexedObject(this);\n                        var length = toLength(O.length);\n                        var k = toAbsoluteIndex(start, length);\n                        var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n                        // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible\n                        var Constructor, result, n;\n                        if (isArray(O)) {\n                            Constructor = O.constructor;\n                            // cross-realm fallback\n                            if (typeof Constructor == \"function\" && (Constructor === Array || isArray(Constructor.prototype))) {\n                                Constructor = undefined;\n                            } else if (isObject(Constructor)) {\n                                Constructor = Constructor[SPECIES];\n                                if (Constructor === null) Constructor = undefined;\n                            }\n                            if (Constructor === Array || Constructor === undefined) {\n                                return nativeSlice.call(O, k, fin);\n                            }\n                        }\n                        result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));\n                        for(n = 0; k < fin; k++, n++)if (k in O) createProperty(result, n, O[k]);\n                        result.length = n;\n                        return result;\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.function.name.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.function.name.js ***!\n  \\**********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_214038__) {\n                var DESCRIPTORS = __nested_webpack_require_214038__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var defineProperty = __nested_webpack_require_214038__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                var FunctionPrototype = Function.prototype;\n                var FunctionPrototypeToString = FunctionPrototype.toString;\n                var nameRE = /^\\s*function ([^ (]*)/;\n                var NAME = \"name\";\n                // Function instances `.name` property\n                // https://tc39.es/ecma262/#sec-function-instances-name\n                if (DESCRIPTORS && !(NAME in FunctionPrototype)) {\n                    defineProperty(FunctionPrototype, NAME, {\n                        configurable: true,\n                        get: function() {\n                            try {\n                                return FunctionPrototypeToString.call(this).match(nameRE)[1];\n                            } catch (error) {\n                                return \"\";\n                            }\n                        }\n                    });\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.number.constructor.js\": /*!***************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.number.constructor.js ***!\n  \\***************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_215616__) {\n                \"use strict\";\n                var DESCRIPTORS = __nested_webpack_require_215616__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var global1 = __nested_webpack_require_215616__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var isForced = __nested_webpack_require_215616__(/*! ../internals/is-forced */ \"./node_modules/core-js/internals/is-forced.js\");\n                var redefine = __nested_webpack_require_215616__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var has = __nested_webpack_require_215616__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var classof = __nested_webpack_require_215616__(/*! ../internals/classof-raw */ \"./node_modules/core-js/internals/classof-raw.js\");\n                var inheritIfRequired = __nested_webpack_require_215616__(/*! ../internals/inherit-if-required */ \"./node_modules/core-js/internals/inherit-if-required.js\");\n                var isSymbol = __nested_webpack_require_215616__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                var toPrimitive = __nested_webpack_require_215616__(/*! ../internals/to-primitive */ \"./node_modules/core-js/internals/to-primitive.js\");\n                var fails = __nested_webpack_require_215616__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var create = __nested_webpack_require_215616__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\n                var getOwnPropertyNames = __nested_webpack_require_215616__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\").f;\n                var getOwnPropertyDescriptor = __nested_webpack_require_215616__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\").f;\n                var defineProperty = __nested_webpack_require_215616__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                var trim = __nested_webpack_require_215616__(/*! ../internals/string-trim */ \"./node_modules/core-js/internals/string-trim.js\").trim;\n                var NUMBER = \"Number\";\n                var NativeNumber = global1[NUMBER];\n                var NumberPrototype = NativeNumber.prototype;\n                // Opera ~12 has broken Object#toString\n                var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;\n                // `ToNumber` abstract operation\n                // https://tc39.es/ecma262/#sec-tonumber\n                var toNumber = function(argument) {\n                    if (isSymbol(argument)) throw TypeError(\"Cannot convert a Symbol value to a number\");\n                    var it = toPrimitive(argument, \"number\");\n                    var first, third, radix, maxCode, digits, length, index, code;\n                    if (typeof it == \"string\" && it.length > 2) {\n                        it = trim(it);\n                        first = it.charCodeAt(0);\n                        if (first === 43 || first === 45) {\n                            third = it.charCodeAt(2);\n                            if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n                        } else if (first === 48) {\n                            switch(it.charCodeAt(1)){\n                                case 66:\n                                case 98:\n                                    radix = 2;\n                                    maxCode = 49;\n                                    break; // fast equal of /^0b[01]+$/i\n                                case 79:\n                                case 111:\n                                    radix = 8;\n                                    maxCode = 55;\n                                    break; // fast equal of /^0o[0-7]+$/i\n                                default:\n                                    return +it;\n                            }\n                            digits = it.slice(2);\n                            length = digits.length;\n                            for(index = 0; index < length; index++){\n                                code = digits.charCodeAt(index);\n                                // parseInt parses a string to a first unavailable symbol\n                                // but ToNumber should return NaN if a string contains unavailable symbols\n                                if (code < 48 || code > maxCode) return NaN;\n                            }\n                            return parseInt(digits, radix);\n                        }\n                    }\n                    return +it;\n                };\n                // `Number` constructor\n                // https://tc39.es/ecma262/#sec-number-constructor\n                if (isForced(NUMBER, !NativeNumber(\" 0o1\") || !NativeNumber(\"0b1\") || NativeNumber(\"+0x1\"))) {\n                    var NumberWrapper = function Number1(value) {\n                        var it = arguments.length < 1 ? 0 : value;\n                        var dummy = this;\n                        return dummy instanceof NumberWrapper && (BROKEN_CLASSOF ? fails(function() {\n                            NumberPrototype.valueOf.call(dummy);\n                        }) : classof(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);\n                    };\n                    for(var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : // ES3:\n                    (\"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,\" + // ES2015 (in case, if modules with ES2015 Number statics required before):\n                    \"EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,\" + \"MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,\" + // ESNext\n                    \"fromString,range\").split(\",\"), j = 0, key; keys.length > j; j++){\n                        if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {\n                            defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));\n                        }\n                    }\n                    NumberWrapper.prototype = NumberPrototype;\n                    NumberPrototype.constructor = NumberWrapper;\n                    redefine(global1, NUMBER, NumberWrapper);\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.object.assign.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.object.assign.js ***!\n  \\**********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_222355__) {\n                var $ = __nested_webpack_require_222355__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var assign = __nested_webpack_require_222355__(/*! ../internals/object-assign */ \"./node_modules/core-js/internals/object-assign.js\");\n                // `Object.assign` method\n                // https://tc39.es/ecma262/#sec-object.assign\n                // eslint-disable-next-line es/no-object-assign -- required for testing\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: Object.assign !== assign\n                }, {\n                    assign: assign\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.object.keys.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.object.keys.js ***!\n  \\********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_223386__) {\n                var $ = __nested_webpack_require_223386__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var toObject = __nested_webpack_require_223386__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var nativeKeys = __nested_webpack_require_223386__(/*! ../internals/object-keys */ \"./node_modules/core-js/internals/object-keys.js\");\n                var fails = __nested_webpack_require_223386__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var FAILS_ON_PRIMITIVES = fails(function() {\n                    nativeKeys(1);\n                });\n                // `Object.keys` method\n                // https://tc39.es/ecma262/#sec-object.keys\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: FAILS_ON_PRIMITIVES\n                }, {\n                    keys: function keys(it) {\n                        return nativeKeys(toObject(it));\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.object.to-string.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!\n  \\*************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_224797__) {\n                var TO_STRING_TAG_SUPPORT = __nested_webpack_require_224797__(/*! ../internals/to-string-tag-support */ \"./node_modules/core-js/internals/to-string-tag-support.js\");\n                var redefine = __nested_webpack_require_224797__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var toString = __nested_webpack_require_224797__(/*! ../internals/object-to-string */ \"./node_modules/core-js/internals/object-to-string.js\");\n                // `Object.prototype.toString` method\n                // https://tc39.es/ecma262/#sec-object.prototype.tostring\n                if (!TO_STRING_TAG_SUPPORT) {\n                    redefine(Object.prototype, \"toString\", toString, {\n                        unsafe: true\n                    });\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.regexp.to-string.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.regexp.to-string.js ***!\n  \\*************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_225948__) {\n                \"use strict\";\n                var redefine = __nested_webpack_require_225948__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var anObject = __nested_webpack_require_225948__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var $toString = __nested_webpack_require_225948__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var fails = __nested_webpack_require_225948__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var flags = __nested_webpack_require_225948__(/*! ../internals/regexp-flags */ \"./node_modules/core-js/internals/regexp-flags.js\");\n                var TO_STRING = \"toString\";\n                var RegExpPrototype = RegExp.prototype;\n                var nativeToString = RegExpPrototype[TO_STRING];\n                var NOT_GENERIC = fails(function() {\n                    return nativeToString.call({\n                        source: \"a\",\n                        flags: \"b\"\n                    }) != \"/a/b\";\n                });\n                // FF44- RegExp#toString has a wrong name\n                var INCORRECT_NAME = nativeToString.name != TO_STRING;\n                // `RegExp.prototype.toString` method\n                // https://tc39.es/ecma262/#sec-regexp.prototype.tostring\n                if (NOT_GENERIC || INCORRECT_NAME) {\n                    redefine(RegExp.prototype, TO_STRING, function toString() {\n                        var R = anObject(this);\n                        var p = $toString(R.source);\n                        var rf = R.flags;\n                        var f = $toString(rf === undefined && R instanceof RegExp && !(\"flags\" in RegExpPrototype) ? flags.call(R) : rf);\n                        return \"/\" + p + \"/\" + f;\n                    }, {\n                        unsafe: true\n                    });\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.string.iterator.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!\n  \\************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_228223__) {\n                \"use strict\";\n                var charAt = __nested_webpack_require_228223__(/*! ../internals/string-multibyte */ \"./node_modules/core-js/internals/string-multibyte.js\").charAt;\n                var toString = __nested_webpack_require_228223__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var InternalStateModule = __nested_webpack_require_228223__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n                var defineIterator = __nested_webpack_require_228223__(/*! ../internals/define-iterator */ \"./node_modules/core-js/internals/define-iterator.js\");\n                var STRING_ITERATOR = \"String Iterator\";\n                var setInternalState = InternalStateModule.set;\n                var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\n                // `String.prototype[@@iterator]` method\n                // https://tc39.es/ecma262/#sec-string.prototype-@@iterator\n                defineIterator(String, \"String\", function(iterated) {\n                    setInternalState(this, {\n                        type: STRING_ITERATOR,\n                        string: toString(iterated),\n                        index: 0\n                    });\n                // `%StringIteratorPrototype%.next` method\n                // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n                }, function next() {\n                    var state = getInternalState(this);\n                    var string = state.string;\n                    var index = state.index;\n                    var point;\n                    if (index >= string.length) return {\n                        value: undefined,\n                        done: true\n                    };\n                    point = charAt(string, index);\n                    state.index += point.length;\n                    return {\n                        value: point,\n                        done: false\n                    };\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.string.link.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.string.link.js ***!\n  \\********************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_230569__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_230569__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var createHTML = __nested_webpack_require_230569__(/*! ../internals/create-html */ \"./node_modules/core-js/internals/create-html.js\");\n                var forcedStringHTMLMethod = __nested_webpack_require_230569__(/*! ../internals/string-html-forced */ \"./node_modules/core-js/internals/string-html-forced.js\");\n                // `String.prototype.link` method\n                // https://tc39.es/ecma262/#sec-string.prototype.link\n                $({\n                    target: \"String\",\n                    proto: true,\n                    forced: forcedStringHTMLMethod(\"link\")\n                }, {\n                    link: function link(url) {\n                        return createHTML(this, \"a\", \"href\", url);\n                    }\n                });\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.symbol.description.js\": /*!***************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.symbol.description.js ***!\n  \\***************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_231857__) {\n                \"use strict\";\n                // `Symbol.prototype.description` getter\n                // https://tc39.es/ecma262/#sec-symbol.prototype.description\n                var $ = __nested_webpack_require_231857__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var DESCRIPTORS = __nested_webpack_require_231857__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var global1 = __nested_webpack_require_231857__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var has = __nested_webpack_require_231857__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var isObject = __nested_webpack_require_231857__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var defineProperty = __nested_webpack_require_231857__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\").f;\n                var copyConstructorProperties = __nested_webpack_require_231857__(/*! ../internals/copy-constructor-properties */ \"./node_modules/core-js/internals/copy-constructor-properties.js\");\n                var NativeSymbol = global1.Symbol;\n                if (DESCRIPTORS && typeof NativeSymbol == \"function\" && (!(\"description\" in NativeSymbol.prototype) || // Safari 12 bug\n                NativeSymbol().description !== undefined)) {\n                    var EmptyStringDescriptionStore = {};\n                    // wrap Symbol constructor for correct work with undefined description\n                    var SymbolWrapper = function Symbol1() {\n                        var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);\n                        var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === undefined ? NativeSymbol() : NativeSymbol(description);\n                        if (description === \"\") EmptyStringDescriptionStore[result] = true;\n                        return result;\n                    };\n                    copyConstructorProperties(SymbolWrapper, NativeSymbol);\n                    var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;\n                    symbolPrototype.constructor = SymbolWrapper;\n                    var symbolToString = symbolPrototype.toString;\n                    var native = String(NativeSymbol(\"test\")) == \"Symbol(test)\";\n                    var regexp = /^Symbol\\((.*)\\)[^)]+$/;\n                    defineProperty(symbolPrototype, \"description\", {\n                        configurable: true,\n                        get: function description() {\n                            var symbol = isObject(this) ? this.valueOf() : this;\n                            var string = symbolToString.call(symbol);\n                            if (has(EmptyStringDescriptionStore, symbol)) return \"\";\n                            var desc = native ? string.slice(7, -1) : string.replace(regexp, \"$1\");\n                            return desc === \"\" ? undefined : desc;\n                        }\n                    });\n                    $({\n                        global: true,\n                        forced: true\n                    }, {\n                        Symbol: SymbolWrapper\n                    });\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.symbol.iterator.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.symbol.iterator.js ***!\n  \\************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_235561__) {\n                var defineWellKnownSymbol = __nested_webpack_require_235561__(/*! ../internals/define-well-known-symbol */ \"./node_modules/core-js/internals/define-well-known-symbol.js\");\n                // `Symbol.iterator` well-known symbol\n                // https://tc39.es/ecma262/#sec-symbol.iterator\n                defineWellKnownSymbol(\"iterator\");\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/es.symbol.js\": /*!***************************************************!*\\\n  !*** ./node_modules/core-js/modules/es.symbol.js ***!\n  \\***************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_236250__) {\n                \"use strict\";\n                var $ = __nested_webpack_require_236250__(/*! ../internals/export */ \"./node_modules/core-js/internals/export.js\");\n                var global1 = __nested_webpack_require_236250__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var getBuiltIn = __nested_webpack_require_236250__(/*! ../internals/get-built-in */ \"./node_modules/core-js/internals/get-built-in.js\");\n                var IS_PURE = __nested_webpack_require_236250__(/*! ../internals/is-pure */ \"./node_modules/core-js/internals/is-pure.js\");\n                var DESCRIPTORS = __nested_webpack_require_236250__(/*! ../internals/descriptors */ \"./node_modules/core-js/internals/descriptors.js\");\n                var NATIVE_SYMBOL = __nested_webpack_require_236250__(/*! ../internals/native-symbol */ \"./node_modules/core-js/internals/native-symbol.js\");\n                var fails = __nested_webpack_require_236250__(/*! ../internals/fails */ \"./node_modules/core-js/internals/fails.js\");\n                var has = __nested_webpack_require_236250__(/*! ../internals/has */ \"./node_modules/core-js/internals/has.js\");\n                var isArray = __nested_webpack_require_236250__(/*! ../internals/is-array */ \"./node_modules/core-js/internals/is-array.js\");\n                var isObject = __nested_webpack_require_236250__(/*! ../internals/is-object */ \"./node_modules/core-js/internals/is-object.js\");\n                var isSymbol = __nested_webpack_require_236250__(/*! ../internals/is-symbol */ \"./node_modules/core-js/internals/is-symbol.js\");\n                var anObject = __nested_webpack_require_236250__(/*! ../internals/an-object */ \"./node_modules/core-js/internals/an-object.js\");\n                var toObject = __nested_webpack_require_236250__(/*! ../internals/to-object */ \"./node_modules/core-js/internals/to-object.js\");\n                var toIndexedObject = __nested_webpack_require_236250__(/*! ../internals/to-indexed-object */ \"./node_modules/core-js/internals/to-indexed-object.js\");\n                var toPropertyKey = __nested_webpack_require_236250__(/*! ../internals/to-property-key */ \"./node_modules/core-js/internals/to-property-key.js\");\n                var $toString = __nested_webpack_require_236250__(/*! ../internals/to-string */ \"./node_modules/core-js/internals/to-string.js\");\n                var createPropertyDescriptor = __nested_webpack_require_236250__(/*! ../internals/create-property-descriptor */ \"./node_modules/core-js/internals/create-property-descriptor.js\");\n                var nativeObjectCreate = __nested_webpack_require_236250__(/*! ../internals/object-create */ \"./node_modules/core-js/internals/object-create.js\");\n                var objectKeys = __nested_webpack_require_236250__(/*! ../internals/object-keys */ \"./node_modules/core-js/internals/object-keys.js\");\n                var getOwnPropertyNamesModule = __nested_webpack_require_236250__(/*! ../internals/object-get-own-property-names */ \"./node_modules/core-js/internals/object-get-own-property-names.js\");\n                var getOwnPropertyNamesExternal = __nested_webpack_require_236250__(/*! ../internals/object-get-own-property-names-external */ \"./node_modules/core-js/internals/object-get-own-property-names-external.js\");\n                var getOwnPropertySymbolsModule = __nested_webpack_require_236250__(/*! ../internals/object-get-own-property-symbols */ \"./node_modules/core-js/internals/object-get-own-property-symbols.js\");\n                var getOwnPropertyDescriptorModule = __nested_webpack_require_236250__(/*! ../internals/object-get-own-property-descriptor */ \"./node_modules/core-js/internals/object-get-own-property-descriptor.js\");\n                var definePropertyModule = __nested_webpack_require_236250__(/*! ../internals/object-define-property */ \"./node_modules/core-js/internals/object-define-property.js\");\n                var propertyIsEnumerableModule = __nested_webpack_require_236250__(/*! ../internals/object-property-is-enumerable */ \"./node_modules/core-js/internals/object-property-is-enumerable.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_236250__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var redefine = __nested_webpack_require_236250__(/*! ../internals/redefine */ \"./node_modules/core-js/internals/redefine.js\");\n                var shared = __nested_webpack_require_236250__(/*! ../internals/shared */ \"./node_modules/core-js/internals/shared.js\");\n                var sharedKey = __nested_webpack_require_236250__(/*! ../internals/shared-key */ \"./node_modules/core-js/internals/shared-key.js\");\n                var hiddenKeys = __nested_webpack_require_236250__(/*! ../internals/hidden-keys */ \"./node_modules/core-js/internals/hidden-keys.js\");\n                var uid = __nested_webpack_require_236250__(/*! ../internals/uid */ \"./node_modules/core-js/internals/uid.js\");\n                var wellKnownSymbol = __nested_webpack_require_236250__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var wrappedWellKnownSymbolModule = __nested_webpack_require_236250__(/*! ../internals/well-known-symbol-wrapped */ \"./node_modules/core-js/internals/well-known-symbol-wrapped.js\");\n                var defineWellKnownSymbol = __nested_webpack_require_236250__(/*! ../internals/define-well-known-symbol */ \"./node_modules/core-js/internals/define-well-known-symbol.js\");\n                var setToStringTag = __nested_webpack_require_236250__(/*! ../internals/set-to-string-tag */ \"./node_modules/core-js/internals/set-to-string-tag.js\");\n                var InternalStateModule = __nested_webpack_require_236250__(/*! ../internals/internal-state */ \"./node_modules/core-js/internals/internal-state.js\");\n                var $forEach = __nested_webpack_require_236250__(/*! ../internals/array-iteration */ \"./node_modules/core-js/internals/array-iteration.js\").forEach;\n                var HIDDEN = sharedKey(\"hidden\");\n                var SYMBOL = \"Symbol\";\n                var PROTOTYPE = \"prototype\";\n                var TO_PRIMITIVE = wellKnownSymbol(\"toPrimitive\");\n                var setInternalState = InternalStateModule.set;\n                var getInternalState = InternalStateModule.getterFor(SYMBOL);\n                var ObjectPrototype = Object[PROTOTYPE];\n                var $Symbol = global1.Symbol;\n                var $stringify = getBuiltIn(\"JSON\", \"stringify\");\n                var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n                var nativeDefineProperty = definePropertyModule.f;\n                var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;\n                var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;\n                var AllSymbols = shared(\"symbols\");\n                var ObjectPrototypeSymbols = shared(\"op-symbols\");\n                var StringToSymbolRegistry = shared(\"string-to-symbol-registry\");\n                var SymbolToStringRegistry = shared(\"symbol-to-string-registry\");\n                var WellKnownSymbolsStore = shared(\"wks\");\n                var QObject = global1.QObject;\n                // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n                var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n                // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n                var setSymbolDescriptor = DESCRIPTORS && fails(function() {\n                    return nativeObjectCreate(nativeDefineProperty({}, \"a\", {\n                        get: function() {\n                            return nativeDefineProperty(this, \"a\", {\n                                value: 7\n                            }).a;\n                        }\n                    })).a != 7;\n                }) ? function(O, P, Attributes) {\n                    var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);\n                    if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];\n                    nativeDefineProperty(O, P, Attributes);\n                    if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {\n                        nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);\n                    }\n                } : nativeDefineProperty;\n                var wrap = function(tag, description) {\n                    var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);\n                    setInternalState(symbol, {\n                        type: SYMBOL,\n                        tag: tag,\n                        description: description\n                    });\n                    if (!DESCRIPTORS) symbol.description = description;\n                    return symbol;\n                };\n                var $defineProperty = function defineProperty(O, P, Attributes) {\n                    if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);\n                    anObject(O);\n                    var key = toPropertyKey(P);\n                    anObject(Attributes);\n                    if (has(AllSymbols, key)) {\n                        if (!Attributes.enumerable) {\n                            if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));\n                            O[HIDDEN][key] = true;\n                        } else {\n                            if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;\n                            Attributes = nativeObjectCreate(Attributes, {\n                                enumerable: createPropertyDescriptor(0, false)\n                            });\n                        }\n                        return setSymbolDescriptor(O, key, Attributes);\n                    }\n                    return nativeDefineProperty(O, key, Attributes);\n                };\n                var $defineProperties = function defineProperties(O, Properties) {\n                    anObject(O);\n                    var properties = toIndexedObject(Properties);\n                    var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));\n                    $forEach(keys, function(key) {\n                        if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);\n                    });\n                    return O;\n                };\n                var $create = function create(O, Properties) {\n                    return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);\n                };\n                var $propertyIsEnumerable = function propertyIsEnumerable(V) {\n                    var P = toPropertyKey(V);\n                    var enumerable = nativePropertyIsEnumerable.call(this, P);\n                    if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;\n                    return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;\n                };\n                var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {\n                    var it = toIndexedObject(O);\n                    var key = toPropertyKey(P);\n                    if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;\n                    var descriptor = nativeGetOwnPropertyDescriptor(it, key);\n                    if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {\n                        descriptor.enumerable = true;\n                    }\n                    return descriptor;\n                };\n                var $getOwnPropertyNames = function getOwnPropertyNames(O) {\n                    var names = nativeGetOwnPropertyNames(toIndexedObject(O));\n                    var result = [];\n                    $forEach(names, function(key) {\n                        if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);\n                    });\n                    return result;\n                };\n                var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {\n                    var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;\n                    var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));\n                    var result = [];\n                    $forEach(names, function(key) {\n                        if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {\n                            result.push(AllSymbols[key]);\n                        }\n                    });\n                    return result;\n                };\n                // `Symbol` constructor\n                // https://tc39.es/ecma262/#sec-symbol-constructor\n                if (!NATIVE_SYMBOL) {\n                    $Symbol = function Symbol1() {\n                        if (this instanceof $Symbol) throw TypeError(\"Symbol is not a constructor\");\n                        var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);\n                        var tag = uid(description);\n                        var setter = function(value) {\n                            if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);\n                            if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n                            setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));\n                        };\n                        if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {\n                            configurable: true,\n                            set: setter\n                        });\n                        return wrap(tag, description);\n                    };\n                    redefine($Symbol[PROTOTYPE], \"toString\", function toString() {\n                        return getInternalState(this).tag;\n                    });\n                    redefine($Symbol, \"withoutSetter\", function(description) {\n                        return wrap(uid(description), description);\n                    });\n                    propertyIsEnumerableModule.f = $propertyIsEnumerable;\n                    definePropertyModule.f = $defineProperty;\n                    getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;\n                    getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;\n                    getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;\n                    wrappedWellKnownSymbolModule.f = function(name) {\n                        return wrap(wellKnownSymbol(name), name);\n                    };\n                    if (DESCRIPTORS) {\n                        // https://github.com/tc39/proposal-Symbol-description\n                        nativeDefineProperty($Symbol[PROTOTYPE], \"description\", {\n                            configurable: true,\n                            get: function description() {\n                                return getInternalState(this).description;\n                            }\n                        });\n                        if (!IS_PURE) {\n                            redefine(ObjectPrototype, \"propertyIsEnumerable\", $propertyIsEnumerable, {\n                                unsafe: true\n                            });\n                        }\n                    }\n                }\n                $({\n                    global: true,\n                    wrap: true,\n                    forced: !NATIVE_SYMBOL,\n                    sham: !NATIVE_SYMBOL\n                }, {\n                    Symbol: $Symbol\n                });\n                $forEach(objectKeys(WellKnownSymbolsStore), function(name) {\n                    defineWellKnownSymbol(name);\n                });\n                $({\n                    target: SYMBOL,\n                    stat: true,\n                    forced: !NATIVE_SYMBOL\n                }, {\n                    // `Symbol.for` method\n                    // https://tc39.es/ecma262/#sec-symbol.for\n                    \"for\": function(key) {\n                        var string = $toString(key);\n                        if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];\n                        var symbol = $Symbol(string);\n                        StringToSymbolRegistry[string] = symbol;\n                        SymbolToStringRegistry[symbol] = string;\n                        return symbol;\n                    },\n                    // `Symbol.keyFor` method\n                    // https://tc39.es/ecma262/#sec-symbol.keyfor\n                    keyFor: function keyFor(sym) {\n                        if (!isSymbol(sym)) throw TypeError(sym + \" is not a symbol\");\n                        if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];\n                    },\n                    useSetter: function() {\n                        USE_SETTER = true;\n                    },\n                    useSimple: function() {\n                        USE_SETTER = false;\n                    }\n                });\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: !NATIVE_SYMBOL,\n                    sham: !DESCRIPTORS\n                }, {\n                    // `Object.create` method\n                    // https://tc39.es/ecma262/#sec-object.create\n                    create: $create,\n                    // `Object.defineProperty` method\n                    // https://tc39.es/ecma262/#sec-object.defineproperty\n                    defineProperty: $defineProperty,\n                    // `Object.defineProperties` method\n                    // https://tc39.es/ecma262/#sec-object.defineproperties\n                    defineProperties: $defineProperties,\n                    // `Object.getOwnPropertyDescriptor` method\n                    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors\n                    getOwnPropertyDescriptor: $getOwnPropertyDescriptor\n                });\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: !NATIVE_SYMBOL\n                }, {\n                    // `Object.getOwnPropertyNames` method\n                    // https://tc39.es/ecma262/#sec-object.getownpropertynames\n                    getOwnPropertyNames: $getOwnPropertyNames,\n                    // `Object.getOwnPropertySymbols` method\n                    // https://tc39.es/ecma262/#sec-object.getownpropertysymbols\n                    getOwnPropertySymbols: $getOwnPropertySymbols\n                });\n                // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n                // https://bugs.chromium.org/p/v8/issues/detail?id=3443\n                $({\n                    target: \"Object\",\n                    stat: true,\n                    forced: fails(function() {\n                        getOwnPropertySymbolsModule.f(1);\n                    })\n                }, {\n                    getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n                        return getOwnPropertySymbolsModule.f(toObject(it));\n                    }\n                });\n                // `JSON.stringify` method behavior with symbols\n                // https://tc39.es/ecma262/#sec-json.stringify\n                if ($stringify) {\n                    var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {\n                        var symbol = $Symbol();\n                        // MS Edge converts symbol values to JSON as {}\n                        return $stringify([\n                            symbol\n                        ]) != \"[null]\" || $stringify({\n                            a: symbol\n                        }) != \"{}\" || $stringify(Object(symbol)) != \"{}\";\n                    });\n                    $({\n                        target: \"JSON\",\n                        stat: true,\n                        forced: FORCED_JSON_STRINGIFY\n                    }, {\n                        // eslint-disable-next-line no-unused-vars -- required for `.length`\n                        stringify: function stringify(it, replacer, space) {\n                            var args = [\n                                it\n                            ];\n                            var index = 1;\n                            var $replacer;\n                            while(arguments.length > index)args.push(arguments[index++]);\n                            $replacer = replacer;\n                            if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n                            if (!isArray(replacer)) replacer = function(key, value) {\n                                if (typeof $replacer == \"function\") value = $replacer.call(this, key, value);\n                                if (!isSymbol(value)) return value;\n                            };\n                            args[1] = replacer;\n                            return $stringify.apply(null, args);\n                        }\n                    });\n                }\n                // `Symbol.prototype[@@toPrimitive]` method\n                // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive\n                if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {\n                    createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n                }\n                // `Symbol.prototype[@@toStringTag]` property\n                // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag\n                setToStringTag($Symbol, SYMBOL);\n                hiddenKeys[HIDDEN] = true;\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/web.dom-collections.for-each.js\": /*!**********************************************************************!*\\\n  !*** ./node_modules/core-js/modules/web.dom-collections.for-each.js ***!\n  \\**********************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_258214__) {\n                var global1 = __nested_webpack_require_258214__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var DOMIterables = __nested_webpack_require_258214__(/*! ../internals/dom-iterables */ \"./node_modules/core-js/internals/dom-iterables.js\");\n                var forEach = __nested_webpack_require_258214__(/*! ../internals/array-for-each */ \"./node_modules/core-js/internals/array-for-each.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_258214__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                for(var COLLECTION_NAME in DOMIterables){\n                    var Collection = global1[COLLECTION_NAME];\n                    var CollectionPrototype = Collection && Collection.prototype;\n                    // some Chrome versions have non-configurable methods on DOMTokenList\n                    if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {\n                        createNonEnumerableProperty(CollectionPrototype, \"forEach\", forEach);\n                    } catch (error) {\n                        CollectionPrototype.forEach = forEach;\n                    }\n                }\n            /***/ },\n            /***/ \"./node_modules/core-js/modules/web.dom-collections.iterator.js\": /*!**********************************************************************!*\\\n  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!\n  \\**********************************************************************/ /***/ function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_259856__) {\n                var global1 = __nested_webpack_require_259856__(/*! ../internals/global */ \"./node_modules/core-js/internals/global.js\");\n                var DOMIterables = __nested_webpack_require_259856__(/*! ../internals/dom-iterables */ \"./node_modules/core-js/internals/dom-iterables.js\");\n                var ArrayIteratorMethods = __nested_webpack_require_259856__(/*! ../modules/es.array.iterator */ \"./node_modules/core-js/modules/es.array.iterator.js\");\n                var createNonEnumerableProperty = __nested_webpack_require_259856__(/*! ../internals/create-non-enumerable-property */ \"./node_modules/core-js/internals/create-non-enumerable-property.js\");\n                var wellKnownSymbol = __nested_webpack_require_259856__(/*! ../internals/well-known-symbol */ \"./node_modules/core-js/internals/well-known-symbol.js\");\n                var ITERATOR = wellKnownSymbol(\"iterator\");\n                var TO_STRING_TAG = wellKnownSymbol(\"toStringTag\");\n                var ArrayValues = ArrayIteratorMethods.values;\n                for(var COLLECTION_NAME in DOMIterables){\n                    var Collection = global1[COLLECTION_NAME];\n                    var CollectionPrototype = Collection && Collection.prototype;\n                    if (CollectionPrototype) {\n                        // some Chrome versions have non-configurable methods on DOMTokenList\n                        if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\n                            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);\n                        } catch (error) {\n                            CollectionPrototype[ITERATOR] = ArrayValues;\n                        }\n                        if (!CollectionPrototype[TO_STRING_TAG]) {\n                            createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n                        }\n                        if (DOMIterables[COLLECTION_NAME]) for(var METHOD_NAME in ArrayIteratorMethods){\n                            // some Chrome versions have non-configurable methods on DOMTokenList\n                            if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n                                createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n                            } catch (error) {\n                                CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n                            }\n                        }\n                    }\n                }\n            /***/ },\n            /***/ \"./node_modules/es6-promise/dist/es6-promise.js\": /*!******************************************************!*\\\n  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!\n  \\******************************************************/ /***/ function(module1) {\n                /*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   v4.2.8+1e68dce6\n */ (function(global1, factory) {\n                     true ? module1.exports = factory() : 0;\n                })(this, function() {\n                    \"use strict\";\n                    function objectOrFunction(x) {\n                        var type = typeof x;\n                        return x !== null && (type === \"object\" || type === \"function\");\n                    }\n                    function isFunction(x) {\n                        return typeof x === \"function\";\n                    }\n                    var _isArray = void 0;\n                    if (Array.isArray) {\n                        _isArray = Array.isArray;\n                    } else {\n                        _isArray = function(x) {\n                            return Object.prototype.toString.call(x) === \"[object Array]\";\n                        };\n                    }\n                    var isArray = _isArray;\n                    var len = 0;\n                    var vertxNext = void 0;\n                    var customSchedulerFn = void 0;\n                    var asap = function asap(callback, arg) {\n                        queue[len] = callback;\n                        queue[len + 1] = arg;\n                        len += 2;\n                        if (len === 2) {\n                            // If len is 2, that means that we need to schedule an async flush.\n                            // If additional callbacks are queued before the queue is flushed, they\n                            // will be processed by this flush that we are scheduling.\n                            if (customSchedulerFn) {\n                                customSchedulerFn(flush);\n                            } else {\n                                scheduleFlush();\n                            }\n                        }\n                    };\n                    function setScheduler(scheduleFn) {\n                        customSchedulerFn = scheduleFn;\n                    }\n                    function setAsap(asapFn) {\n                        asap = asapFn;\n                    }\n                    var browserWindow =  false ? 0 : undefined;\n                    var browserGlobal = browserWindow || {};\n                    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n                    var isNode = typeof self === \"undefined\" && typeof process !== \"undefined\" && ({}).toString.call(process) === \"[object process]\";\n                    // test for web worker but not in IE10\n                    var isWorker = typeof Uint8ClampedArray !== \"undefined\" && typeof importScripts !== \"undefined\" && typeof MessageChannel !== \"undefined\";\n                    // node\n                    function useNextTick() {\n                        // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n                        // see https://github.com/cujojs/when/issues/410 for details\n                        return function() {\n                            return process.nextTick(flush);\n                        };\n                    }\n                    // vertx\n                    function useVertxTimer() {\n                        if (typeof vertxNext !== \"undefined\") {\n                            return function() {\n                                vertxNext(flush);\n                            };\n                        }\n                        return useSetTimeout();\n                    }\n                    function useMutationObserver() {\n                        var iterations = 0;\n                        var observer = new BrowserMutationObserver(flush);\n                        var node = document.createTextNode(\"\");\n                        observer.observe(node, {\n                            characterData: true\n                        });\n                        return function() {\n                            node.data = iterations = ++iterations % 2;\n                        };\n                    }\n                    // web worker\n                    function useMessageChannel() {\n                        var channel = new MessageChannel();\n                        channel.port1.onmessage = flush;\n                        return function() {\n                            return channel.port2.postMessage(0);\n                        };\n                    }\n                    function useSetTimeout() {\n                        // Store setTimeout reference so es6-promise will be unaffected by\n                        // other code modifying setTimeout (like sinon.useFakeTimers())\n                        var globalSetTimeout = setTimeout;\n                        return function() {\n                            return globalSetTimeout(flush, 1);\n                        };\n                    }\n                    var queue = new Array(1000);\n                    function flush() {\n                        for(var i = 0; i < len; i += 2){\n                            var callback = queue[i];\n                            var arg = queue[i + 1];\n                            callback(arg);\n                            queue[i] = undefined;\n                            queue[i + 1] = undefined;\n                        }\n                        len = 0;\n                    }\n                    function attemptVertx() {\n                        try {\n                            var vertx = Function(\"return this\")().require(\"vertx\");\n                            vertxNext = vertx.runOnLoop || vertx.runOnContext;\n                            return useVertxTimer();\n                        } catch (e) {\n                            return useSetTimeout();\n                        }\n                    }\n                    var scheduleFlush = void 0;\n                    // Decide what async method to use to triggering processing of queued callbacks:\n                    if (isNode) {\n                        scheduleFlush = useNextTick();\n                    } else if (BrowserMutationObserver) {\n                        scheduleFlush = useMutationObserver();\n                    } else if (isWorker) {\n                        scheduleFlush = useMessageChannel();\n                    } else if (browserWindow === undefined && \"function\" === \"function\") {\n                        scheduleFlush = attemptVertx();\n                    } else {\n                        scheduleFlush = useSetTimeout();\n                    }\n                    function then(onFulfillment, onRejection) {\n                        var parent = this;\n                        var child = new this.constructor(noop);\n                        if (child[PROMISE_ID] === undefined) {\n                            makePromise(child);\n                        }\n                        var _state = parent._state;\n                        if (_state) {\n                            var callback = arguments[_state - 1];\n                            asap(function() {\n                                return invokeCallback(_state, child, callback, parent._result);\n                            });\n                        } else {\n                            subscribe(parent, child, onFulfillment, onRejection);\n                        }\n                        return child;\n                    }\n                    /**\n  `Promise.resolve` returns a promise that will become resolved with the\n  passed `value`. It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    resolve(1);\n  });\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.resolve(1);\n\n  promise.then(function(value){\n    // value === 1\n  });\n  ```\n\n  @method resolve\n  @static\n  @param {Any} value value that the returned promise will be resolved with\n  Useful for tooling.\n  @return {Promise} a promise that will become fulfilled with the given\n  `value`\n*/ function resolve$1(object) {\n                        /*jshint validthis:true */ var Constructor = this;\n                        if (object && typeof object === \"object\" && object.constructor === Constructor) {\n                            return object;\n                        }\n                        var promise = new Constructor(noop);\n                        resolve(promise, object);\n                        return promise;\n                    }\n                    var PROMISE_ID = Math.random().toString(36).substring(2);\n                    function noop() {}\n                    var PENDING = void 0;\n                    var FULFILLED = 1;\n                    var REJECTED = 2;\n                    function selfFulfillment() {\n                        return new TypeError(\"You cannot resolve a promise with itself\");\n                    }\n                    function cannotReturnOwn() {\n                        return new TypeError(\"A promises callback cannot return that same promise.\");\n                    }\n                    function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n                        try {\n                            then$$1.call(value, fulfillmentHandler, rejectionHandler);\n                        } catch (e) {\n                            return e;\n                        }\n                    }\n                    function handleForeignThenable(promise, thenable, then$$1) {\n                        asap(function(promise) {\n                            var sealed = false;\n                            var error = tryThen(then$$1, thenable, function(value) {\n                                if (sealed) {\n                                    return;\n                                }\n                                sealed = true;\n                                if (thenable !== value) {\n                                    resolve(promise, value);\n                                } else {\n                                    fulfill(promise, value);\n                                }\n                            }, function(reason) {\n                                if (sealed) {\n                                    return;\n                                }\n                                sealed = true;\n                                reject(promise, reason);\n                            }, \"Settle: \" + (promise._label || \" unknown promise\"));\n                            if (!sealed && error) {\n                                sealed = true;\n                                reject(promise, error);\n                            }\n                        }, promise);\n                    }\n                    function handleOwnThenable(promise, thenable) {\n                        if (thenable._state === FULFILLED) {\n                            fulfill(promise, thenable._result);\n                        } else if (thenable._state === REJECTED) {\n                            reject(promise, thenable._result);\n                        } else {\n                            subscribe(thenable, undefined, function(value) {\n                                return resolve(promise, value);\n                            }, function(reason) {\n                                return reject(promise, reason);\n                            });\n                        }\n                    }\n                    function handleMaybeThenable(promise, maybeThenable, then$$1) {\n                        if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n                            handleOwnThenable(promise, maybeThenable);\n                        } else {\n                            if (then$$1 === undefined) {\n                                fulfill(promise, maybeThenable);\n                            } else if (isFunction(then$$1)) {\n                                handleForeignThenable(promise, maybeThenable, then$$1);\n                            } else {\n                                fulfill(promise, maybeThenable);\n                            }\n                        }\n                    }\n                    function resolve(promise, value) {\n                        if (promise === value) {\n                            reject(promise, selfFulfillment());\n                        } else if (objectOrFunction(value)) {\n                            var then$$1 = void 0;\n                            try {\n                                then$$1 = value.then;\n                            } catch (error) {\n                                reject(promise, error);\n                                return;\n                            }\n                            handleMaybeThenable(promise, value, then$$1);\n                        } else {\n                            fulfill(promise, value);\n                        }\n                    }\n                    function publishRejection(promise) {\n                        if (promise._onerror) {\n                            promise._onerror(promise._result);\n                        }\n                        publish(promise);\n                    }\n                    function fulfill(promise, value) {\n                        if (promise._state !== PENDING) {\n                            return;\n                        }\n                        promise._result = value;\n                        promise._state = FULFILLED;\n                        if (promise._subscribers.length !== 0) {\n                            asap(publish, promise);\n                        }\n                    }\n                    function reject(promise, reason) {\n                        if (promise._state !== PENDING) {\n                            return;\n                        }\n                        promise._state = REJECTED;\n                        promise._result = reason;\n                        asap(publishRejection, promise);\n                    }\n                    function subscribe(parent, child, onFulfillment, onRejection) {\n                        var _subscribers = parent._subscribers;\n                        var length = _subscribers.length;\n                        parent._onerror = null;\n                        _subscribers[length] = child;\n                        _subscribers[length + FULFILLED] = onFulfillment;\n                        _subscribers[length + REJECTED] = onRejection;\n                        if (length === 0 && parent._state) {\n                            asap(publish, parent);\n                        }\n                    }\n                    function publish(promise) {\n                        var subscribers = promise._subscribers;\n                        var settled = promise._state;\n                        if (subscribers.length === 0) {\n                            return;\n                        }\n                        var child = void 0, callback = void 0, detail = promise._result;\n                        for(var i = 0; i < subscribers.length; i += 3){\n                            child = subscribers[i];\n                            callback = subscribers[i + settled];\n                            if (child) {\n                                invokeCallback(settled, child, callback, detail);\n                            } else {\n                                callback(detail);\n                            }\n                        }\n                        promise._subscribers.length = 0;\n                    }\n                    function invokeCallback(settled, promise, callback, detail) {\n                        var hasCallback = isFunction(callback), value = void 0, error = void 0, succeeded = true;\n                        if (hasCallback) {\n                            try {\n                                value = callback(detail);\n                            } catch (e) {\n                                succeeded = false;\n                                error = e;\n                            }\n                            if (promise === value) {\n                                reject(promise, cannotReturnOwn());\n                                return;\n                            }\n                        } else {\n                            value = detail;\n                        }\n                        if (promise._state !== PENDING) {\n                        // noop\n                        } else if (hasCallback && succeeded) {\n                            resolve(promise, value);\n                        } else if (succeeded === false) {\n                            reject(promise, error);\n                        } else if (settled === FULFILLED) {\n                            fulfill(promise, value);\n                        } else if (settled === REJECTED) {\n                            reject(promise, value);\n                        }\n                    }\n                    function initializePromise(promise, resolver) {\n                        try {\n                            resolver(function resolvePromise(value) {\n                                resolve(promise, value);\n                            }, function rejectPromise(reason) {\n                                reject(promise, reason);\n                            });\n                        } catch (e) {\n                            reject(promise, e);\n                        }\n                    }\n                    var id = 0;\n                    function nextId() {\n                        return id++;\n                    }\n                    function makePromise(promise) {\n                        promise[PROMISE_ID] = id++;\n                        promise._state = undefined;\n                        promise._result = undefined;\n                        promise._subscribers = [];\n                    }\n                    function validationError() {\n                        return new Error(\"Array Methods must be provided an Array\");\n                    }\n                    var Enumerator = function() {\n                        function Enumerator(Constructor, input) {\n                            this._instanceConstructor = Constructor;\n                            this.promise = new Constructor(noop);\n                            if (!this.promise[PROMISE_ID]) {\n                                makePromise(this.promise);\n                            }\n                            if (isArray(input)) {\n                                this.length = input.length;\n                                this._remaining = input.length;\n                                this._result = new Array(this.length);\n                                if (this.length === 0) {\n                                    fulfill(this.promise, this._result);\n                                } else {\n                                    this.length = this.length || 0;\n                                    this._enumerate(input);\n                                    if (this._remaining === 0) {\n                                        fulfill(this.promise, this._result);\n                                    }\n                                }\n                            } else {\n                                reject(this.promise, validationError());\n                            }\n                        }\n                        Enumerator.prototype._enumerate = function _enumerate(input) {\n                            for(var i = 0; this._state === PENDING && i < input.length; i++){\n                                this._eachEntry(input[i], i);\n                            }\n                        };\n                        Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {\n                            var c = this._instanceConstructor;\n                            var resolve$$1 = c.resolve;\n                            if (resolve$$1 === resolve$1) {\n                                var _then = void 0;\n                                var error = void 0;\n                                var didError = false;\n                                try {\n                                    _then = entry.then;\n                                } catch (e) {\n                                    didError = true;\n                                    error = e;\n                                }\n                                if (_then === then && entry._state !== PENDING) {\n                                    this._settledAt(entry._state, i, entry._result);\n                                } else if (typeof _then !== \"function\") {\n                                    this._remaining--;\n                                    this._result[i] = entry;\n                                } else if (c === Promise$1) {\n                                    var promise = new c(noop);\n                                    if (didError) {\n                                        reject(promise, error);\n                                    } else {\n                                        handleMaybeThenable(promise, entry, _then);\n                                    }\n                                    this._willSettleAt(promise, i);\n                                } else {\n                                    this._willSettleAt(new c(function(resolve$$1) {\n                                        return resolve$$1(entry);\n                                    }), i);\n                                }\n                            } else {\n                                this._willSettleAt(resolve$$1(entry), i);\n                            }\n                        };\n                        Enumerator.prototype._settledAt = function _settledAt(state, i, value) {\n                            var promise = this.promise;\n                            if (promise._state === PENDING) {\n                                this._remaining--;\n                                if (state === REJECTED) {\n                                    reject(promise, value);\n                                } else {\n                                    this._result[i] = value;\n                                }\n                            }\n                            if (this._remaining === 0) {\n                                fulfill(promise, this._result);\n                            }\n                        };\n                        Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {\n                            var enumerator = this;\n                            subscribe(promise, undefined, function(value) {\n                                return enumerator._settledAt(FULFILLED, i, value);\n                            }, function(reason) {\n                                return enumerator._settledAt(REJECTED, i, reason);\n                            });\n                        };\n                        return Enumerator;\n                    }();\n                    /**\n  `Promise.all` accepts an array of promises, and returns a new promise which\n  is fulfilled with an array of fulfillment values for the passed promises, or\n  rejected with the reason of the first passed promise to be rejected. It casts all\n  elements of the passed iterable to promises as it runs this algorithm.\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = resolve(2);\n  let promise3 = resolve(3);\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // The array here would be [ 1, 2, 3 ];\n  });\n  ```\n\n  If any of the `promises` given to `all` are rejected, the first promise\n  that is rejected will be given as an argument to the returned promises's\n  rejection handler. For example:\n\n  Example:\n\n  ```javascript\n  let promise1 = resolve(1);\n  let promise2 = reject(new Error(\"2\"));\n  let promise3 = reject(new Error(\"3\"));\n  let promises = [ promise1, promise2, promise3 ];\n\n  Promise.all(promises).then(function(array){\n    // Code here never runs because there are rejected promises!\n  }, function(error) {\n    // error.message === \"2\"\n  });\n  ```\n\n  @method all\n  @static\n  @param {Array} entries array of promises\n  @param {String} label optional string for labeling the promise.\n  Useful for tooling.\n  @return {Promise} promise that is fulfilled when all `promises` have been\n  fulfilled, or rejected if any of them become rejected.\n  @static\n*/ function all(entries) {\n                        return new Enumerator(this, entries).promise;\n                    }\n                    /**\n  `Promise.race` returns a new promise which is settled in the same way as the\n  first passed promise to settle.\n\n  Example:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 2');\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // result === 'promise 2' because it was resolved before promise1\n    // was resolved.\n  });\n  ```\n\n  `Promise.race` is deterministic in that only the state of the first\n  settled promise matters. For example, even if other promises given to the\n  `promises` array argument are resolved, but the first settled promise has\n  become rejected before the other promises became fulfilled, the returned\n  promise will become rejected:\n\n  ```javascript\n  let promise1 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      resolve('promise 1');\n    }, 200);\n  });\n\n  let promise2 = new Promise(function(resolve, reject){\n    setTimeout(function(){\n      reject(new Error('promise 2'));\n    }, 100);\n  });\n\n  Promise.race([promise1, promise2]).then(function(result){\n    // Code here never runs\n  }, function(reason){\n    // reason.message === 'promise 2' because promise 2 became rejected before\n    // promise 1 became fulfilled\n  });\n  ```\n\n  An example real-world use case is implementing timeouts:\n\n  ```javascript\n  Promise.race([ajax('foo.json'), timeout(5000)])\n  ```\n\n  @method race\n  @static\n  @param {Array} promises array of promises to observe\n  Useful for tooling.\n  @return {Promise} a promise which settles in the same way as the first passed\n  promise to settle.\n*/ function race(entries) {\n                        /*jshint validthis:true */ var Constructor = this;\n                        if (!isArray(entries)) {\n                            return new Constructor(function(_, reject) {\n                                return reject(new TypeError(\"You must pass an array to race.\"));\n                            });\n                        } else {\n                            return new Constructor(function(resolve, reject) {\n                                var length = entries.length;\n                                for(var i = 0; i < length; i++){\n                                    Constructor.resolve(entries[i]).then(resolve, reject);\n                                }\n                            });\n                        }\n                    }\n                    /**\n  `Promise.reject` returns a promise rejected with the passed `reason`.\n  It is shorthand for the following:\n\n  ```javascript\n  let promise = new Promise(function(resolve, reject){\n    reject(new Error('WHOOPS'));\n  });\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  Instead of writing the above, your code now simply becomes the following:\n\n  ```javascript\n  let promise = Promise.reject(new Error('WHOOPS'));\n\n  promise.then(function(value){\n    // Code here doesn't run because the promise is rejected!\n  }, function(reason){\n    // reason.message === 'WHOOPS'\n  });\n  ```\n\n  @method reject\n  @static\n  @param {Any} reason value that the returned promise will be rejected with.\n  Useful for tooling.\n  @return {Promise} a promise rejected with the given `reason`.\n*/ function reject$1(reason) {\n                        /*jshint validthis:true */ var Constructor = this;\n                        var promise = new Constructor(noop);\n                        reject(promise, reason);\n                        return promise;\n                    }\n                    function needsResolver() {\n                        throw new TypeError(\"You must pass a resolver function as the first argument to the promise constructor\");\n                    }\n                    function needsNew() {\n                        throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n                    }\n                    /**\n  Promise objects represent the eventual result of an asynchronous operation. The\n  primary way of interacting with a promise is through its `then` method, which\n  registers callbacks to receive either a promise's eventual value or the reason\n  why the promise cannot be fulfilled.\n\n  Terminology\n  -----------\n\n  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n  - `thenable` is an object or function that defines a `then` method.\n  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n  - `exception` is a value that is thrown using the throw statement.\n  - `reason` is a value that indicates why a promise was rejected.\n  - `settled` the final resting state of a promise, fulfilled or rejected.\n\n  A promise can be in one of three states: pending, fulfilled, or rejected.\n\n  Promises that are fulfilled have a fulfillment value and are in the fulfilled\n  state.  Promises that are rejected have a rejection reason and are in the\n  rejected state.  A fulfillment value is never a thenable.\n\n  Promises can also be said to *resolve* a value.  If this value is also a\n  promise, then the original promise's settled state will match the value's\n  settled state.  So a promise that *resolves* a promise that rejects will\n  itself reject, and a promise that *resolves* a promise that fulfills will\n  itself fulfill.\n\n\n  Basic Usage:\n  ------------\n\n  ```js\n  let promise = new Promise(function(resolve, reject) {\n    // on success\n    resolve(value);\n\n    // on failure\n    reject(reason);\n  });\n\n  promise.then(function(value) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Advanced Usage:\n  ---------------\n\n  Promises shine when abstracting away asynchronous interactions such as\n  `XMLHttpRequest`s.\n\n  ```js\n  function getJSON(url) {\n    return new Promise(function(resolve, reject){\n      let xhr = new XMLHttpRequest();\n\n      xhr.open('GET', url);\n      xhr.onreadystatechange = handler;\n      xhr.responseType = 'json';\n      xhr.setRequestHeader('Accept', 'application/json');\n      xhr.send();\n\n      function handler() {\n        if (this.readyState === this.DONE) {\n          if (this.status === 200) {\n            resolve(this.response);\n          } else {\n            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n          }\n        }\n      };\n    });\n  }\n\n  getJSON('/posts.json').then(function(json) {\n    // on fulfillment\n  }, function(reason) {\n    // on rejection\n  });\n  ```\n\n  Unlike callbacks, promises are great composable primitives.\n\n  ```js\n  Promise.all([\n    getJSON('/posts'),\n    getJSON('/comments')\n  ]).then(function(values){\n    values[0] // => postsJSON\n    values[1] // => commentsJSON\n\n    return values;\n  });\n  ```\n\n  @class Promise\n  @param {Function} resolver\n  Useful for tooling.\n  @constructor\n*/ var Promise$1 = function() {\n                        function Promise(resolver) {\n                            this[PROMISE_ID] = nextId();\n                            this._result = this._state = undefined;\n                            this._subscribers = [];\n                            if (noop !== resolver) {\n                                typeof resolver !== \"function\" && needsResolver();\n                                this instanceof Promise ? initializePromise(this, resolver) : needsNew();\n                            }\n                        }\n                        /**\n  The primary way of interacting with a promise is through its `then` method,\n  which registers callbacks to receive either a promise's eventual value or the\n  reason why the promise cannot be fulfilled.\n   ```js\n  findUser().then(function(user){\n    // user is available\n  }, function(reason){\n    // user is unavailable, and you are given the reason why\n  });\n  ```\n   Chaining\n  --------\n   The return value of `then` is itself a promise.  This second, 'downstream'\n  promise is resolved with the return value of the first promise's fulfillment\n  or rejection handler, or rejected if the handler throws an exception.\n   ```js\n  findUser().then(function (user) {\n    return user.name;\n  }, function (reason) {\n    return 'default name';\n  }).then(function (userName) {\n    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n    // will be `'default name'`\n  });\n   findUser().then(function (user) {\n    throw new Error('Found user, but still unhappy');\n  }, function (reason) {\n    throw new Error('`findUser` rejected and we're unhappy');\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n  });\n  ```\n  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n   ```js\n  findUser().then(function (user) {\n    throw new PedagogicalException('Upstream error');\n  }).then(function (value) {\n    // never reached\n  }).then(function (value) {\n    // never reached\n  }, function (reason) {\n    // The `PedgagocialException` is propagated all the way down to here\n  });\n  ```\n   Assimilation\n  ------------\n   Sometimes the value you want to propagate to a downstream promise can only be\n  retrieved asynchronously. This can be achieved by returning a promise in the\n  fulfillment or rejection handler. The downstream promise will then be pending\n  until the returned promise is settled. This is called *assimilation*.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // The user's comments are now available\n  });\n  ```\n   If the assimliated promise rejects, then the downstream promise will also reject.\n   ```js\n  findUser().then(function (user) {\n    return findCommentsByAuthor(user);\n  }).then(function (comments) {\n    // If `findCommentsByAuthor` fulfills, we'll have the value here\n  }, function (reason) {\n    // If `findCommentsByAuthor` rejects, we'll have the reason here\n  });\n  ```\n   Simple Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let result;\n   try {\n    result = findResult();\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n  findResult(function(result, err){\n    if (err) {\n      // failure\n    } else {\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findResult().then(function(result){\n    // success\n  }, function(reason){\n    // failure\n  });\n  ```\n   Advanced Example\n  --------------\n   Synchronous Example\n   ```javascript\n  let author, books;\n   try {\n    author = findAuthor();\n    books  = findBooksByAuthor(author);\n    // success\n  } catch(reason) {\n    // failure\n  }\n  ```\n   Errback Example\n   ```js\n   function foundBooks(books) {\n   }\n   function failure(reason) {\n   }\n   findAuthor(function(author, err){\n    if (err) {\n      failure(err);\n      // failure\n    } else {\n      try {\n        findBoooksByAuthor(author, function(books, err) {\n          if (err) {\n            failure(err);\n          } else {\n            try {\n              foundBooks(books);\n            } catch(reason) {\n              failure(reason);\n            }\n          }\n        });\n      } catch(error) {\n        failure(err);\n      }\n      // success\n    }\n  });\n  ```\n   Promise Example;\n   ```javascript\n  findAuthor().\n    then(findBooksByAuthor).\n    then(function(books){\n      // found books\n  }).catch(function(reason){\n    // something went wrong\n  });\n  ```\n   @method then\n  @param {Function} onFulfilled\n  @param {Function} onRejected\n  Useful for tooling.\n  @return {Promise}\n  */ /**\n  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n  as the catch block of a try/catch statement.\n  ```js\n  function findAuthor(){\n  throw new Error('couldn't find that author');\n  }\n  // synchronous\n  try {\n  findAuthor();\n  } catch(reason) {\n  // something went wrong\n  }\n  // async with promises\n  findAuthor().catch(function(reason){\n  // something went wrong\n  });\n  ```\n  @method catch\n  @param {Function} onRejection\n  Useful for tooling.\n  @return {Promise}\n  */ Promise.prototype.catch = function _catch(onRejection) {\n                            return this.then(null, onRejection);\n                        };\n                        /**\n    `finally` will be invoked regardless of the promise's fate just as native\n    try/catch/finally behaves\n  \n    Synchronous example:\n  \n    ```js\n    findAuthor() {\n      if (Math.random() > 0.5) {\n        throw new Error();\n      }\n      return new Author();\n    }\n  \n    try {\n      return findAuthor(); // succeed or fail\n    } catch(error) {\n      return findOtherAuther();\n    } finally {\n      // always runs\n      // doesn't affect the return value\n    }\n    ```\n  \n    Asynchronous example:\n  \n    ```js\n    findAuthor().catch(function(reason){\n      return findOtherAuther();\n    }).finally(function(){\n      // author was either found, or not\n    });\n    ```\n  \n    @method finally\n    @param {Function} callback\n    @return {Promise}\n  */ Promise.prototype.finally = function _finally(callback) {\n                            var promise = this;\n                            var constructor = promise.constructor;\n                            if (isFunction(callback)) {\n                                return promise.then(function(value) {\n                                    return constructor.resolve(callback()).then(function() {\n                                        return value;\n                                    });\n                                }, function(reason) {\n                                    return constructor.resolve(callback()).then(function() {\n                                        throw reason;\n                                    });\n                                });\n                            }\n                            return promise.then(callback, callback);\n                        };\n                        return Promise;\n                    }();\n                    Promise$1.prototype.then = then;\n                    Promise$1.all = all;\n                    Promise$1.race = race;\n                    Promise$1.resolve = resolve$1;\n                    Promise$1.reject = reject$1;\n                    Promise$1._setScheduler = setScheduler;\n                    Promise$1._setAsap = setAsap;\n                    Promise$1._asap = asap;\n                    /*global self*/ function polyfill() {\n                        var local = void 0;\n                        if (typeof global !== \"undefined\") {\n                            local = global;\n                        } else if (typeof self !== \"undefined\") {\n                            local = self;\n                        } else {\n                            try {\n                                local = Function(\"return this\")();\n                            } catch (e) {\n                                throw new Error(\"polyfill failed because global object is unavailable in this environment\");\n                            }\n                        }\n                        var P = local.Promise;\n                        if (P) {\n                            var promiseToString = null;\n                            try {\n                                promiseToString = Object.prototype.toString.call(P.resolve());\n                            } catch (e) {\n                            // silently ignored\n                            }\n                            if (promiseToString === \"[object Promise]\" && !P.cast) {\n                                return;\n                            }\n                        }\n                        local.Promise = Promise$1;\n                    }\n                    // Strange compat..\n                    Promise$1.polyfill = polyfill;\n                    Promise$1.Promise = Promise$1;\n                    return Promise$1;\n                });\n            //# sourceMappingURL=es6-promise.map\n            /***/ },\n            /***/ \"html2canvas\": /*!******************************!*\\\n  !*** external \"html2canvas\" ***!\n  \\******************************/ /***/ function(module1) {\n                \"use strict\";\n                module1.exports = __WEBPACK_EXTERNAL_MODULE_html2canvas__;\n            /***/ },\n            /***/ \"jspdf\": /*!************************!*\\\n  !*** external \"jspdf\" ***!\n  \\************************/ /***/ function(module1) {\n                \"use strict\";\n                module1.exports = __WEBPACK_EXTERNAL_MODULE_jspdf__;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_304567__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_304567__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /* webpack/runtime/compat get default export */ /******/ !function() {\n            /******/ // getDefaultExport function for compatibility with non-harmony modules\n            /******/ __nested_webpack_require_304567__.n = function(module1) {\n                /******/ var getter = module1 && module1.__esModule ? /******/ function() {\n                    return module1[\"default\"];\n                } : /******/ function() {\n                    return module1;\n                };\n                /******/ __nested_webpack_require_304567__.d(getter, {\n                    a: getter\n                });\n                /******/ return getter;\n            /******/ };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/define property getters */ /******/ !function() {\n            /******/ // define getter functions for harmony exports\n            /******/ __nested_webpack_require_304567__.d = function(exports1, definition) {\n                /******/ for(var key in definition){\n                    /******/ if (__nested_webpack_require_304567__.o(definition, key) && !__nested_webpack_require_304567__.o(exports1, key)) {\n                        /******/ Object.defineProperty(exports1, key, {\n                            enumerable: true,\n                            get: definition[key]\n                        });\n                    /******/ }\n                /******/ }\n            /******/ };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ !function() {\n            /******/ __nested_webpack_require_304567__.o = function(obj, prop) {\n                return Object.prototype.hasOwnProperty.call(obj, prop);\n            };\n        /******/ }();\n        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ !function() {\n            /******/ // define __esModule on exports\n            /******/ __nested_webpack_require_304567__.r = function(exports1) {\n                /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                        value: \"Module\"\n                    });\n                /******/ }\n                /******/ Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /******/ };\n        /******/ }();\n        /******/ /************************************************************************/ var __nested_webpack_exports__ = {};\n        // This entry need to be wrapped in an IIFE because it need to be in strict mode.\n        !function() {\n            \"use strict\";\n            /*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/ __nested_webpack_require_304567__.r(__nested_webpack_exports__);\n            /* harmony import */ var _worker_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_304567__(/*! ./worker.js */ \"./src/worker.js\");\n            /* harmony import */ var _plugin_jspdf_plugin_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_304567__(/*! ./plugin/jspdf-plugin.js */ \"./src/plugin/jspdf-plugin.js\");\n            /* harmony import */ var _plugin_pagebreaks_js__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_304567__(/*! ./plugin/pagebreaks.js */ \"./src/plugin/pagebreaks.js\");\n            /* harmony import */ var _plugin_hyperlinks_js__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_304567__(/*! ./plugin/hyperlinks.js */ \"./src/plugin/hyperlinks.js\");\n            /**\n * Generate a PDF from an HTML element or string using html2canvas and jsPDF.\n *\n * @param {Element|string} source The source element or HTML string.\n * @param {Object=} opt An object of optional settings: 'margin', 'filename',\n *    'image' ('type' and 'quality'), and 'html2canvas' / 'jspdf', which are\n *    sent as settings to their corresponding functions.\n */ var html2pdf = function html2pdf(src, opt) {\n                // Create a new worker with the given options.\n                var worker = new html2pdf.Worker(opt);\n                if (src) {\n                    // If src is specified, perform the traditional 'simple' operation.\n                    return worker.from(src).save();\n                } else {\n                    // Otherwise, return the worker for new Promise-based operation.\n                    return worker;\n                }\n            };\n            html2pdf.Worker = _worker_js__WEBPACK_IMPORTED_MODULE_0__.default; // Expose the html2pdf function.\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = html2pdf;\n        }();\n        __nested_webpack_exports__ = __nested_webpack_exports__.default;\n        /******/ return __nested_webpack_exports__;\n    /******/ }();\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaHRtbDJwZGYuanMvZGlzdC9odG1sMnBkZi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDLEdBQ0EsVUFBU0EsaUNBQWlDQyxJQUFJLEVBQUVDLE9BQU87SUFDdkQsSUFBRyxJQUFpRCxFQUNuREUsT0FBT0QsT0FBTyxHQUFHRCxRQUFRRyxtQkFBT0EsQ0FBQyw4REFBTyxHQUFHQSxtQkFBT0EsQ0FBQyw2RUFBYTtTQUM1RCxFQUsyRDtBQUNqRSxHQUFHRyxNQUFNLFNBQVNDLGlDQUFpQyxFQUFFQyx1Q0FBdUM7SUFDNUYsT0FBZ0IsTUFBSCxHQUFJO1FBQ2pCLE1BQU0sR0FBSSxJQUFJQyxzQkFBdUI7WUFFckMsR0FBRyxHQUFHLDhCQUNOOztvQ0FFb0MsR0FDcEMsR0FBRyxHQUFJLFNBQVNDLHVCQUF1QixFQUFFQywwQkFBbUIsRUFBRUMsK0JBQW1CO2dCQUVqRjtnQkFDQUEsK0JBQW1CQSxDQUFDQyxDQUFDLENBQUNGLDBCQUFtQkE7Z0JBQ3pDLGtCQUFrQixHQUFHLElBQUlHLCtFQUErRUYsK0JBQW1CQSxDQUFDLG9EQUFvRCxHQUFHO2dCQUNuTCxrQkFBa0IsR0FBRyxJQUFJRyx1RkFBdUYsV0FBVyxHQUFFSCwrQkFBbUJBLENBQUNJLENBQUMsQ0FBQ0Y7Z0JBQ25KLGtCQUFrQixHQUFHLElBQUlHLGlFQUFpRUwsK0JBQW1CQSxDQUFDLHNDQUFzQyxHQUFHO2dCQUN2SixrQkFBa0IsR0FBRyxJQUFJTSx5RUFBeUUsV0FBVyxHQUFFTiwrQkFBbUJBLENBQUNJLENBQUMsQ0FBQ0M7Z0JBQ3JJLGtCQUFrQixHQUFHLElBQUlFLDBDQUEwQ1AsK0JBQW1CQSxDQUFDLGlCQUFpQixHQUFHO2dCQUMzRyxrQkFBa0IsR0FBRyxJQUFJUSx5Q0FBeUNSLCtCQUFtQkEsQ0FBQyxnQkFBZ0IsR0FBRztnQkFJeEcsbURBQW1EO2dCQUNwRCxtREFBbUQ7Z0JBRW5ELElBQUlTLFdBQVcsRUFBRTtnQkFDakIsSUFBSUMsT0FBTztvQkFD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WUFFQUQsU0FBUy9yQixNQUFNLEdBQUcyckIsd0NBQXdDajVCLE9BQU8sRUFBRSxnQ0FBZ0M7WUFFbkcsMEJBQTBCLEdBQUdiLDBCQUFtQixDQUFDLFVBQVUsR0FBSWs2QjtRQUMvRDtRQUNBbDZCLDBCQUFtQkEsR0FBR0EsMEJBQW1CQSxDQUFDYSxPQUFPO1FBQ2pELE1BQU0sR0FBSSxPQUFPYiwwQkFBbUJBO0lBQ3BDLE1BQU0sR0FBRztBQUVUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2FuZGVybGVucy8uL25vZGVfbW9kdWxlcy9odG1sMnBkZi5qcy9kaXN0L2h0bWwycGRmLmpzPzg1MzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBodG1sMnBkZi5qcyB2MC4xMC4yXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjQgRXJpayBLb29wbWFuc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJqc3BkZlwiKSwgcmVxdWlyZShcImh0bWwyY2FudmFzXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiaHRtbDJwZGZcIiwgW1wianNwZGZcIiwgXCJodG1sMmNhbnZhc1wiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJodG1sMnBkZlwiXSA9IGZhY3RvcnkocmVxdWlyZShcImpzcGRmXCIpLCByZXF1aXJlKFwiaHRtbDJjYW52YXNcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImh0bWwycGRmXCJdID0gZmFjdG9yeShyb290W1wianNwZGZcIl0sIHJvb3RbXCJodG1sMmNhbnZhc1wiXSk7XG59KShzZWxmLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2pzcGRmX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfaHRtbDJjYW52YXNfXykge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbigpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9zcmMvcGx1Z2luL2h5cGVybGlua3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcGx1Z2luL2h5cGVybGlua3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19mb3JfZWFjaF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfc3RyaW5nX2xpbmtfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubGluay5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubGluay5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfc3RyaW5nX2xpbmtfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfc3RyaW5nX2xpbmtfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vd29ya2VyLmpzICovIFwiLi9zcmMvd29ya2VyLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vdXRpbHMuanMgKi8gXCIuL3NyYy91dGlscy5qc1wiKTtcblxuXG5cbiAvLyBBZGQgaHlwZXJsaW5rIGZ1bmN0aW9uYWxpdHkgdG8gdGhlIFBERiBjcmVhdGlvbi5cbi8vIE1haW4gbGluayBhcnJheSwgYW5kIHJlZnMgdG8gb3JpZ2luYWwgZnVuY3Rpb25zLlxuXG52YXIgbGlua0luZm8gPSBbXTtcbnZhciBvcmlnID0ge1xuICB0b0NvbnRhaW5lcjogX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmRlZmF1bHQucHJvdG90eXBlLnRvQ29udGFpbmVyLFxuICB0b1BkZjogX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fLmRlZmF1bHQucHJvdG90eXBlLnRvUGRmXG59O1xuXG5fd29ya2VyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18uZGVmYXVsdC5wcm90b3R5cGUudG9Db250YWluZXIgPSBmdW5jdGlvbiB0b0NvbnRhaW5lcigpIHtcbiAgcmV0dXJuIG9yaWcudG9Db250YWluZXIuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uIHRvQ29udGFpbmVyX2h5cGVybGluaygpIHtcbiAgICAvLyBSZXRyaWV2ZSBoeXBlcmxpbmsgaW5mbyBpZiB0aGUgb3B0aW9uIGlzIGVuYWJsZWQuXG4gICAgaWYgKHRoaXMub3B0LmVuYWJsZUxpbmtzKSB7XG4gICAgICAvLyBGaW5kIGFsbCBhbmNob3IgdGFncyBhbmQgZ2V0IHRoZSBjb250YWluZXIncyBib3VuZHMgZm9yIHJlZmVyZW5jZS5cbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLnByb3AuY29udGFpbmVyO1xuICAgICAgdmFyIGxpbmtzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2EnKTtcbiAgICAgIHZhciBjb250YWluZXJSZWN0ID0gKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18udW5pdENvbnZlcnQpKGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdGhpcy5wcm9wLnBhZ2VTaXplLmspO1xuICAgICAgbGlua0luZm8gPSBbXTsgLy8gTG9vcCB0aHJvdWdoIGVhY2ggYW5jaG9yIHRhZy5cblxuICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChsaW5rcywgZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgLy8gVHJlYXQgZWFjaCBjbGllbnQgcmVjdCBhcyBhIHNlcGFyYXRlIGxpbmsgKGZvciB0ZXh0LXdyYXBwaW5nKS5cbiAgICAgICAgdmFyIGNsaWVudFJlY3RzID0gbGluay5nZXRDbGllbnRSZWN0cygpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpZW50UmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2xpZW50UmVjdCA9ICgwLF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fLnVuaXRDb252ZXJ0KShjbGllbnRSZWN0c1tpXSwgdGhpcy5wcm9wLnBhZ2VTaXplLmspO1xuICAgICAgICAgIGNsaWVudFJlY3QubGVmdCAtPSBjb250YWluZXJSZWN0LmxlZnQ7XG4gICAgICAgICAgY2xpZW50UmVjdC50b3AgLT0gY29udGFpbmVyUmVjdC50b3A7XG4gICAgICAgICAgdmFyIHBhZ2UgPSBNYXRoLmZsb29yKGNsaWVudFJlY3QudG9wIC8gdGhpcy5wcm9wLnBhZ2VTaXplLmlubmVyLmhlaWdodCkgKyAxO1xuICAgICAgICAgIHZhciB0b3AgPSB0aGlzLm9wdC5tYXJnaW5bMF0gKyBjbGllbnRSZWN0LnRvcCAlIHRoaXMucHJvcC5wYWdlU2l6ZS5pbm5lci5oZWlnaHQ7XG4gICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLm9wdC5tYXJnaW5bMV0gKyBjbGllbnRSZWN0LmxlZnQ7XG4gICAgICAgICAgbGlua0luZm8ucHVzaCh7XG4gICAgICAgICAgICBwYWdlOiBwYWdlLFxuICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgY2xpZW50UmVjdDogY2xpZW50UmVjdCxcbiAgICAgICAgICAgIGxpbms6IGxpbmtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9KTtcbn07XG5cbl93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5kZWZhdWx0LnByb3RvdHlwZS50b1BkZiA9IGZ1bmN0aW9uIHRvUGRmKCkge1xuICByZXR1cm4gb3JpZy50b1BkZi5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gdG9QZGZfaHlwZXJsaW5rKCkge1xuICAgIC8vIEFkZCBoeXBlcmxpbmtzIGlmIHRoZSBvcHRpb24gaXMgZW5hYmxlZC5cbiAgICBpZiAodGhpcy5vcHQuZW5hYmxlTGlua3MpIHtcbiAgICAgIC8vIEF0dGFjaCBlYWNoIGFuY2hvciB0YWcgYmFzZWQgb24gaW5mbyBmcm9tIHRvQ29udGFpbmVyKCkuXG4gICAgICBsaW5rSW5mby5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgICAgIHRoaXMucHJvcC5wZGYuc2V0UGFnZShsLnBhZ2UpO1xuICAgICAgICB0aGlzLnByb3AucGRmLmxpbmsobC5sZWZ0LCBsLnRvcCwgbC5jbGllbnRSZWN0LndpZHRoLCBsLmNsaWVudFJlY3QuaGVpZ2h0LCB7XG4gICAgICAgICAgdXJsOiBsLmxpbmsuaHJlZlxuICAgICAgICB9KTtcbiAgICAgIH0sIHRoaXMpOyAvLyBSZXNldCB0aGUgYWN0aXZlIHBhZ2Ugb2YgdGhlIFBERiB0byB0aGUgZmluYWwgcGFnZS5cblxuICAgICAgdmFyIG5QYWdlcyA9IHRoaXMucHJvcC5wZGYuaW50ZXJuYWwuZ2V0TnVtYmVyT2ZQYWdlcygpO1xuICAgICAgdGhpcy5wcm9wLnBkZi5zZXRQYWdlKG5QYWdlcyk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3BsdWdpbi9qc3BkZi1wbHVnaW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9wbHVnaW4vanNwZGYtcGx1Z2luLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9kZXNjcmlwdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9kZXNjcmlwdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfZGVzY3JpcHRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganNwZGYgKi8gXCJqc3BkZlwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpzcGRmX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18pO1xuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLy8gSW1wb3J0IGRlcGVuZGVuY2llcy5cbiAvLyBHZXQgZGltZW5zaW9ucyBvZiBhIFBERiBwYWdlLCBhcyBkZXRlcm1pbmVkIGJ5IGpzUERGLlxuXG5qc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fLmpzUERGLmdldFBhZ2VTaXplID0gZnVuY3Rpb24gKG9yaWVudGF0aW9uLCB1bml0LCBmb3JtYXQpIHtcbiAgLy8gRGVjb2RlIG9wdGlvbnMgb2JqZWN0XG4gIGlmIChfdHlwZW9mKG9yaWVudGF0aW9uKSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IG9yaWVudGF0aW9uO1xuICAgIG9yaWVudGF0aW9uID0gb3B0aW9ucy5vcmllbnRhdGlvbjtcbiAgICB1bml0ID0gb3B0aW9ucy51bml0IHx8IHVuaXQ7XG4gICAgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgZm9ybWF0O1xuICB9IC8vIERlZmF1bHQgb3B0aW9uc1xuXG5cbiAgdW5pdCA9IHVuaXQgfHwgJ21tJztcbiAgZm9ybWF0ID0gZm9ybWF0IHx8ICdhNCc7XG4gIG9yaWVudGF0aW9uID0gKCcnICsgKG9yaWVudGF0aW9uIHx8ICdQJykpLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBmb3JtYXRfYXNfc3RyaW5nID0gKCcnICsgZm9ybWF0KS50b0xvd2VyQ2FzZSgpOyAvLyBTaXplIGluIHB0IG9mIHZhcmlvdXMgcGFwZXIgZm9ybWF0c1xuXG4gIHZhciBwYWdlRm9ybWF0cyA9IHtcbiAgICAnYTAnOiBbMjM4My45NCwgMzM3MC4zOV0sXG4gICAgJ2ExJzogWzE2ODMuNzgsIDIzODMuOTRdLFxuICAgICdhMic6IFsxMTkwLjU1LCAxNjgzLjc4XSxcbiAgICAnYTMnOiBbODQxLjg5LCAxMTkwLjU1XSxcbiAgICAnYTQnOiBbNTk1LjI4LCA4NDEuODldLFxuICAgICdhNSc6IFs0MTkuNTMsIDU5NS4yOF0sXG4gICAgJ2E2JzogWzI5Ny42NCwgNDE5LjUzXSxcbiAgICAnYTcnOiBbMjA5Ljc2LCAyOTcuNjRdLFxuICAgICdhOCc6IFsxNDcuNDAsIDIwOS43Nl0sXG4gICAgJ2E5JzogWzEwNC44OCwgMTQ3LjQwXSxcbiAgICAnYTEwJzogWzczLjcwLCAxMDQuODhdLFxuICAgICdiMCc6IFsyODM0LjY1LCA0MDA4LjE5XSxcbiAgICAnYjEnOiBbMjAwNC4wOSwgMjgzNC42NV0sXG4gICAgJ2IyJzogWzE0MTcuMzIsIDIwMDQuMDldLFxuICAgICdiMyc6IFsxMDAwLjYzLCAxNDE3LjMyXSxcbiAgICAnYjQnOiBbNzA4LjY2LCAxMDAwLjYzXSxcbiAgICAnYjUnOiBbNDk4LjkwLCA3MDguNjZdLFxuICAgICdiNic6IFszNTQuMzMsIDQ5OC45MF0sXG4gICAgJ2I3JzogWzI0OS40NSwgMzU0LjMzXSxcbiAgICAnYjgnOiBbMTc1Ljc1LCAyNDkuNDVdLFxuICAgICdiOSc6IFsxMjQuNzIsIDE3NS43NV0sXG4gICAgJ2IxMCc6IFs4Ny44NywgMTI0LjcyXSxcbiAgICAnYzAnOiBbMjU5OS4zNywgMzY3Ni41NF0sXG4gICAgJ2MxJzogWzE4MzYuODUsIDI1OTkuMzddLFxuICAgICdjMic6IFsxMjk4LjI3LCAxODM2Ljg1XSxcbiAgICAnYzMnOiBbOTE4LjQzLCAxMjk4LjI3XSxcbiAgICAnYzQnOiBbNjQ5LjEzLCA5MTguNDNdLFxuICAgICdjNSc6IFs0NTkuMjEsIDY0OS4xM10sXG4gICAgJ2M2JzogWzMyMy4xNSwgNDU5LjIxXSxcbiAgICAnYzcnOiBbMjI5LjYxLCAzMjMuMTVdLFxuICAgICdjOCc6IFsxNjEuNTcsIDIyOS42MV0sXG4gICAgJ2M5JzogWzExMy4zOSwgMTYxLjU3XSxcbiAgICAnYzEwJzogWzc5LjM3LCAxMTMuMzldLFxuICAgICdkbCc6IFszMTEuODEsIDYyMy42Ml0sXG4gICAgJ2xldHRlcic6IFs2MTIsIDc5Ml0sXG4gICAgJ2dvdmVybm1lbnQtbGV0dGVyJzogWzU3NiwgNzU2XSxcbiAgICAnbGVnYWwnOiBbNjEyLCAxMDA4XSxcbiAgICAnanVuaW9yLWxlZ2FsJzogWzU3NiwgMzYwXSxcbiAgICAnbGVkZ2VyJzogWzEyMjQsIDc5Ml0sXG4gICAgJ3RhYmxvaWQnOiBbNzkyLCAxMjI0XSxcbiAgICAnY3JlZGl0LWNhcmQnOiBbMTUzLCAyNDNdXG4gIH07IC8vIFVuaXQgY29udmVyc2lvblxuXG4gIHN3aXRjaCAodW5pdCkge1xuICAgIGNhc2UgJ3B0JzpcbiAgICAgIHZhciBrID0gMTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbW0nOlxuICAgICAgdmFyIGsgPSA3MiAvIDI1LjQ7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2NtJzpcbiAgICAgIHZhciBrID0gNzIgLyAyLjU0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbic6XG4gICAgICB2YXIgayA9IDcyO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdweCc6XG4gICAgICB2YXIgayA9IDcyIC8gOTY7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BjJzpcbiAgICAgIHZhciBrID0gMTI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2VtJzpcbiAgICAgIHZhciBrID0gMTI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2V4JzpcbiAgICAgIHZhciBrID0gNjtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93ICdJbnZhbGlkIHVuaXQ6ICcgKyB1bml0O1xuICB9IC8vIERpbWVuc2lvbnMgYXJlIHN0b3JlZCBhcyB1c2VyIHVuaXRzIGFuZCBjb252ZXJ0ZWQgdG8gcG9pbnRzIG9uIG91dHB1dFxuXG5cbiAgaWYgKHBhZ2VGb3JtYXRzLmhhc093blByb3BlcnR5KGZvcm1hdF9hc19zdHJpbmcpKSB7XG4gICAgdmFyIHBhZ2VIZWlnaHQgPSBwYWdlRm9ybWF0c1tmb3JtYXRfYXNfc3RyaW5nXVsxXSAvIGs7XG4gICAgdmFyIHBhZ2VXaWR0aCA9IHBhZ2VGb3JtYXRzW2Zvcm1hdF9hc19zdHJpbmddWzBdIC8gaztcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHBhZ2VIZWlnaHQgPSBmb3JtYXRbMV07XG4gICAgICB2YXIgcGFnZVdpZHRoID0gZm9ybWF0WzBdO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZvcm1hdDogJyArIGZvcm1hdCk7XG4gICAgfVxuICB9IC8vIEhhbmRsZSBwYWdlIG9yaWVudGF0aW9uXG5cblxuICBpZiAob3JpZW50YXRpb24gPT09ICdwJyB8fCBvcmllbnRhdGlvbiA9PT0gJ3BvcnRyYWl0Jykge1xuICAgIG9yaWVudGF0aW9uID0gJ3AnO1xuXG4gICAgaWYgKHBhZ2VXaWR0aCA+IHBhZ2VIZWlnaHQpIHtcbiAgICAgIHZhciB0bXAgPSBwYWdlV2lkdGg7XG4gICAgICBwYWdlV2lkdGggPSBwYWdlSGVpZ2h0O1xuICAgICAgcGFnZUhlaWdodCA9IHRtcDtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3JpZW50YXRpb24gPT09ICdsJyB8fCBvcmllbnRhdGlvbiA9PT0gJ2xhbmRzY2FwZScpIHtcbiAgICBvcmllbnRhdGlvbiA9ICdsJztcblxuICAgIGlmIChwYWdlSGVpZ2h0ID4gcGFnZVdpZHRoKSB7XG4gICAgICB2YXIgdG1wID0gcGFnZVdpZHRoO1xuICAgICAgcGFnZVdpZHRoID0gcGFnZUhlaWdodDtcbiAgICAgIHBhZ2VIZWlnaHQgPSB0bXA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93ICdJbnZhbGlkIG9yaWVudGF0aW9uOiAnICsgb3JpZW50YXRpb247XG4gIH0gLy8gUmV0dXJuIGluZm9ybWF0aW9uIChrIGlzIHRoZSB1bml0IGNvbnZlcnNpb24gcmF0aW8gZnJvbSBwdHMpXG5cblxuICB2YXIgaW5mbyA9IHtcbiAgICAnd2lkdGgnOiBwYWdlV2lkdGgsXG4gICAgJ2hlaWdodCc6IHBhZ2VIZWlnaHQsXG4gICAgJ3VuaXQnOiB1bml0LFxuICAgICdrJzoga1xuICB9O1xuICByZXR1cm4gaW5mbztcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoanNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXy5qc1BERik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3BsdWdpbi9wYWdlYnJlYWtzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3BsdWdpbi9wYWdlYnJlYWtzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9jb25jYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9jb25jYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfY29uY2F0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9zbGljZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNsaWNlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9zbGljZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9zbGljZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfam9pbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfam9pbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9qb2luX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9rZXlzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9rZXlzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9rZXlzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3dvcmtlci5qcyAqLyBcIi4vc3JjL3dvcmtlci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzLmpzICovIFwiLi9zcmMvdXRpbHMuanNcIik7XG5cblxuXG5cblxuXG5cbi8qIFBhZ2VicmVhayBwbHVnaW46XG5cbiAgICBBZGRzIHBhZ2UtYnJlYWsgZnVuY3Rpb25hbGl0eSB0byB0aGUgaHRtbDJwZGYgbGlicmFyeS4gUGFnZS1icmVha3MgY2FuIGJlXG4gICAgZW5hYmxlZCBieSBDU1Mgc3R5bGVzLCBzZXQgb24gaW5kaXZpZHVhbCBlbGVtZW50cyB1c2luZyBzZWxlY3RvcnMsIG9yXG4gICAgYXZvaWRlZCBmcm9tIGJyZWFraW5nIGluc2lkZSBhbGwgZWxlbWVudHMuXG5cbiAgICBPcHRpb25zIG9uIHRoZSBgb3B0LnBhZ2VicmVha2Agb2JqZWN0OlxuXG4gICAgbW9kZTogICBTdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5nczogJ2F2b2lkLWFsbCcsICdjc3MnLCBhbmQvb3IgJ2xlZ2FjeSdcbiAgICAgICAgICAgIERlZmF1bHQ6IFsnY3NzJywgJ2xlZ2FjeSddXG5cbiAgICBiZWZvcmU6IFN0cmluZyBvciBhcnJheSBvZiBDU1Mgc2VsZWN0b3JzIGZvciB3aGljaCB0byBhZGQgcGFnZS1icmVha3NcbiAgICAgICAgICAgIGJlZm9yZSBlYWNoIGVsZW1lbnQuIENhbiBiZSBhIHNwZWNpZmljIGVsZW1lbnQgd2l0aCBhbiBJRFxuICAgICAgICAgICAgKCcjbXlJRCcpLCBhbGwgZWxlbWVudHMgb2YgYSB0eXBlIChlLmcuICdpbWcnKSwgYWxsIG9mIGEgY2xhc3NcbiAgICAgICAgICAgICgnLm15Q2xhc3MnKSwgb3IgZXZlbiAnKicgdG8gbWF0Y2ggZXZlcnkgZWxlbWVudC5cblxuICAgIGFmdGVyOiAgTGlrZSAnYmVmb3JlJywgYnV0IGFkZHMgYSBwYWdlLWJyZWFrIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBlbGVtZW50LlxuXG4gICAgYXZvaWQ6ICBMaWtlICdiZWZvcmUnLCBidXQgYXZvaWRzIHBhZ2UtYnJlYWtzIG9uIHRoZXNlIGVsZW1lbnRzLiBZb3UgY2FuXG4gICAgICAgICAgICBlbmFibGUgdGhpcyBmZWF0dXJlIG9uIGV2ZXJ5IGVsZW1lbnQgdXNpbmcgdGhlICdhdm9pZC1hbGwnIG1vZGUuXG4qL1xuLy8gUmVmcyB0byBvcmlnaW5hbCBmdW5jdGlvbnMuXG5cbnZhciBvcmlnID0ge1xuICB0b0NvbnRhaW5lcjogX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fLmRlZmF1bHQucHJvdG90eXBlLnRvQ29udGFpbmVyXG59OyAvLyBBZGQgcGFnZWJyZWFrIGRlZmF1bHQgb3B0aW9ucyB0byB0aGUgV29ya2VyIHRlbXBsYXRlLlxuXG5fd29ya2VyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18uZGVmYXVsdC50ZW1wbGF0ZS5vcHQucGFnZWJyZWFrID0ge1xuICBtb2RlOiBbJ2NzcycsICdsZWdhY3knXSxcbiAgYmVmb3JlOiBbXSxcbiAgYWZ0ZXI6IFtdLFxuICBhdm9pZDogW11cbn07XG5cbl93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXy5kZWZhdWx0LnByb3RvdHlwZS50b0NvbnRhaW5lciA9IGZ1bmN0aW9uIHRvQ29udGFpbmVyKCkge1xuICByZXR1cm4gb3JpZy50b0NvbnRhaW5lci5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gdG9Db250YWluZXJfcGFnZWJyZWFrKCkge1xuICAgIC8vIFNldHVwIHJvb3QgZWxlbWVudCBhbmQgaW5uZXIgcGFnZSBoZWlnaHQuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnByb3AuY29udGFpbmVyO1xuICAgIHZhciBweFBhZ2VIZWlnaHQgPSB0aGlzLnByb3AucGFnZVNpemUuaW5uZXIucHguaGVpZ2h0OyAvLyBDaGVjayBhbGwgcmVxdWVzdGVkIG1vZGVzLlxuXG4gICAgdmFyIG1vZGVTcmMgPSBbXS5jb25jYXQodGhpcy5vcHQucGFnZWJyZWFrLm1vZGUpO1xuICAgIHZhciBtb2RlID0ge1xuICAgICAgYXZvaWRBbGw6IG1vZGVTcmMuaW5kZXhPZignYXZvaWQtYWxsJykgIT09IC0xLFxuICAgICAgY3NzOiBtb2RlU3JjLmluZGV4T2YoJ2NzcycpICE9PSAtMSxcbiAgICAgIGxlZ2FjeTogbW9kZVNyYy5pbmRleE9mKCdsZWdhY3knKSAhPT0gLTFcbiAgICB9OyAvLyBHZXQgYXJyYXlzIG9mIGFsbCBleHBsaWNpdGx5IHJlcXVlc3RlZCBlbGVtZW50cy5cblxuICAgIHZhciBzZWxlY3QgPSB7fTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgWydiZWZvcmUnLCAnYWZ0ZXInLCAnYXZvaWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBhbGwgPSBtb2RlLmF2b2lkQWxsICYmIGtleSA9PT0gJ2F2b2lkJztcbiAgICAgIHNlbGVjdFtrZXldID0gYWxsID8gW10gOiBbXS5jb25jYXQoc2VsZi5vcHQucGFnZWJyZWFrW2tleV0gfHwgW10pO1xuXG4gICAgICBpZiAoc2VsZWN0W2tleV0ubGVuZ3RoID4gMCkge1xuICAgICAgICBzZWxlY3Rba2V5XSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHJvb3QucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rba2V5XS5qb2luKCcsICcpKSk7XG4gICAgICB9XG4gICAgfSk7IC8vIEdldCBhbGwgbGVnYWN5IHBhZ2UtYnJlYWsgZWxlbWVudHMuXG5cbiAgICB2YXIgbGVnYWN5RWxzID0gcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCcuaHRtbDJwZGZfX3BhZ2UtYnJlYWsnKTtcbiAgICBsZWdhY3lFbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsZWdhY3lFbHMpOyAvLyBMb29wIHRocm91Z2ggYWxsIGVsZW1lbnRzLlxuXG4gICAgdmFyIGVscyA9IHJvb3QucXVlcnlTZWxlY3RvckFsbCgnKicpO1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWxzLCBmdW5jdGlvbiBwYWdlYnJlYWtfbG9vcChlbCkge1xuICAgICAgLy8gU2V0dXAgcGFnZWJyZWFrIHJ1bGVzIGJhc2VkIG9uIGxlZ2FjeSBhbmQgYXZvaWRBbGwgbW9kZXMuXG4gICAgICB2YXIgcnVsZXMgPSB7XG4gICAgICAgIGJlZm9yZTogZmFsc2UsXG4gICAgICAgIGFmdGVyOiBtb2RlLmxlZ2FjeSAmJiBsZWdhY3lFbHMuaW5kZXhPZihlbCkgIT09IC0xLFxuICAgICAgICBhdm9pZDogbW9kZS5hdm9pZEFsbFxuICAgICAgfTsgLy8gQWRkIHJ1bGVzIGZvciBjc3MgbW9kZS5cblxuICAgICAgaWYgKG1vZGUuY3NzKSB7XG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgaXMgdmFsaWQgd2l0aCBpRnJhbWVzLlxuICAgICAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7IC8vIFRPRE86IEhhbmRsZSAnbGVmdCcgYW5kICdyaWdodCcgY29ycmVjdGx5LlxuICAgICAgICAvLyBUT0RPOiBBZGQgc3VwcG9ydCBmb3IgJ2F2b2lkJyBvbiBicmVha0JlZm9yZS9BZnRlci5cblxuICAgICAgICB2YXIgYnJlYWtPcHQgPSBbJ2Fsd2F5cycsICdwYWdlJywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgICAgICAgdmFyIGF2b2lkT3B0ID0gWydhdm9pZCcsICdhdm9pZC1wYWdlJ107XG4gICAgICAgIHJ1bGVzID0ge1xuICAgICAgICAgIGJlZm9yZTogcnVsZXMuYmVmb3JlIHx8IGJyZWFrT3B0LmluZGV4T2Yoc3R5bGUuYnJlYWtCZWZvcmUgfHwgc3R5bGUucGFnZUJyZWFrQmVmb3JlKSAhPT0gLTEsXG4gICAgICAgICAgYWZ0ZXI6IHJ1bGVzLmFmdGVyIHx8IGJyZWFrT3B0LmluZGV4T2Yoc3R5bGUuYnJlYWtBZnRlciB8fCBzdHlsZS5wYWdlQnJlYWtBZnRlcikgIT09IC0xLFxuICAgICAgICAgIGF2b2lkOiBydWxlcy5hdm9pZCB8fCBhdm9pZE9wdC5pbmRleE9mKHN0eWxlLmJyZWFrSW5zaWRlIHx8IHN0eWxlLnBhZ2VCcmVha0luc2lkZSkgIT09IC0xXG4gICAgICAgIH07XG4gICAgICB9IC8vIEFkZCBydWxlcyBmb3IgZXhwbGljaXQgcmVxdWVzdHMuXG5cblxuICAgICAgT2JqZWN0LmtleXMocnVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBydWxlc1trZXldID0gcnVsZXNba2V5XSB8fCBzZWxlY3Rba2V5XS5pbmRleE9mKGVsKSAhPT0gLTE7XG4gICAgICB9KTsgLy8gR2V0IGVsZW1lbnQgcG9zaXRpb24gb24gdGhlIHNjcmVlbi5cbiAgICAgIC8vIFRPRE86IFN1YnRyYWN0IHRoZSB0b3Agb2YgdGhlIGNvbnRhaW5lciBmcm9tIGNsaWVudFJlY3QudG9wL2JvdHRvbT9cblxuICAgICAgdmFyIGNsaWVudFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gQXZvaWQ6IENoZWNrIGlmIGEgYnJlYWsgaGFwcGVucyBtaWQtZWxlbWVudC5cblxuICAgICAgaWYgKHJ1bGVzLmF2b2lkICYmICFydWxlcy5iZWZvcmUpIHtcbiAgICAgICAgdmFyIHN0YXJ0UGFnZSA9IE1hdGguZmxvb3IoY2xpZW50UmVjdC50b3AgLyBweFBhZ2VIZWlnaHQpO1xuICAgICAgICB2YXIgZW5kUGFnZSA9IE1hdGguZmxvb3IoY2xpZW50UmVjdC5ib3R0b20gLyBweFBhZ2VIZWlnaHQpO1xuICAgICAgICB2YXIgblBhZ2VzID0gTWF0aC5hYnMoY2xpZW50UmVjdC5ib3R0b20gLSBjbGllbnRSZWN0LnRvcCkgLyBweFBhZ2VIZWlnaHQ7IC8vIFR1cm4gb24gcnVsZXMuYmVmb3JlIGlmIHRoZSBlbCBpcyBicm9rZW4gYW5kIGlzIGF0IG1vc3Qgb25lIHBhZ2UgbG9uZy5cblxuICAgICAgICBpZiAoZW5kUGFnZSAhPT0gc3RhcnRQYWdlICYmIG5QYWdlcyA8PSAxKSB7XG4gICAgICAgICAgcnVsZXMuYmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBCZWZvcmU6IENyZWF0ZSBhIHBhZGRpbmcgZGl2IHRvIHB1c2ggdGhlIGVsZW1lbnQgdG8gdGhlIG5leHQgcGFnZS5cblxuXG4gICAgICBpZiAocnVsZXMuYmVmb3JlKSB7XG4gICAgICAgIHZhciBwYWQgPSAoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy5jcmVhdGVFbGVtZW50KSgnZGl2Jywge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgaGVpZ2h0OiBweFBhZ2VIZWlnaHQgLSBjbGllbnRSZWN0LnRvcCAlIHB4UGFnZUhlaWdodCArICdweCdcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShwYWQsIGVsKTtcbiAgICAgIH0gLy8gQWZ0ZXI6IENyZWF0ZSBhIHBhZGRpbmcgZGl2IHRvIGZpbGwgdGhlIHJlbWFpbmluZyBwYWdlLlxuXG5cbiAgICAgIGlmIChydWxlcy5hZnRlcikge1xuICAgICAgICB2YXIgcGFkID0gKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18uY3JlYXRlRWxlbWVudCkoJ2RpdicsIHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgIGhlaWdodDogcHhQYWdlSGVpZ2h0IC0gY2xpZW50UmVjdC5ib3R0b20gJSBweFBhZ2VIZWlnaHQgKyAncHgnXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocGFkLCBlbC5uZXh0U2libGluZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdXRpbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuLyogaGFybW9ueSBleHBvcnQgKi8gICBcIm9ialR5cGVcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIG9ialR5cGU7IH0sXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiY3JlYXRlRWxlbWVudFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gY3JlYXRlRWxlbWVudDsgfSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJjbG9uZU5vZGVcIjogZnVuY3Rpb24oKSB7IHJldHVybiAvKiBiaW5kaW5nICovIGNsb25lTm9kZTsgfSxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJ1bml0Q29udmVydFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gdW5pdENvbnZlcnQ7IH0sXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwidG9QeFwiOiBmdW5jdGlvbigpIHsgcmV0dXJuIC8qIGJpbmRpbmcgKi8gdG9QeDsgfVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX251bWJlcl9jb25zdHJ1Y3Rvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5jb25zdHJ1Y3Rvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX251bWJlcl9jb25zdHJ1Y3Rvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19udW1iZXJfY29uc3RydWN0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9kZXNjcmlwdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24uanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9kZXNjcmlwdGlvbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfZGVzY3JpcHRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fKTtcblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLy8gRGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGEgdmFyaWFibGUvb2JqZWN0LlxudmFyIG9ialR5cGUgPSBmdW5jdGlvbiBvYmpUeXBlKG9iaikge1xuICB2YXIgdHlwZSA9IF90eXBlb2Yob2JqKTtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiAndW5kZWZpbmVkJztlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCBvYmogaW5zdGFuY2VvZiBTdHJpbmcpIHJldHVybiAnc3RyaW5nJztlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBOdW1iZXIpIHJldHVybiAnbnVtYmVyJztlbHNlIGlmICh0eXBlID09PSAnZnVuY3Rpb24nIHx8IG9iaiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSByZXR1cm4gJ2Z1bmN0aW9uJztlbHNlIGlmICghIW9iaiAmJiBvYmouY29uc3RydWN0b3IgPT09IEFycmF5KSByZXR1cm4gJ2FycmF5JztlbHNlIGlmIChvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKSByZXR1cm4gJ2VsZW1lbnQnO2Vsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSByZXR1cm4gJ29iamVjdCc7ZWxzZSByZXR1cm4gJ3Vua25vd24nO1xufTsgLy8gQ3JlYXRlIGFuIEhUTUwgZWxlbWVudCB3aXRoIG9wdGlvbmFsIGNsYXNzTmFtZSwgaW5uZXJIVE1MLCBhbmQgc3R5bGUuXG5cbnZhciBjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBvcHQpIHtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKG9wdC5jbGFzc05hbWUpIGVsLmNsYXNzTmFtZSA9IG9wdC5jbGFzc05hbWU7XG5cbiAgaWYgKG9wdC5pbm5lckhUTUwpIHtcbiAgICBlbC5pbm5lckhUTUwgPSBvcHQuaW5uZXJIVE1MO1xuICAgIHZhciBzY3JpcHRzID0gZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuXG4gICAgZm9yICh2YXIgaSA9IHNjcmlwdHMubGVuZ3RoOyBpLS0gPiAwOyBudWxsKSB7XG4gICAgICBzY3JpcHRzW2ldLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIG9wdC5zdHlsZSkge1xuICAgIGVsLnN0eWxlW2tleV0gPSBvcHQuc3R5bGVba2V5XTtcbiAgfVxuXG4gIHJldHVybiBlbDtcbn07IC8vIERlZXAtY2xvbmUgYSBub2RlIGFuZCBwcmVzZXJ2ZSBjb250ZW50cy9wcm9wZXJ0aWVzLlxuXG52YXIgY2xvbmVOb2RlID0gZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUsIGphdmFzY3JpcHRFbmFibGVkKSB7XG4gIC8vIFJlY3Vyc2l2ZWx5IGNsb25lIHRoZSBub2RlLlxuICB2YXIgY2xvbmUgPSBub2RlLm5vZGVUeXBlID09PSAzID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobm9kZS5ub2RlVmFsdWUpIDogbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuXG4gIGZvciAodmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgIGlmIChqYXZhc2NyaXB0RW5hYmxlZCA9PT0gdHJ1ZSB8fCBjaGlsZC5ub2RlVHlwZSAhPT0gMSB8fCBjaGlsZC5ub2RlTmFtZSAhPT0gJ1NDUklQVCcpIHtcbiAgICAgIGNsb25lLmFwcGVuZENoaWxkKGNsb25lTm9kZShjaGlsZCwgamF2YXNjcmlwdEVuYWJsZWQpKTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgIC8vIFByZXNlcnZlIGNvbnRlbnRzL3Byb3BlcnRpZXMgb2Ygc3BlY2lhbCBub2Rlcy5cbiAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ0NBTlZBUycpIHtcbiAgICAgIGNsb25lLndpZHRoID0gbm9kZS53aWR0aDtcbiAgICAgIGNsb25lLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgY2xvbmUuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2Uobm9kZSwgMCwgMCk7XG4gICAgfSBlbHNlIGlmIChub2RlLm5vZGVOYW1lID09PSAnVEVYVEFSRUEnIHx8IG5vZGUubm9kZU5hbWUgPT09ICdTRUxFQ1QnKSB7XG4gICAgICBjbG9uZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgfSAvLyBQcmVzZXJ2ZSB0aGUgbm9kZSdzIHNjcm9sbCBwb3NpdGlvbiB3aGVuIGl0IGxvYWRzLlxuXG5cbiAgICBjbG9uZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgY2xvbmUuc2Nyb2xsVG9wID0gbm9kZS5zY3JvbGxUb3A7XG4gICAgICBjbG9uZS5zY3JvbGxMZWZ0ID0gbm9kZS5zY3JvbGxMZWZ0O1xuICAgIH0sIHRydWUpO1xuICB9IC8vIFJldHVybiB0aGUgY2xvbmVkIG5vZGUuXG5cblxuICByZXR1cm4gY2xvbmU7XG59OyAvLyBDb252ZXJ0IHVuaXRzIGZyb20gcHggdXNpbmcgdGhlIGNvbnZlcnNpb24gdmFsdWUgJ2snIGZyb20ganNQREYuXG5cbnZhciB1bml0Q29udmVydCA9IGZ1bmN0aW9uIHVuaXRDb252ZXJ0KG9iaiwgaykge1xuICBpZiAob2JqVHlwZShvYmopID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBvYmogKiA3MiAvIDk2IC8gaztcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV3T2JqID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldICogNzIgLyA5NiAvIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld09iajtcbiAgfVxufTsgLy8gQ29udmVydCB1bml0cyB0byBweCB1c2luZyB0aGUgY29udmVyc2lvbiB2YWx1ZSAnaycgZnJvbSBqc1BERi5cblxudmFyIHRvUHggPSBmdW5jdGlvbiB0b1B4KHZhbCwgaykge1xuICByZXR1cm4gTWF0aC5mbG9vcih2YWwgKiBrIC8gNzIgKiA5Nik7XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy93b3JrZXIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3dvcmtlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9hc3NpZ25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuYXNzaWduLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9hc3NpZ25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2Fzc2lnbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfbWFwX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfbWFwX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X21hcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2tleXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3Qua2V5cy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2tleXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2tleXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2NvbmNhdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5jb25jYXQuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2NvbmNhdF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19hcnJheV9jb25jYXRfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfcmVnZXhwX3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC50by1zdHJpbmcuanMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXNfcmVnZXhwX3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lc19yZWdleHBfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19mdW5jdGlvbl9uYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lc19mdW5jdGlvbl9uYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzX2Z1bmN0aW9uX25hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2guanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19mb3JfZWFjaF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganNwZGYgKi8gXCJqc3BkZlwiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpzcGRmX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGh0bWwyY2FudmFzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBodG1sMmNhbnZhcyAqLyBcImh0bWwyY2FudmFzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGh0bWwyY2FudmFzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oaHRtbDJjYW52YXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy5qcyAqLyBcIi4vc3JjL3V0aWxzLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGVzNl9wcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZXM2LXByb21pc2UgKi8gXCIuL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGVzNl9wcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGVzNl9wcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBQcm9taXNlID0gKGVzNl9wcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fX2RlZmF1bHQoKS5Qcm9taXNlKTtcbi8qIC0tLS0tIENPTlNUUlVDVE9SIC0tLS0tICovXG5cbnZhciBXb3JrZXIgPSBmdW5jdGlvbiBXb3JrZXIob3B0KSB7XG4gIC8vIENyZWF0ZSB0aGUgcm9vdCBwYXJlbnQgZm9yIHRoZSBwcm90byBjaGFpbiwgYW5kIHRoZSBzdGFydGluZyBXb3JrZXIuXG4gIHZhciByb290ID0gT2JqZWN0LmFzc2lnbihXb3JrZXIuY29udmVydChQcm9taXNlLnJlc29sdmUoKSksIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoV29ya2VyLnRlbXBsYXRlKSkpO1xuICB2YXIgc2VsZiA9IFdvcmtlci5jb252ZXJ0KFByb21pc2UucmVzb2x2ZSgpLCByb290KTsgLy8gU2V0IHByb2dyZXNzLCBvcHRpb25hbCBzZXR0aW5ncywgYW5kIHJldHVybi5cblxuICBzZWxmID0gc2VsZi5zZXRQcm9ncmVzcygxLCBXb3JrZXIsIDEsIFtXb3JrZXJdKTtcbiAgc2VsZiA9IHNlbGYuc2V0KG9wdCk7XG4gIHJldHVybiBzZWxmO1xufTsgLy8gQm9pbGVycGxhdGUgZm9yIHN1YmNsYXNzaW5nIFByb21pc2UuXG5cblxuV29ya2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUHJvbWlzZS5wcm90b3R5cGUpO1xuV29ya2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdvcmtlcjsgLy8gQ29udmVydHMvY2FzdHMgcHJvbWlzZXMgaW50byBXb3JrZXJzLlxuXG5Xb3JrZXIuY29udmVydCA9IGZ1bmN0aW9uIGNvbnZlcnQocHJvbWlzZSwgaW5oZXJpdCkge1xuICAvLyBVc2VzIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgdG8gcmVjZWl2ZSBjaGFuZ2VzIG1hZGUgdG8gYW5jZXN0b3JzJyBwcm9wZXJ0aWVzLlxuICBwcm9taXNlLl9fcHJvdG9fXyA9IGluaGVyaXQgfHwgV29ya2VyLnByb3RvdHlwZTtcbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5Xb3JrZXIudGVtcGxhdGUgPSB7XG4gIHByb3A6IHtcbiAgICBzcmM6IG51bGwsXG4gICAgY29udGFpbmVyOiBudWxsLFxuICAgIG92ZXJsYXk6IG51bGwsXG4gICAgY2FudmFzOiBudWxsLFxuICAgIGltZzogbnVsbCxcbiAgICBwZGY6IG51bGwsXG4gICAgcGFnZVNpemU6IG51bGxcbiAgfSxcbiAgcHJvZ3Jlc3M6IHtcbiAgICB2YWw6IDAsXG4gICAgc3RhdGU6IG51bGwsXG4gICAgbjogMCxcbiAgICBzdGFjazogW11cbiAgfSxcbiAgb3B0OiB7XG4gICAgZmlsZW5hbWU6ICdmaWxlLnBkZicsXG4gICAgbWFyZ2luOiBbMCwgMCwgMCwgMF0sXG4gICAgaW1hZ2U6IHtcbiAgICAgIHR5cGU6ICdqcGVnJyxcbiAgICAgIHF1YWxpdHk6IDAuOTVcbiAgICB9LFxuICAgIGVuYWJsZUxpbmtzOiB0cnVlLFxuICAgIGh0bWwyY2FudmFzOiB7fSxcbiAgICBqc1BERjoge31cbiAgfVxufTtcbi8qIC0tLS0tIEZST00gLyBUTyAtLS0tLSAqL1xuXG5Xb3JrZXIucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiBmcm9tKHNyYywgdHlwZSkge1xuICBmdW5jdGlvbiBnZXRUeXBlKHNyYykge1xuICAgIHN3aXRjaCAoKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLm9ialR5cGUpKHNyYykpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiAnc3RyaW5nJztcblxuICAgICAgY2FzZSAnZWxlbWVudCc6XG4gICAgICAgIHJldHVybiBzcmMubm9kZU5hbWUudG9Mb3dlckNhc2UgJiYgc3JjLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnID8gJ2NhbnZhcycgOiAnZWxlbWVudCc7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiBmcm9tX21haW4oKSB7XG4gICAgdHlwZSA9IHR5cGUgfHwgZ2V0VHlwZShzcmMpO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gdGhpcy5zZXQoe1xuICAgICAgICAgIHNyYzogKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLmNyZWF0ZUVsZW1lbnQpKCdkaXYnLCB7XG4gICAgICAgICAgICBpbm5lckhUTUw6IHNyY1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuXG4gICAgICBjYXNlICdlbGVtZW50JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgICAgICBzcmM6IHNyY1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnY2FudmFzJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgICAgICBjYW52YXM6IHNyY1xuICAgICAgICB9KTtcblxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KHtcbiAgICAgICAgICBpbWc6IHNyY1xuICAgICAgICB9KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ1Vua25vd24gc291cmNlIHR5cGUuJyk7XG4gICAgfVxuICB9KTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiB0byh0YXJnZXQpIHtcbiAgLy8gUm91dGUgdGhlICd0bycgcmVxdWVzdCB0byB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kLlxuICBzd2l0Y2ggKHRhcmdldCkge1xuICAgIGNhc2UgJ2NvbnRhaW5lcic6XG4gICAgICByZXR1cm4gdGhpcy50b0NvbnRhaW5lcigpO1xuXG4gICAgY2FzZSAnY2FudmFzJzpcbiAgICAgIHJldHVybiB0aGlzLnRvQ2FudmFzKCk7XG5cbiAgICBjYXNlICdpbWcnOlxuICAgICAgcmV0dXJuIHRoaXMudG9JbWcoKTtcblxuICAgIGNhc2UgJ3BkZic6XG4gICAgICByZXR1cm4gdGhpcy50b1BkZigpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0aGlzLmVycm9yKCdJbnZhbGlkIHRhcmdldC4nKTtcbiAgfVxufTtcblxuV29ya2VyLnByb3RvdHlwZS50b0NvbnRhaW5lciA9IGZ1bmN0aW9uIHRvQ29udGFpbmVyKCkge1xuICAvLyBTZXQgdXAgZnVuY3Rpb24gcHJlcmVxdWlzaXRlcy5cbiAgdmFyIHByZXJlcXMgPSBbZnVuY3Rpb24gY2hlY2tTcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcC5zcmMgfHwgdGhpcy5lcnJvcignQ2Fubm90IGR1cGxpY2F0ZSAtIG5vIHNvdXJjZSBIVE1MLicpO1xuICB9LCBmdW5jdGlvbiBjaGVja1BhZ2VTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnByb3AucGFnZVNpemUgfHwgdGhpcy5zZXRQYWdlU2l6ZSgpO1xuICB9XTtcbiAgcmV0dXJuIHRoaXMudGhlbkxpc3QocHJlcmVxcykudGhlbihmdW5jdGlvbiB0b0NvbnRhaW5lcl9tYWluKCkge1xuICAgIC8vIERlZmluZSB0aGUgQ1NTIHN0eWxlcyBmb3IgdGhlIGNvbnRhaW5lciBhbmQgaXRzIG92ZXJsYXkgcGFyZW50LlxuICAgIHZhciBvdmVybGF5Q1NTID0ge1xuICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICB6SW5kZXg6IDEwMDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICBib3R0b206IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknXG4gICAgfTtcbiAgICB2YXIgY29udGFpbmVyQ1NTID0ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB3aWR0aDogdGhpcy5wcm9wLnBhZ2VTaXplLmlubmVyLndpZHRoICsgdGhpcy5wcm9wLnBhZ2VTaXplLnVuaXQsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBoZWlnaHQ6ICdhdXRvJyxcbiAgICAgIG1hcmdpbjogJ2F1dG8nLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnXG4gICAgfTsgLy8gU2V0IHRoZSBvdmVybGF5IHRvIGhpZGRlbiAoY291bGQgYmUgY2hhbmdlZCBpbiB0aGUgZnV0dXJlIHRvIHByb3ZpZGUgYSBwcmludCBwcmV2aWV3KS5cblxuICAgIG92ZXJsYXlDU1Mub3BhY2l0eSA9IDA7IC8vIENyZWF0ZSBhbmQgYXR0YWNoIHRoZSBlbGVtZW50cy5cblxuICAgIHZhciBzb3VyY2UgPSAoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18uY2xvbmVOb2RlKSh0aGlzLnByb3Auc3JjLCB0aGlzLm9wdC5odG1sMmNhbnZhcy5qYXZhc2NyaXB0RW5hYmxlZCk7XG4gICAgdGhpcy5wcm9wLm92ZXJsYXkgPSAoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18uY3JlYXRlRWxlbWVudCkoJ2RpdicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2h0bWwycGRmX19vdmVybGF5JyxcbiAgICAgIHN0eWxlOiBvdmVybGF5Q1NTXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wLmNvbnRhaW5lciA9ICgwLF91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXy5jcmVhdGVFbGVtZW50KSgnZGl2Jywge1xuICAgICAgY2xhc3NOYW1lOiAnaHRtbDJwZGZfX2NvbnRhaW5lcicsXG4gICAgICBzdHlsZTogY29udGFpbmVyQ1NTXG4gICAgfSk7XG4gICAgdGhpcy5wcm9wLmNvbnRhaW5lci5hcHBlbmRDaGlsZChzb3VyY2UpO1xuICAgIHRoaXMucHJvcC5vdmVybGF5LmFwcGVuZENoaWxkKHRoaXMucHJvcC5jb250YWluZXIpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wcm9wLm92ZXJsYXkpO1xuICB9KTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUudG9DYW52YXMgPSBmdW5jdGlvbiB0b0NhbnZhcygpIHtcbiAgLy8gU2V0IHVwIGZ1bmN0aW9uIHByZXJlcXVpc2l0ZXMuXG4gIHZhciBwcmVyZXFzID0gW2Z1bmN0aW9uIGNoZWNrQ29udGFpbmVyKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMucHJvcC5jb250YWluZXIpIHx8IHRoaXMudG9Db250YWluZXIoKTtcbiAgfV07IC8vIEZ1bGZpbGwgcHJlcmVxcyB0aGVuIGNyZWF0ZSB0aGUgY2FudmFzLlxuXG4gIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnRoZW4oZnVuY3Rpb24gdG9DYW52YXNfbWFpbigpIHtcbiAgICAvLyBIYW5kbGUgb2xkLWZhc2hpb25lZCAnb25yZW5kZXJlZCcgYXJndW1lbnQuXG4gICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdC5odG1sMmNhbnZhcyk7XG4gICAgZGVsZXRlIG9wdGlvbnMub25yZW5kZXJlZDtcbiAgICByZXR1cm4gaHRtbDJjYW52YXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyh0aGlzLnByb3AuY29udGFpbmVyLCBvcHRpb25zKTtcbiAgfSkudGhlbihmdW5jdGlvbiB0b0NhbnZhc19wb3N0KGNhbnZhcykge1xuICAgIC8vIEhhbmRsZSBvbGQtZmFzaGlvbmVkICdvbnJlbmRlcmVkJyBhcmd1bWVudC5cbiAgICB2YXIgb25SZW5kZXJlZCA9IHRoaXMub3B0Lmh0bWwyY2FudmFzLm9ucmVuZGVyZWQgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICBvblJlbmRlcmVkKGNhbnZhcyk7XG4gICAgdGhpcy5wcm9wLmNhbnZhcyA9IGNhbnZhcztcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMucHJvcC5vdmVybGF5KTtcbiAgfSk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLnRvSW1nID0gZnVuY3Rpb24gdG9JbWcoKSB7XG4gIC8vIFNldCB1cCBmdW5jdGlvbiBwcmVyZXF1aXNpdGVzLlxuICB2YXIgcHJlcmVxcyA9IFtmdW5jdGlvbiBjaGVja0NhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wLmNhbnZhcyB8fCB0aGlzLnRvQ2FudmFzKCk7XG4gIH1dOyAvLyBGdWxmaWxsIHByZXJlcXMgdGhlbiBjcmVhdGUgdGhlIGltYWdlLlxuXG4gIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnRoZW4oZnVuY3Rpb24gdG9JbWdfbWFpbigpIHtcbiAgICB2YXIgaW1nRGF0YSA9IHRoaXMucHJvcC5jYW52YXMudG9EYXRhVVJMKCdpbWFnZS8nICsgdGhpcy5vcHQuaW1hZ2UudHlwZSwgdGhpcy5vcHQuaW1hZ2UucXVhbGl0eSk7XG4gICAgdGhpcy5wcm9wLmltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIHRoaXMucHJvcC5pbWcuc3JjID0gaW1nRGF0YTtcbiAgfSk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLnRvUGRmID0gZnVuY3Rpb24gdG9QZGYoKSB7XG4gIC8vIFNldCB1cCBmdW5jdGlvbiBwcmVyZXF1aXNpdGVzLlxuICB2YXIgcHJlcmVxcyA9IFtmdW5jdGlvbiBjaGVja0NhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wLmNhbnZhcyB8fCB0aGlzLnRvQ2FudmFzKCk7XG4gIH0sIGZ1bmN0aW9uIGNoZWNrUGFnZVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcC5wYWdlU2l6ZSB8fCB0aGlzLnNldFBhZ2VTaXplKCk7XG4gIH1dOyAvLyBGdWxmaWxsIHByZXJlcXMgdGhlbiBjcmVhdGUgdGhlIGltYWdlLlxuXG4gIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnRoZW4oZnVuY3Rpb24gdG9QZGZfbWFpbigpIHtcbiAgICAvLyBDcmVhdGUgbG9jYWwgY29waWVzIG9mIGZyZXF1ZW50bHkgdXNlZCBwcm9wZXJ0aWVzLlxuICAgIHZhciBjYW52YXMgPSB0aGlzLnByb3AuY2FudmFzO1xuICAgIHZhciBvcHQgPSB0aGlzLm9wdDsgLy8gQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgcGFnZXMuXG5cbiAgICB2YXIgcHhGdWxsSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICB2YXIgcHhQYWdlSGVpZ2h0ID0gTWF0aC5mbG9vcihjYW52YXMud2lkdGggKiB0aGlzLnByb3AucGFnZVNpemUuaW5uZXIucmF0aW8pO1xuICAgIHZhciBuUGFnZXMgPSBNYXRoLmNlaWwocHhGdWxsSGVpZ2h0IC8gcHhQYWdlSGVpZ2h0KTsgLy8gRGVmaW5lIHBhZ2VIZWlnaHQgc2VwYXJhdGVseSBzbyBpdCBjYW4gYmUgdHJpbW1lZCBvbiB0aGUgZmluYWwgcGFnZS5cblxuICAgIHZhciBwYWdlSGVpZ2h0ID0gdGhpcy5wcm9wLnBhZ2VTaXplLmlubmVyLmhlaWdodDsgLy8gQ3JlYXRlIGEgb25lLXBhZ2UgY2FudmFzIHRvIHNwbGl0IHVwIHRoZSBmdWxsIGltYWdlLlxuXG4gICAgdmFyIHBhZ2VDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgcGFnZUN0eCA9IHBhZ2VDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBwYWdlQ2FudmFzLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIHBhZ2VDYW52YXMuaGVpZ2h0ID0gcHhQYWdlSGVpZ2h0OyAvLyBJbml0aWFsaXplIHRoZSBQREYuXG5cbiAgICB0aGlzLnByb3AucGRmID0gdGhpcy5wcm9wLnBkZiB8fCBuZXcganNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXy5qc1BERihvcHQuanNQREYpO1xuXG4gICAgZm9yICh2YXIgcGFnZSA9IDA7IHBhZ2UgPCBuUGFnZXM7IHBhZ2UrKykge1xuICAgICAgLy8gVHJpbSB0aGUgZmluYWwgcGFnZSB0byByZWR1Y2UgZmlsZSBzaXplLlxuICAgICAgaWYgKHBhZ2UgPT09IG5QYWdlcyAtIDEgJiYgcHhGdWxsSGVpZ2h0ICUgcHhQYWdlSGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgIHBhZ2VDYW52YXMuaGVpZ2h0ID0gcHhGdWxsSGVpZ2h0ICUgcHhQYWdlSGVpZ2h0O1xuICAgICAgICBwYWdlSGVpZ2h0ID0gcGFnZUNhbnZhcy5oZWlnaHQgKiB0aGlzLnByb3AucGFnZVNpemUuaW5uZXIud2lkdGggLyBwYWdlQ2FudmFzLndpZHRoO1xuICAgICAgfSAvLyBEaXNwbGF5IHRoZSBwYWdlLlxuXG5cbiAgICAgIHZhciB3ID0gcGFnZUNhbnZhcy53aWR0aDtcbiAgICAgIHZhciBoID0gcGFnZUNhbnZhcy5oZWlnaHQ7XG4gICAgICBwYWdlQ3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBwYWdlQ3R4LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgcGFnZUN0eC5kcmF3SW1hZ2UoY2FudmFzLCAwLCBwYWdlICogcHhQYWdlSGVpZ2h0LCB3LCBoLCAwLCAwLCB3LCBoKTsgLy8gQWRkIHRoZSBwYWdlIHRvIHRoZSBQREYuXG5cbiAgICAgIGlmIChwYWdlKSB0aGlzLnByb3AucGRmLmFkZFBhZ2UoKTtcbiAgICAgIHZhciBpbWdEYXRhID0gcGFnZUNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlLycgKyBvcHQuaW1hZ2UudHlwZSwgb3B0LmltYWdlLnF1YWxpdHkpO1xuICAgICAgdGhpcy5wcm9wLnBkZi5hZGRJbWFnZShpbWdEYXRhLCBvcHQuaW1hZ2UudHlwZSwgb3B0Lm1hcmdpblsxXSwgb3B0Lm1hcmdpblswXSwgdGhpcy5wcm9wLnBhZ2VTaXplLmlubmVyLndpZHRoLCBwYWdlSGVpZ2h0KTtcbiAgICB9XG4gIH0pO1xufTtcbi8qIC0tLS0tIE9VVFBVVCAvIFNBVkUgLS0tLS0gKi9cblxuXG5Xb3JrZXIucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uIG91dHB1dCh0eXBlLCBvcHRpb25zLCBzcmMpIHtcbiAgLy8gUmVkaXJlY3QgcmVxdWVzdHMgdG8gdGhlIGNvcnJlY3QgZnVuY3Rpb24gKG91dHB1dFBkZiAvIG91dHB1dEltZykuXG4gIHNyYyA9IHNyYyB8fCAncGRmJztcblxuICBpZiAoc3JjLnRvTG93ZXJDYXNlKCkgPT09ICdpbWcnIHx8IHNyYy50b0xvd2VyQ2FzZSgpID09PSAnaW1hZ2UnKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0SW1nKHR5cGUsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLm91dHB1dFBkZih0eXBlLCBvcHRpb25zKTtcbiAgfVxufTtcblxuV29ya2VyLnByb3RvdHlwZS5vdXRwdXRQZGYgPSBmdW5jdGlvbiBvdXRwdXRQZGYodHlwZSwgb3B0aW9ucykge1xuICAvLyBTZXQgdXAgZnVuY3Rpb24gcHJlcmVxdWlzaXRlcy5cbiAgdmFyIHByZXJlcXMgPSBbZnVuY3Rpb24gY2hlY2tQZGYoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcC5wZGYgfHwgdGhpcy50b1BkZigpO1xuICB9XTsgLy8gRnVsZmlsbCBwcmVyZXFzIHRoZW4gcGVyZm9ybSB0aGUgYXBwcm9wcmlhdGUgb3V0cHV0LlxuXG4gIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnRoZW4oZnVuY3Rpb24gb3V0cHV0UGRmX21haW4oKSB7XG4gICAgLyogQ3VycmVudGx5IGltcGxlbWVudGVkIG91dHB1dCB0eXBlczpcbiAgICAgKiAgICBodHRwczovL3Jhd2dpdC5jb20vTXJSaW8vanNQREYvbWFzdGVyL2RvY3MvanNwZGYuanMuaHRtbCNsaW5lOTkyXG4gICAgICogIHNhdmUob3B0aW9ucyksIGFycmF5YnVmZmVyLCBibG9iLCBibG9idXJpL2Jsb2J1cmwsXG4gICAgICogIGRhdGF1cmlzdHJpbmcvZGF0YXVybHN0cmluZywgZGF0YXVybG5ld3dpbmRvdywgZGF0YXVyaS9kYXRhdXJsXG4gICAgICovXG4gICAgcmV0dXJuIHRoaXMucHJvcC5wZGYub3V0cHV0KHR5cGUsIG9wdGlvbnMpO1xuICB9KTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUub3V0cHV0SW1nID0gZnVuY3Rpb24gb3V0cHV0SW1nKHR5cGUsIG9wdGlvbnMpIHtcbiAgLy8gU2V0IHVwIGZ1bmN0aW9uIHByZXJlcXVpc2l0ZXMuXG4gIHZhciBwcmVyZXFzID0gW2Z1bmN0aW9uIGNoZWNrSW1nKCkge1xuICAgIHJldHVybiB0aGlzLnByb3AuaW1nIHx8IHRoaXMudG9JbWcoKTtcbiAgfV07IC8vIEZ1bGZpbGwgcHJlcmVxcyB0aGVuIHBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIG91dHB1dC5cblxuICByZXR1cm4gdGhpcy50aGVuTGlzdChwcmVyZXFzKS50aGVuKGZ1bmN0aW9uIG91dHB1dEltZ19tYWluKCkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wLmltZztcblxuICAgICAgY2FzZSAnZGF0YXVyaXN0cmluZyc6XG4gICAgICBjYXNlICdkYXRhdXJsc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcC5pbWcuc3JjO1xuXG4gICAgICBjYXNlICdkYXRhdXJpJzpcbiAgICAgIGNhc2UgJ2RhdGF1cmwnOlxuICAgICAgICByZXR1cm4gZG9jdW1lbnQubG9jYXRpb24uaHJlZiA9IHRoaXMucHJvcC5pbWcuc3JjO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyAnSW1hZ2Ugb3V0cHV0IHR5cGUgXCInICsgdHlwZSArICdcIiBpcyBub3Qgc3VwcG9ydGVkLic7XG4gICAgfVxuICB9KTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIHNhdmUoZmlsZW5hbWUpIHtcbiAgLy8gU2V0IHVwIGZ1bmN0aW9uIHByZXJlcXVpc2l0ZXMuXG4gIHZhciBwcmVyZXFzID0gW2Z1bmN0aW9uIGNoZWNrUGRmKCkge1xuICAgIHJldHVybiB0aGlzLnByb3AucGRmIHx8IHRoaXMudG9QZGYoKTtcbiAgfV07IC8vIEZ1bGZpbGwgcHJlcmVxcywgdXBkYXRlIHRoZSBmaWxlbmFtZSAoaWYgcHJvdmlkZWQpLCBhbmQgc2F2ZSB0aGUgUERGLlxuXG4gIHJldHVybiB0aGlzLnRoZW5MaXN0KHByZXJlcXMpLnNldChmaWxlbmFtZSA/IHtcbiAgICBmaWxlbmFtZTogZmlsZW5hbWVcbiAgfSA6IG51bGwpLnRoZW4oZnVuY3Rpb24gc2F2ZV9tYWluKCkge1xuICAgIHRoaXMucHJvcC5wZGYuc2F2ZSh0aGlzLm9wdC5maWxlbmFtZSk7XG4gIH0pO1xufTtcbi8qIC0tLS0tIFNFVCAvIEdFVCAtLS0tLSAqL1xuXG5cbldvcmtlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KG9wdCkge1xuICAvLyBUT0RPOiBJbXBsZW1lbnQgb3JkZXJlZCBwYWlycz9cbiAgLy8gU2lsZW50bHkgaWdub3JlIGludmFsaWQgb3IgZW1wdHkgaW5wdXQuXG4gIGlmICgoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18ub2JqVHlwZSkob3B0KSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyBCdWlsZCBhbiBhcnJheSBvZiBzZXR0ZXIgZnVuY3Rpb25zIHRvIHF1ZXVlLlxuXG5cbiAgdmFyIGZucyA9IE9iamVjdC5rZXlzKG9wdCB8fCB7fSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSAnbWFyZ2luJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TWFyZ2luLmJpbmQodGhpcywgb3B0Lm1hcmdpbik7XG5cbiAgICAgIGNhc2UgJ2pzUERGJzpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldF9qc1BERigpIHtcbiAgICAgICAgICB0aGlzLm9wdC5qc1BERiA9IG9wdC5qc1BERjtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXRQYWdlU2l6ZSgpO1xuICAgICAgICB9O1xuXG4gICAgICBjYXNlICdwYWdlU2l6ZSc6XG4gICAgICAgIHJldHVybiB0aGlzLnNldFBhZ2VTaXplLmJpbmQodGhpcywgb3B0LnBhZ2VTaXplKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGtleSBpbiBXb3JrZXIudGVtcGxhdGUucHJvcCkge1xuICAgICAgICAgIC8vIFNldCBwcmUtZGVmaW5lZCBwcm9wZXJ0aWVzIGluIHByb3AuXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldF9wcm9wKCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wW2tleV0gPSBvcHRba2V5XTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNldCBhbnkgb3RoZXIgcHJvcGVydGllcyBpbiBvcHQuXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldF9vcHQoKSB7XG4gICAgICAgICAgICB0aGlzLm9wdFtrZXldID0gb3B0W2tleV07XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9LCB0aGlzKTsgLy8gU2V0IHByb3BlcnRpZXMgd2l0aGluIHRoZSBwcm9taXNlIGNoYWluLlxuXG4gIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gc2V0X21haW4oKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbkxpc3QoZm5zKTtcbiAgfSk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChrZXksIGNiaykge1xuICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uIGdldF9tYWluKCkge1xuICAgIC8vIEZldGNoIHRoZSByZXF1ZXN0ZWQgcHJvcGVydHksIGVpdGhlciBhcyBhIHByZWRlZmluZWQgcHJvcCBvciBpbiBvcHQuXG4gICAgdmFyIHZhbCA9IGtleSBpbiBXb3JrZXIudGVtcGxhdGUucHJvcCA/IHRoaXMucHJvcFtrZXldIDogdGhpcy5vcHRba2V5XTtcbiAgICByZXR1cm4gY2JrID8gY2JrKHZhbCkgOiB2YWw7XG4gIH0pO1xufTtcblxuV29ya2VyLnByb3RvdHlwZS5zZXRNYXJnaW4gPSBmdW5jdGlvbiBzZXRNYXJnaW4obWFyZ2luKSB7XG4gIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gc2V0TWFyZ2luX21haW4oKSB7XG4gICAgLy8gUGFyc2UgdGhlIG1hcmdpbiBwcm9wZXJ0eTogW3RvcCwgbGVmdCwgYm90dG9tLCByaWdodF0uXG4gICAgc3dpdGNoICgoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18ub2JqVHlwZSkobWFyZ2luKSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgbWFyZ2luID0gW21hcmdpbiwgbWFyZ2luLCBtYXJnaW4sIG1hcmdpbl07XG5cbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgaWYgKG1hcmdpbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBtYXJnaW4gPSBbbWFyZ2luWzBdLCBtYXJnaW5bMV0sIG1hcmdpblswXSwgbWFyZ2luWzFdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXJnaW4ubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoJ0ludmFsaWQgbWFyZ2luIGFycmF5LicpO1xuICAgIH0gLy8gU2V0IHRoZSBtYXJnaW4gcHJvcGVydHksIHRoZW4gdXBkYXRlIHBhZ2VTaXplLlxuXG5cbiAgICB0aGlzLm9wdC5tYXJnaW4gPSBtYXJnaW47XG4gIH0pLnRoZW4odGhpcy5zZXRQYWdlU2l6ZSk7XG59O1xuXG5Xb3JrZXIucHJvdG90eXBlLnNldFBhZ2VTaXplID0gZnVuY3Rpb24gc2V0UGFnZVNpemUocGFnZVNpemUpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiBzZXRQYWdlU2l6ZV9tYWluKCkge1xuICAgIC8vIFJldHJpZXZlIHBhZ2Utc2l6ZSBiYXNlZCBvbiBqc1BERiBzZXR0aW5ncywgaWYgbm90IGV4cGxpY2l0bHkgcHJvdmlkZWQuXG4gICAgcGFnZVNpemUgPSBwYWdlU2l6ZSB8fCBqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fLmpzUERGLmdldFBhZ2VTaXplKHRoaXMub3B0LmpzUERGKTsgLy8gQWRkICdpbm5lcicgZmllbGQgaWYgbm90IHByZXNlbnQuXG5cbiAgICBpZiAoIXBhZ2VTaXplLmhhc093blByb3BlcnR5KCdpbm5lcicpKSB7XG4gICAgICBwYWdlU2l6ZS5pbm5lciA9IHtcbiAgICAgICAgd2lkdGg6IHBhZ2VTaXplLndpZHRoIC0gdGhpcy5vcHQubWFyZ2luWzFdIC0gdGhpcy5vcHQubWFyZ2luWzNdLFxuICAgICAgICBoZWlnaHQ6IHBhZ2VTaXplLmhlaWdodCAtIHRoaXMub3B0Lm1hcmdpblswXSAtIHRoaXMub3B0Lm1hcmdpblsyXVxuICAgICAgfTtcbiAgICAgIHBhZ2VTaXplLmlubmVyLnB4ID0ge1xuICAgICAgICB3aWR0aDogKDAsX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fLnRvUHgpKHBhZ2VTaXplLmlubmVyLndpZHRoLCBwYWdlU2l6ZS5rKSxcbiAgICAgICAgaGVpZ2h0OiAoMCxfdXRpbHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18udG9QeCkocGFnZVNpemUuaW5uZXIuaGVpZ2h0LCBwYWdlU2l6ZS5rKVxuICAgICAgfTtcbiAgICAgIHBhZ2VTaXplLmlubmVyLnJhdGlvID0gcGFnZVNpemUuaW5uZXIuaGVpZ2h0IC8gcGFnZVNpemUuaW5uZXIud2lkdGg7XG4gICAgfSAvLyBBdHRhY2ggcGFnZVNpemUgdG8gdGhpcy5cblxuXG4gICAgdGhpcy5wcm9wLnBhZ2VTaXplID0gcGFnZVNpemU7XG4gIH0pO1xufTtcblxuV29ya2VyLnByb3RvdHlwZS5zZXRQcm9ncmVzcyA9IGZ1bmN0aW9uIHNldFByb2dyZXNzKHZhbCwgc3RhdGUsIG4sIHN0YWNrKSB7XG4gIC8vIEltbWVkaWF0ZWx5IHVwZGF0ZSBhbGwgcHJvZ3Jlc3MgdmFsdWVzLlxuICBpZiAodmFsICE9IG51bGwpIHRoaXMucHJvZ3Jlc3MudmFsID0gdmFsO1xuICBpZiAoc3RhdGUgIT0gbnVsbCkgdGhpcy5wcm9ncmVzcy5zdGF0ZSA9IHN0YXRlO1xuICBpZiAobiAhPSBudWxsKSB0aGlzLnByb2dyZXNzLm4gPSBuO1xuICBpZiAoc3RhY2sgIT0gbnVsbCkgdGhpcy5wcm9ncmVzcy5zdGFjayA9IHN0YWNrO1xuICB0aGlzLnByb2dyZXNzLnJhdGlvID0gdGhpcy5wcm9ncmVzcy52YWwgLyB0aGlzLnByb2dyZXNzLnN0YXRlOyAvLyBSZXR1cm4gdGhpcyBmb3IgY29tbWFuZCBjaGFpbmluZy5cblxuICByZXR1cm4gdGhpcztcbn07XG5cbldvcmtlci5wcm90b3R5cGUudXBkYXRlUHJvZ3Jlc3MgPSBmdW5jdGlvbiB1cGRhdGVQcm9ncmVzcyh2YWwsIHN0YXRlLCBuLCBzdGFjaykge1xuICAvLyBJbW1lZGlhdGVseSB1cGRhdGUgYWxsIHByb2dyZXNzIHZhbHVlcywgdXNpbmcgc2V0UHJvZ3Jlc3MuXG4gIHJldHVybiB0aGlzLnNldFByb2dyZXNzKHZhbCA/IHRoaXMucHJvZ3Jlc3MudmFsICsgdmFsIDogbnVsbCwgc3RhdGUgPyBzdGF0ZSA6IG51bGwsIG4gPyB0aGlzLnByb2dyZXNzLm4gKyBuIDogbnVsbCwgc3RhY2sgPyB0aGlzLnByb2dyZXNzLnN0YWNrLmNvbmNhdChzdGFjaykgOiBudWxsKTtcbn07XG4vKiAtLS0tLSBQUk9NSVNFIE1BUFBJTkcgLS0tLS0gKi9cblxuXG5Xb3JrZXIucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIC8vIFdyYXAgYHRoaXNgIGZvciBlbmNhcHN1bGF0aW9uLlxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB0aGlzLnRoZW5Db3JlKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBmdW5jdGlvbiB0aGVuX21haW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAvLyBVcGRhdGUgcHJvZ3Jlc3Mgd2hpbGUgcXVldWluZywgY2FsbGluZywgYW5kIHJlc29sdmluZyBgdGhlbmAuXG4gICAgc2VsZi51cGRhdGVQcm9ncmVzcyhudWxsLCBudWxsLCAxLCBbb25GdWxmaWxsZWRdKTtcbiAgICByZXR1cm4gUHJvbWlzZS5wcm90b3R5cGUudGhlbi5jYWxsKHRoaXMsIGZ1bmN0aW9uIHRoZW5fcHJlKHZhbCkge1xuICAgICAgc2VsZi51cGRhdGVQcm9ncmVzcyhudWxsLCBvbkZ1bGZpbGxlZCk7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0pLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpLnRoZW4oZnVuY3Rpb24gdGhlbl9wb3N0KHZhbCkge1xuICAgICAgc2VsZi51cGRhdGVQcm9ncmVzcygxKTtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuV29ya2VyLnByb3RvdHlwZS50aGVuQ29yZSA9IGZ1bmN0aW9uIHRoZW5Db3JlKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCB0aGVuQmFzZSkge1xuICAvLyBIYW5kbGUgb3B0aW9uYWwgdGhlbkJhc2UgcGFyYW1ldGVyLlxuICB0aGVuQmFzZSA9IHRoZW5CYXNlIHx8IFByb21pc2UucHJvdG90eXBlLnRoZW47IC8vIFdyYXAgYHRoaXNgIGZvciBlbmNhcHN1bGF0aW9uIGFuZCBiaW5kIGl0IHRvIHRoZSBwcm9taXNlIGhhbmRsZXJzLlxuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAob25GdWxmaWxsZWQpIHtcbiAgICBvbkZ1bGZpbGxlZCA9IG9uRnVsZmlsbGVkLmJpbmQoc2VsZik7XG4gIH1cblxuICBpZiAob25SZWplY3RlZCkge1xuICAgIG9uUmVqZWN0ZWQgPSBvblJlamVjdGVkLmJpbmQoc2VsZik7XG4gIH0gLy8gQ2FzdCBzZWxmIGludG8gYSBQcm9taXNlIHRvIGF2b2lkIHBvbHlmaWxscyByZWN1cnNpdmVseSBkZWZpbmluZyBgdGhlbmAuXG5cblxuICB2YXIgaXNOYXRpdmUgPSBQcm9taXNlLnRvU3RyaW5nKCkuaW5kZXhPZignW25hdGl2ZSBjb2RlXScpICE9PSAtMSAmJiBQcm9taXNlLm5hbWUgPT09ICdQcm9taXNlJztcbiAgdmFyIHNlbGZQcm9taXNlID0gaXNOYXRpdmUgPyBzZWxmIDogV29ya2VyLmNvbnZlcnQoT2JqZWN0LmFzc2lnbih7fSwgc2VsZiksIFByb21pc2UucHJvdG90eXBlKTsgLy8gUmV0dXJuIHRoZSBwcm9taXNlLCBhZnRlciBjYXN0aW5nIGl0IGludG8gYSBXb3JrZXIgYW5kIHByZXNlcnZpbmcgcHJvcHMuXG5cbiAgdmFyIHJldHVyblZhbCA9IHRoZW5CYXNlLmNhbGwoc2VsZlByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgcmV0dXJuIFdvcmtlci5jb252ZXJ0KHJldHVyblZhbCwgc2VsZi5fX3Byb3RvX18pO1xufTtcblxuV29ya2VyLnByb3RvdHlwZS50aGVuRXh0ZXJuYWwgPSBmdW5jdGlvbiB0aGVuRXh0ZXJuYWwob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgLy8gQ2FsbCBgdGhlbmAgYW5kIHJldHVybiBhIHN0YW5kYXJkIHByb21pc2UgKGV4aXRzIHRoZSBXb3JrZXIgY2hhaW4pLlxuICByZXR1cm4gUHJvbWlzZS5wcm90b3R5cGUudGhlbi5jYWxsKHRoaXMsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUudGhlbkxpc3QgPSBmdW5jdGlvbiB0aGVuTGlzdChmbnMpIHtcbiAgLy8gUXVldWUgYSBzZXJpZXMgb2YgcHJvbWlzZSAnZmFjdG9yaWVzJyBpbnRvIHRoZSBwcm9taXNlIGNoYWluLlxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZucy5mb3JFYWNoKGZ1bmN0aW9uIHRoZW5MaXN0X2ZvckVhY2goZm4pIHtcbiAgICBzZWxmID0gc2VsZi50aGVuQ29yZShmbik7XG4gIH0pO1xuICByZXR1cm4gc2VsZjtcbn07XG5cbldvcmtlci5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAvLyBCaW5kIGB0aGlzYCB0byB0aGUgcHJvbWlzZSBoYW5kbGVyLCBjYWxsIGBjYXRjaGAsIGFuZCByZXR1cm4gYSBXb3JrZXIuXG4gIGlmIChvblJlamVjdGVkKSB7XG4gICAgb25SZWplY3RlZCA9IG9uUmVqZWN0ZWQuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHZhciByZXR1cm5WYWwgPSBQcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXS5jYWxsKHRoaXMsIG9uUmVqZWN0ZWQpO1xuICByZXR1cm4gV29ya2VyLmNvbnZlcnQocmV0dXJuVmFsLCB0aGlzKTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUuY2F0Y2hFeHRlcm5hbCA9IGZ1bmN0aW9uIGNhdGNoRXh0ZXJuYWwob25SZWplY3RlZCkge1xuICAvLyBDYWxsIGBjYXRjaGAgYW5kIHJldHVybiBhIHN0YW5kYXJkIHByb21pc2UgKGV4aXRzIHRoZSBXb3JrZXIgY2hhaW4pLlxuICByZXR1cm4gUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10uY2FsbCh0aGlzLCBvblJlamVjdGVkKTtcbn07XG5cbldvcmtlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtc2cpIHtcbiAgLy8gVGhyb3cgdGhlIGVycm9yIGluIHRoZSBQcm9taXNlIGNoYWluLlxuICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uIGVycm9yX21haW4oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gIH0pO1xufTtcbi8qIC0tLS0tIEFMSUFTRVMgLS0tLS0gKi9cblxuXG5Xb3JrZXIucHJvdG90eXBlLnVzaW5nID0gV29ya2VyLnByb3RvdHlwZS5zZXQ7XG5Xb3JrZXIucHJvdG90eXBlLnNhdmVBcyA9IFdvcmtlci5wcm90b3R5cGUuc2F2ZTtcbldvcmtlci5wcm90b3R5cGUuZXhwb3J0ID0gV29ya2VyLnByb3RvdHlwZS5vdXRwdXQ7XG5Xb3JrZXIucHJvdG90eXBlLnJ1biA9IFdvcmtlci5wcm90b3R5cGUudGhlbjtcbi8qIC0tLS0tIEZJTklTSElORyAtLS0tLSAqL1xuLy8gRXhwb3NlIHRoZSBXb3JrZXIgY2xhc3MuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoV29ya2VyKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1mdW5jdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtZnVuY3Rpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSAmJiBpdCAhPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArIFN0cmluZyhpdCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xudmFyIGNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtY3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZS5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKTtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sKCd1bnNjb3BhYmxlcycpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xuXG4vLyBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBjcmVhdGUobnVsbClcbiAgfSk7XG59XG5cbi8vIGFkZCBhIGtleSB0byBBcnJheS5wcm90b3R5cGVbQEB1bnNjb3BhYmxlc11cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mb3ItZWFjaC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mb3ItZWFjaC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICRmb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qc1wiKS5mb3JFYWNoO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QuanNcIik7XG5cbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnZm9yRWFjaCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxubW9kdWxlLmV4cG9ydHMgPSAhU1RSSUNUX01FVEhPRCA/IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1wcm90b3R5cGUtZm9yZWFjaCAtLSBzYWZlXG59IDogW10uZm9yRWFjaDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzXCIpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4LmpzXCIpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluY2x1ZGVzXG4gIGluY2x1ZGVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kKGZhbHNlKVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0LmpzXCIpO1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qc1wiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzXCIpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzXCIpO1xuXG52YXIgcHVzaCA9IFtdLnB1c2g7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCwgZmlsdGVyUmVqZWN0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIElTX0ZJTFRFUl9SRUpFQ1QgPSBUWVBFID09IDc7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjcmVhdGUgPSBzcGVjaWZpY0NyZWF0ZSB8fCBhcnJheVNwZWNpZXNDcmVhdGU7XG4gICAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiB8fCBJU19GSUxURVJfUkVKRUNUID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdmFsdWUsIHJlc3VsdDtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbHVlID0gc2VsZltpbmRleF07XG4gICAgICByZXN1bHQgPSBib3VuZEZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgTyk7XG4gICAgICBpZiAoVFlQRSkge1xuICAgICAgICBpZiAoSVNfTUFQKSB0YXJnZXRbaW5kZXhdID0gcmVzdWx0OyAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzdWx0KSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbHVlOyAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcHVzaC5jYWxsKHRhcmdldCwgdmFsdWUpOyAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAvLyBldmVyeVxuICAgICAgICAgIGNhc2UgNzogcHVzaC5jYWxsKHRhcmdldCwgdmFsdWUpOyAvLyBmaWx0ZXJSZWplY3RcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgZm9yRWFjaDogY3JlYXRlTWV0aG9kKDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuICBtYXA6IGNyZWF0ZU1ldGhvZCgxKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWx0ZXJcbiAgZmlsdGVyOiBjcmVhdGVNZXRob2QoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiAgc29tZTogY3JlYXRlTWV0aG9kKDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcbiAgZXZlcnk6IGNyZWF0ZU1ldGhvZCg0KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuICBmaW5kOiBjcmVhdGVNZXRob2QoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG4gIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kKDYpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlclJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWZpbHRlcmluZ1xuICBmaWx0ZXJSZWplY3Q6IGNyZWF0ZU1ldGhvZCg3KVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcbnZhciBWOF9WRVJTSU9OID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanNcIik7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB0aGlzIGZlYXR1cmUgZGV0ZWN0aW9uIGluIFY4IHNpbmNlIGl0IGNhdXNlc1xuICAvLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc3XG4gIHJldHVybiBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3IgPSB7fTtcbiAgICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGZvbzogMSB9O1xuICAgIH07XG4gICAgcmV0dXJuIGFycmF5W01FVEhPRF9OQU1FXShCb29sZWFuKS5mb28gIT09IDE7XG4gIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWlzLXN0cmljdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIGFyZ3VtZW50KSB7XG4gIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbCxuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkgeyB0aHJvdyAxOyB9LCAxKTtcbiAgfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanNcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbi8vIGEgcGFydCBvZiBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5KSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbEFycmF5KSkge1xuICAgIEMgPSBvcmlnaW5hbEFycmF5LmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBlbHNlIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNvbnN0cnVjdG9yLmpzXCIpO1xuXG4vLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXlzcGVjaWVzY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoYXJyYXlTcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWxBcnJheSkpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanNcIik7XG52YXIgY2xhc3NvZlJhdyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jbGFzc29mLXJhdyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YtcmF3LmpzXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcIik7XG52YXIgb3duS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vd24ta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzXCIpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXModGFyZ2V0LCBrZXkpKSBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWh0bWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWh0bWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzXCIpO1xudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qc1wiKTtcblxudmFyIHF1b3QgPSAvXCIvZztcblxuLy8gYENyZWF0ZUhUTUxgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1jcmVhdGVodG1sXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHJpbmcsIHRhZywgYXR0cmlidXRlLCB2YWx1ZSkge1xuICB2YXIgUyA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoc3RyaW5nKSk7XG4gIHZhciBwMSA9ICc8JyArIHRhZztcbiAgaWYgKGF0dHJpYnV0ZSAhPT0gJycpIHAxICs9ICcgJyArIGF0dHJpYnV0ZSArICc9XCInICsgdG9TdHJpbmcodmFsdWUpLnJlcGxhY2UocXVvdCwgJyZxdW90OycpICsgJ1wiJztcbiAgcmV0dXJuIHAxICsgJz4nICsgUyArICc8LycgKyB0YWcgKyAnPic7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3Rvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanNcIikuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXCIpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanNcIik7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qc1wiKTtcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanNcIik7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkuanNcIik7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG4gIGVsc2Ugb2JqZWN0W3Byb3BlcnR5S2V5XSA9IHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiKTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3RvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3Rvci5qc1wiKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzXCIpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YuanNcIik7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZy5qc1wiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanNcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1wdXJlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qc1wiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzXCIpO1xudmFyIEl0ZXJhdG9yc0NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMtY29yZS5qc1wiKTtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcbiAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl1cbiAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXG4gICAgfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcbiAgdmFyIGRlZmF1bHRJdGVyYXRvciA9ICFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7XG5cbiAgLy8gZml4IG5hdGl2ZVxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcbiAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICBpZiAoIUlTX1BVUkUgJiYgZ2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlKSAhPT0gSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgc2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCB0cnVlLCB0cnVlKTtcbiAgICAgIGlmIChJU19QVVJFKSBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRkFVTFQgPT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xuICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgZGVmYXVsdEl0ZXJhdG9yID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmF0aXZlSXRlcmF0b3IuY2FsbCh0aGlzKTsgfTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoKCFJU19QVVJFIHx8IEZPUkNFRCkgJiYgSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmFibGVQcm90b3R5cGUsIElURVJBVE9SLCBkZWZhdWx0SXRlcmF0b3IpO1xuICB9XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IGRlZmF1bHRJdGVyYXRvcjtcblxuICAvLyBleHBvcnQgYWRkaXRpb25hbCBtZXRob2RzXG4gIGlmIChERUZBVUxUKSB7XG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIHZhbHVlczogZ2V0SXRlcmF0aW9uTWV0aG9kKFZBTFVFUyksXG4gICAgICBrZXlzOiBJU19TRVQgPyBkZWZhdWx0SXRlcmF0b3IgOiBnZXRJdGVyYXRpb25NZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiBnZXRJdGVyYXRpb25NZXRob2QoRU5UUklFUylcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoS0VZIGluIG1ldGhvZHMpIHtcbiAgICAgIGlmIChCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB8fCAhKEtFWSBpbiBJdGVyYWJsZVByb3RvdHlwZSkpIHtcbiAgICAgICAgcmVkZWZpbmUoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCh7IHRhcmdldDogTkFNRSwgcHJvdG86IHRydWUsIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgfSwgbWV0aG9kcyk7XG4gIH1cblxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBwYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3BhdGggKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXRoLmpzXCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcIik7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZC5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKS5mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHZhciBTeW1ib2wgPSBwYXRoLlN5bWJvbCB8fCAocGF0aC5TeW1ib2wgPSB7fSk7XG4gIGlmICghaGFzKFN5bWJvbCwgTkFNRSkpIGRlZmluZVByb3BlcnR5KFN5bWJvbCwgTkFNRSwge1xuICAgIHZhbHVlOiB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYoTkFNRSlcbiAgfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG5cbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8vIGl0ZXJhYmxlIERPTSBjb2xsZWN0aW9uc1xuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENTU1J1bGVMaXN0OiAwLFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICBDU1NWYWx1ZUxpc3Q6IDAsXG4gIENsaWVudFJlY3RMaXN0OiAwLFxuICBET01SZWN0TGlzdDogMCxcbiAgRE9NU3RyaW5nTGlzdDogMCxcbiAgRE9NVG9rZW5MaXN0OiAxLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgRmlsZUxpc3Q6IDAsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiAgTWVkaWFMaXN0OiAwLFxuICBNaW1lVHlwZUFycmF5OiAwLFxuICBOYW1lZE5vZGVNYXA6IDAsXG4gIE5vZGVMaXN0OiAxLFxuICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICBQbHVnaW46IDAsXG4gIFBsdWdpbkFycmF5OiAwLFxuICBTVkdMZW5ndGhMaXN0OiAwLFxuICBTVkdOdW1iZXJMaXN0OiAwLFxuICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgU1ZHUG9pbnRMaXN0OiAwLFxuICBTVkdTdHJpbmdMaXN0OiAwLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICBTdHlsZVNoZWV0TGlzdDogMCxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgVGV4dFRyYWNrTGlzdDogMCxcbiAgVG91Y2hMaXN0OiAwXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgdXNlckFnZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2VuZ2luZS11c2VyLWFnZW50ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXVzZXItYWdlbnQuanNcIik7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbC5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIHZlcnNpb24gPSBtYXRjaFswXSA8IDQgPyAxIDogbWF0Y2hbMF0gKyBtYXRjaFsxXTtcbn0gZWxzZSBpZiAodXNlckFnZW50KSB7XG4gIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gbWF0Y2hbMV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2ZXJzaW9uICYmICt2ZXJzaW9uO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcIikuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanNcIik7XG52YXIgc2V0R2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NldC1nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtZ2xvYmFsLmpzXCIpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzXCIpO1xudmFyIGlzRm9yY2VkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWZvcmNlZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qc1wiKTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5ub1RhcmdldEdldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsW1RBUkdFVF0gfHwgc2V0R2xvYmFsKFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuICB9XG4gIGlmICh0YXJnZXQpIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICAgaWYgKG9wdGlvbnMubm9UYXJnZXRHZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgICAgdGFyZ2V0UHJvcGVydHkgPSBkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IudmFsdWU7XG4gICAgfSBlbHNlIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG4gICAgRk9SQ0VEID0gaXNGb3JjZWQoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KSBjb250aW51ZTtcbiAgICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgICB9XG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICByZWRlZmluZSh0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQtY29udGV4dC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZnVuY3Rpb24tYmluZC1jb250ZXh0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hLWZ1bmN0aW9uLmpzXCIpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQpO1xuICAgIH07XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWJ1aWx0LWluLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIHZhcmlhYmxlID09ICdmdW5jdGlvbicgPyB2YXJpYWJsZSA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSkgOiBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbm1vZHVsZS5leHBvcnRzID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jIC0tIGZhbGxiYWNrXG4gIChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcIik7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwodG9PYmplY3QoaXQpLCBrZXkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9odG1sLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdkb2N1bWVudCcsICdkb2N1bWVudEVsZW1lbnQnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1wiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudC5qc1wiKTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aWVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2xhc3NvZi1yYXcuanNcIik7XG5cbnZhciBzcGxpdCA9ICcnLnNwbGl0O1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xubW9kdWxlLmV4cG9ydHMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHRocm93cyBhbiBlcnJvciBpbiByaGlubywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3JoaW5vL2lzc3Vlcy8zNDZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGlucyAtLSBzYWZlXG4gIHJldHVybiAhT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdC5jYWxsKGl0LCAnJykgOiBPYmplY3QoaXQpO1xufSA6IE9iamVjdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG52YXIgc2V0UHJvdG90eXBlT2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZi5qc1wiKTtcblxuLy8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG4gIHZhciBOZXdUYXJnZXQsIE5ld1RhcmdldFByb3RvdHlwZTtcbiAgaWYgKFxuICAgIC8vIGl0IGNhbiB3b3JrIG9ubHkgd2l0aCBuYXRpdmUgYHNldFByb3RvdHlwZU9mYFxuICAgIHNldFByb3RvdHlwZU9mICYmXG4gICAgLy8gd2UgaGF2ZW4ndCBjb21wbGV0ZWx5IGNvcnJlY3QgcHJlLUVTNiB3YXkgZm9yIGdldHRpbmcgYG5ldy50YXJnZXRgLCBzbyB1c2UgdGhpc1xuICAgIHR5cGVvZiAoTmV3VGFyZ2V0ID0gZHVtbXkuY29uc3RydWN0b3IpID09ICdmdW5jdGlvbicgJiZcbiAgICBOZXdUYXJnZXQgIT09IFdyYXBwZXIgJiZcbiAgICBpc09iamVjdChOZXdUYXJnZXRQcm90b3R5cGUgPSBOZXdUYXJnZXQucHJvdG90eXBlKSAmJlxuICAgIE5ld1RhcmdldFByb3RvdHlwZSAhPT0gV3JhcHBlci5wcm90b3R5cGVcbiAgKSBzZXRQcm90b3R5cGVPZigkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcbiAgcmV0dXJuICR0aGlzO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzXCIpO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnRvU3RyaW5nO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAodHlwZW9mIHN0b3JlLmluc3BlY3RTb3VyY2UgIT0gJ2Z1bmN0aW9uJykge1xuICBzdG9yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcC5qc1wiKTtcbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCIpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzXCIpO1xudmFyIG9iamVjdEhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcIik7XG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1zdG9yZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qc1wiKTtcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLWtleSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanNcIik7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRkZW4ta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXCIpO1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIHZhciB3bWdldCA9IHN0b3JlLmdldDtcbiAgdmFyIHdtaGFzID0gc3RvcmUuaGFzO1xuICB2YXIgd21zZXQgPSBzdG9yZS5zZXQ7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMuY2FsbChzdG9yZSwgaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldC5jYWxsKHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0LmNhbGwoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzLmNhbGwoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcbiAgaGlkZGVuS2V5c1tTVEFURV0gPSB0cnVlO1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKG9iamVjdEhhcyhpdCwgU1RBVEUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qc1wiKTtcblxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2FycmF5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNsYXNzb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWZvcmNlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcIik7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogdHlwZW9mIGRldGVjdGlvbiA9PSAnZnVuY3Rpb24nID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtb2JqZWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1wdXJlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXN5bWJvbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtc3ltYm9sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanNcIik7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xuICByZXR1cm4gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QoaXQpIGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xudmFyIGdldFByb3RvdHlwZU9mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YuanNcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtcHVyZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanNcIik7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLW9iamVjdFxudmFyIEl0ZXJhdG9yUHJvdG90eXBlLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSB0cnVlO1xuICBlbHNlIHtcbiAgICBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihnZXRQcm90b3R5cGVPZihhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUgPSBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cbn1cblxudmFyIE5FV19JVEVSQVRPUl9QUk9UT1RZUEUgPSBJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IHt9O1xuICAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcbiAgcmV0dXJuIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xufSk7XG5cbmlmIChORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuXG4vLyBgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1AQGl0ZXJhdG9yXG5pZiAoKCFJU19QVVJFIHx8IE5FV19JVEVSQVRPUl9QUk9UT1RZUEUpICYmICFoYXMoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SKSkge1xuICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSxcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUzogQlVHR1lfU0FGQVJJX0lURVJBVE9SU1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2l0ZXJhdG9ycy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBWOF9WRVJTSU9OID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2VuZ2luZS12OC12ZXJzaW9uICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24uanNcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3Rpbmdcbm1vZHVsZS5leHBvcnRzID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiAmJiBWOF9WRVJTSU9OIDwgNDE7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS13ZWFrLW1hcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnNwZWN0LXNvdXJjZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlLmpzXCIpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlKFdlYWtNYXApKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtYXNzaWduLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1wiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xudmFyIG9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qc1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanNcIik7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZS5qc1wiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcIik7XG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2luZGV4ZWQtb2JqZWN0LmpzXCIpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWFzc2lnbiAtLSBzYWZlXG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIHNob3VsZCBoYXZlIGNvcnJlY3Qgb3JkZXIgb2Ygb3BlcmF0aW9ucyAoRWRnZSBidWcpXG4gIGlmIChERVNDUklQVE9SUyAmJiAkYXNzaWduKHsgYjogMSB9LCAkYXNzaWduKGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGhpcywgJ2InLCB7XG4gICAgICAgIHZhbHVlOiAzLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgeyBiOiAyIH0pKS5iICE9PSAxKSByZXR1cm4gdHJ1ZTtcbiAgLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1zeW1ib2wgLS0gc2FmZVxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbc3ltYm9sXSA9IDc7XG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gIHdoaWxlIChhcmd1bWVudHNMZW5ndGggPiBpbmRleCkge1xuICAgIHZhciBTID0gSW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gb2JqZWN0S2V5cyhTKS5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSB7XG4gICAgICBrZXkgPSBrZXlzW2orK107XG4gICAgICBpZiAoIURFU0NSSVBUT1JTIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoUywga2V5KSkgVFtrZXldID0gU1trZXldO1xuICAgIH1cbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogZ2xvYmFsIEFjdGl2ZVhPYmplY3QgLS0gb2xkIElFLCBXU0ggKi9cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcIik7XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanNcIik7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2VudW0tYnVnLWtleXMuanNcIik7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRkZW4ta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXCIpO1xudmFyIGh0bWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaHRtbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2h0bWwuanNcIik7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanNcIik7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXCIpO1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmIChpZnJhbWUuc3R5bGUpIHtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ3NVxuICAgIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuICAgIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICAgIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG4gICAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgICByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbiAgfVxufTtcblxuLy8gQ2hlY2sgZm9yIGRvY3VtZW50LmRvbWFpbiBhbmQgYWN0aXZlIHggc3VwcG9ydFxuLy8gTm8gbmVlZCB0byB1c2UgYWN0aXZlIHggYXBwcm9hY2ggd2hlbiBkb2N1bWVudC5kb21haW4gaXMgbm90IHNldFxuLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbS9pc3N1ZXMvMTUwXG4vLyB2YXJpYXRpb24gb2YgaHR0cHM6Ly9naXRodWIuY29tL2tpdGNhbWJyaWRnZS9lczUtc2hpbS9jb21taXQvNGY3MzhhYzA2NjM0NlxuLy8gYXZvaWQgSUUgR0MgYnVnXG52YXIgYWN0aXZlWERvY3VtZW50O1xudmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBhY3RpdmVYRG9jdW1lbnQgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogaWdub3JlICovIH1cbiAgTnVsbFByb3RvT2JqZWN0ID0gZG9jdW1lbnQuZG9tYWluICYmIGFjdGl2ZVhEb2N1bWVudCA/XG4gICAgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIDogLy8gb2xkIElFXG4gICAgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKCkgfHxcbiAgICBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7IC8vIFdTSFxuICB2YXIgbGVuZ3RoID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gICAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnRpZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXCIpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1wiKTtcbnZhciBvYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanNcIik7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnRpZXMgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIFByb3BlcnRpZXNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXCIpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUuanNcIik7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXCIpO1xudmFyIHRvUHJvcGVydHlLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzXCIpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZXNjcmlwdG9ycy5qc1wiKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzXCIpO1xudmFyIHRvUHJvcGVydHlLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzXCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcIik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pZTgtZG9tLWRlZmluZS5qc1wiKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZSAqL1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzXCIpO1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanNcIikuZjtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5TmFtZXMoaXQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XSdcbiAgICA/IGdldFdpbmRvd05hbWVzKGl0KVxuICAgIDogJGdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KGl0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1wiKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qc1wiKTtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1wiKTtcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLWtleSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1rZXkuanNcIik7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qc1wiKTtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0cHJvdG90eXBlb2YgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oYXMuanNcIik7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcIik7XG52YXIgaW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzLmpzXCIpLmluZGV4T2Y7XG52YXIgaGlkZGVuS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9oaWRkZW4ta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hpZGRlbi1rZXlzLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzKGhpZGRlbktleXMsIGtleSkgJiYgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5pbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy1pbnRlcm5hbC5qc1wiKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qc1wiKTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1vYmplY3QuanNcIik7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1wb3NzaWJsZS1wcm90b3R5cGUuanNcIik7XG5cbi8vIGBPYmplY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2Zcbi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gIHZhciBDT1JSRUNUX1NFVFRFUiA9IGZhbHNlO1xuICB2YXIgdGVzdCA9IHt9O1xuICB2YXIgc2V0dGVyO1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbiAgICBzZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQ7XG4gICAgc2V0dGVyLmNhbGwodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0KE8pO1xuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIuY2FsbChPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qc1wiKTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NsYXNzb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLmpzXCIpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8ge30udG9TdHJpbmcgOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdbb2JqZWN0ICcgKyBjbGFzc29mKHRoaXMpICsgJ10nO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vcmRpbmFyeS10by1wcmltaXRpdmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29yZGluYXJ5LXRvLXByaW1pdGl2ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGlucHV0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL293bi1rZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dldC1idWlsdC1pbi5qc1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMuanNcIik7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzLmpzXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1wiKTtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZS5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcGF0aC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qc1wiKTtcbnZhciBpbnNwZWN0U291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2luc3BlY3Qtc291cmNlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5zcGVjdC1zb3VyY2UuanNcIik7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlLmpzXCIpO1xuXG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICB2YXIgdW5zYWZlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy51bnNhZmUgOiBmYWxzZTtcbiAgdmFyIHNpbXBsZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMuZW51bWVyYWJsZSA6IGZhbHNlO1xuICB2YXIgbm9UYXJnZXRHZXQgPSBvcHRpb25zID8gISFvcHRpb25zLm5vVGFyZ2V0R2V0IDogZmFsc2U7XG4gIHZhciBzdGF0ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgJiYgIWhhcyh2YWx1ZSwgJ25hbWUnKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIGtleSk7XG4gICAgfVxuICAgIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpO1xuICAgIGlmICghc3RhdGUuc291cmNlKSB7XG4gICAgICBzdGF0ZS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBrZXkgOiAnJyk7XG4gICAgfVxuICB9XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIHNldEdsb2JhbChrZXksIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIXVuc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gIH0gZWxzZSBpZiAoIW5vVGFyZ2V0R2V0ICYmIE9ba2V5XSkge1xuICAgIHNpbXBsZSA9IHRydWU7XG4gIH1cbiAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gIGVsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KE8sIGtleSwgdmFsdWUpO1xuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZmxhZ3MuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYW4tb2JqZWN0LmpzXCIpO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS5mbGFnc2AgZ2V0dGVyIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1yZWdleHAucHJvdG90eXBlLmZsYWdzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoYXQgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zZXQtZ2xvYmFsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbCwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWxba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXCIpLmY7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1wiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUQUcsIFNUQVRJQykge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkge1xuICAgIGRlZmluZVByb3BlcnR5KGl0LCBUT19TVFJJTkdfVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLWtleS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzXCIpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy91aWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91aWQuanNcIik7XG5cbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC1zdG9yZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBzZXRHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1nbG9iYWwuanNcIik7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IHNldEdsb2JhbChTSEFSRUQsIHt9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NoYXJlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtcHVyZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanNcIik7XG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLXN0b3JlLmpzXCIpO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMTYuMCcsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAyMSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1odG1sLWZvcmNlZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLWh0bWwtZm9yY2VkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcblxuLy8gY2hlY2sgdGhlIGV4aXN0ZW5jZSBvZiBhIG1ldGhvZCwgbG93ZXJjYXNlXG4vLyBvZiBhIHRhZyBhbmQgZXNjYXBpbmcgcXVvdGVzIGluIGFyZ3VtZW50c1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgcmV0dXJuIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGVzdCA9ICcnW01FVEhPRF9OQU1FXSgnXCInKTtcbiAgICByZXR1cm4gdGVzdCAhPT0gdGVzdC50b0xvd2VyQ2FzZSgpIHx8IHRlc3Quc3BsaXQoJ1wiJykubGVuZ3RoID4gMztcbiAgfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbnRlZ2VyICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qc1wiKTtcbnZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanNcIik7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanNcIik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBzaXplID0gUy5sZW5ndGg7XG4gICAgdmFyIGZpcnN0LCBzZWNvbmQ7XG4gICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBzaXplKSByZXR1cm4gQ09OVkVSVF9UT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBmaXJzdCA9IFMuY2hhckNvZGVBdChwb3NpdGlvbik7XG4gICAgcmV0dXJuIGZpcnN0IDwgMHhEODAwIHx8IGZpcnN0ID4gMHhEQkZGIHx8IHBvc2l0aW9uICsgMSA9PT0gc2l6ZVxuICAgICAgfHwgKHNlY29uZCA9IFMuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcbiAgICAgICAgPyBDT05WRVJUX1RPX1NUUklORyA/IFMuY2hhckF0KHBvc2l0aW9uKSA6IGZpcnN0XG4gICAgICAgIDogQ09OVkVSVF9UT19TVFJJTkcgPyBTLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctdHJpbS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctdHJpbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanNcIik7XG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzXCIpO1xudmFyIHdoaXRlc3BhY2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3doaXRlc3BhY2VzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2hpdGVzcGFjZXMuanNcIik7XG5cbnZhciB3aGl0ZXNwYWNlID0gJ1snICsgd2hpdGVzcGFjZXMgKyAnXSc7XG52YXIgbHRyaW0gPSBSZWdFeHAoJ14nICsgd2hpdGVzcGFjZSArIHdoaXRlc3BhY2UgKyAnKicpO1xudmFyIHJ0cmltID0gUmVnRXhwKHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyokJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbSwgdHJpbVN0YXJ0LCB0cmltRW5kLCB0cmltTGVmdCwgdHJpbVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICBpZiAoVFlQRSAmIDEpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGx0cmltLCAnJyk7XG4gICAgaWYgKFRZUEUgJiAyKSBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltTGVmdCwgdHJpbVN0YXJ0IH1gIG1ldGhvZHNcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1zdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1SaWdodCwgdHJpbUVuZCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltZW5kXG4gIGVuZDogY3JlYXRlTWV0aG9kKDIpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS50cmltYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiAgdHJpbTogY3JlYXRlTWV0aG9kKDMpXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW50ZWdlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXIuanNcIik7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qc1wiKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbnRlZ2VyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBUb0ludGVnZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc05hTihhcmd1bWVudCA9ICthcmd1bWVudCkgPyAwIDogKGFyZ3VtZW50ID4gMCA/IGZsb29yIDogY2VpbCkoYXJndW1lbnQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbnRlZ2VyICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW50ZWdlci5qc1wiKTtcblxudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgVG9MZW5ndGhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2xlbmd0aFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGFyZ3VtZW50ID4gMCA/IG1pbih0b0ludGVnZXIoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZS5qc1wiKTtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9vYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcmltaXRpdmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXByaW1pdGl2ZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanNcIik7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vcmRpbmFyeS10by1wcmltaXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vcmRpbmFyeS10by1wcmltaXRpdmUuanNcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG5cbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0KGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGlucHV0W1RPX1BSSU1JVElWRV07XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gZXhvdGljVG9QcmltLmNhbGwoaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QocmVzdWx0KSB8fCBpc1N5bWJvbChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgfVxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJvcGVydHkta2V5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1wcmltaXRpdmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcmltaXRpdmUuanNcIik7XG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtc3ltYm9sLmpzXCIpO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IFN0cmluZyhrZXkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmctdGFnLXN1cHBvcnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy10YWctc3VwcG9ydC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1zdHJpbmcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc1N5bWJvbChhcmd1bWVudCkpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VpZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyBTdHJpbmcoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3VzZS1zeW1ib2wtYXMtdWlkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTFxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC13cmFwcGVkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcblxuZXhwb3J0cy5mID0gd2VsbEtub3duU3ltYm9sO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzXCIpO1xudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanNcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2hhcy5qc1wiKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdWlkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzXCIpO1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanNcIik7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdXNlLXN5bWJvbC1hcy11aWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy91c2Utc3ltYm9sLWFzLXVpZC5qc1wiKTtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXMoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICBpZiAoTkFUSVZFX1NZTUJPTCAmJiBoYXMoU3ltYm9sLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3doaXRlc3BhY2VzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3doaXRlc3BhY2VzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG4vLyBhIHN0cmluZyBvZiBhbGwgdmFsaWQgdW5pY29kZSB3aGl0ZXNwYWNlc1xubW9kdWxlLmV4cG9ydHMgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDInICtcbiAgJ1xcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzXCIpO1xudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qc1wiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tb2JqZWN0LmpzXCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWxlbmd0aC5qc1wiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanNcIik7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUuanNcIik7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0LmpzXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xudmFyIFY4X1ZFUlNJT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZW5naW5lLXY4LXZlcnNpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9lbmdpbmUtdjgtdmVyc2lvbi5qc1wiKTtcblxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gd2VsbEtub3duU3ltYm9sKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjtcbnZhciBNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQgPSAnTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkJztcblxuLy8gV2UgY2FuJ3QgdXNlIHRoaXMgZmVhdHVyZSBkZXRlY3Rpb24gaW4gVjggc2luY2UgaXQgY2F1c2VzXG4vLyBkZW9wdGltaXphdGlvbiBhbmQgc2VyaW91cyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3OVxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgPSBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICBhcnJheVtJU19DT05DQVRfU1BSRUFEQUJMRV0gPSBmYWxzZTtcbiAgcmV0dXJuIGFycmF5LmNvbmNhdCgpWzBdICE9PSBhcnJheTtcbn0pO1xuXG52YXIgU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnY29uY2F0Jyk7XG5cbnZhciBpc0NvbmNhdFNwcmVhZGFibGUgPSBmdW5jdGlvbiAoTykge1xuICBpZiAoIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzcHJlYWRhYmxlID0gT1tJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gIHJldHVybiBzcHJlYWRhYmxlICE9PSB1bmRlZmluZWQgPyAhIXNwcmVhZGFibGUgOiBpc0FycmF5KE8pO1xufTtcblxudmFyIEZPUkNFRCA9ICFJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIHx8ICFTUEVDSUVTX1NVUFBPUlQ7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuY29uY2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQGlzQ29uY2F0U3ByZWFkYWJsZSBhbmQgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdChhcmcpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIHZhciBuID0gMDtcbiAgICB2YXIgaSwgaywgbGVuZ3RoLCBsZW4sIEU7XG4gICAgZm9yIChpID0gLTEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgRSA9IGkgPT09IC0xID8gTyA6IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChpc0NvbmNhdFNwcmVhZGFibGUoRSkpIHtcbiAgICAgICAgbGVuID0gdG9MZW5ndGgoRS5sZW5ndGgpO1xuICAgICAgICBpZiAobiArIGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHRocm93IFR5cGVFcnJvcihNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQpO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyssIG4rKykgaWYgKGsgaW4gRSkgY3JlYXRlUHJvcGVydHkoQSwgbiwgRVtrXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobiA+PSBNQVhfU0FGRV9JTlRFR0VSKSB0aHJvdyBUeXBlRXJyb3IoTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEKTtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkoQSwgbisrLCBFKTtcbiAgICAgIH1cbiAgICB9XG4gICAgQS5sZW5ndGggPSBuO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1wiKTtcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcy5qc1wiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXRlcmF0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLmpzXCIpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1wiKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanNcIik7XG5cbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZW50cmllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5lbnRyaWVzXG4vLyBgQXJyYXkucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUudmFsdWVzXG4vLyBgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAaXRlcmF0b3Jcbi8vIGBDcmVhdGVBcnJheUl0ZXJhdG9yYCBpbnRlcm5hbCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHRhcmdldCA9IHN0YXRlLnRhcmdldDtcbiAgdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCsrO1xuICBpZiAoIXRhcmdldCB8fCBpbmRleCA+PSB0YXJnZXQubGVuZ3RoKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiB7IHZhbHVlOiBpbmRleCwgZG9uZTogZmFsc2UgfTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiB7IHZhbHVlOiB0YXJnZXRbaW5kZXhdLCBkb25lOiBmYWxzZSB9O1xuICByZXR1cm4geyB2YWx1ZTogW2luZGV4LCB0YXJnZXRbaW5kZXhdXSwgZG9uZTogZmFsc2UgfTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXCIpO1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmRleGVkLW9iamVjdC5qc1wiKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qc1wiKTtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1pcy1zdHJpY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaXMtc3RyaWN0LmpzXCIpO1xuXG52YXIgbmF0aXZlSm9pbiA9IFtdLmpvaW47XG5cbnZhciBFUzNfU1RSSU5HUyA9IEluZGV4ZWRPYmplY3QgIT0gT2JqZWN0O1xudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdqb2luJywgJywnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5qb2luYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmpvaW5cbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEVTM19TVFJJTkdTIHx8ICFTVFJJQ1RfTUVUSE9EIH0sIHtcbiAgam9pbjogZnVuY3Rpb24gam9pbihzZXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbmF0aXZlSm9pbi5jYWxsKHRvSW5kZXhlZE9iamVjdCh0aGlzKSwgc2VwYXJhdG9yID09PSB1bmRlZmluZWQgPyAnLCcgOiBzZXBhcmF0b3IpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkubWFwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiKTtcbnZhciAkbWFwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qc1wiKS5tYXA7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0LmpzXCIpO1xuXG52YXIgSEFTX1NQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ21hcCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCB9LCB7XG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXCIpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtYXJyYXkuanNcIik7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXguanNcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tbGVuZ3RoLmpzXCIpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0LmpzXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQuanNcIik7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnc2xpY2UnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciBuYXRpdmVTbGljZSA9IFtdLnNsaWNlO1xudmFyIG1heCA9IE1hdGgubWF4O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNsaWNlXG4vLyBmYWxsYmFjayBmb3Igbm90IGFycmF5LWxpa2UgRVMzIHN0cmluZ3MgYW5kIERPTSBvYmplY3RzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCB9LCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgayA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICAgIC8vIGlubGluZSBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBmb3IgdXNhZ2UgbmF0aXZlIGBBcnJheSNzbGljZWAgd2hlcmUgaXQncyBwb3NzaWJsZVxuICAgIHZhciBDb25zdHJ1Y3RvciwgcmVzdWx0LCBuO1xuICAgIGlmIChpc0FycmF5KE8pKSB7XG4gICAgICBDb25zdHJ1Y3RvciA9IE8uY29uc3RydWN0b3I7XG4gICAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgICAgaWYgKHR5cGVvZiBDb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIChDb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgaXNBcnJheShDb25zdHJ1Y3Rvci5wcm90b3R5cGUpKSkge1xuICAgICAgICBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3JbU1BFQ0lFU107XG4gICAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gbnVsbCkgQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IgPT09IEFycmF5IHx8IENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVNsaWNlLmNhbGwoTywgaywgZmluKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0ID0gbmV3IChDb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDb25zdHJ1Y3RvcikobWF4KGZpbiAtIGssIDApKTtcbiAgICBmb3IgKG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgaWYgKGsgaW4gTykgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBuLCBPW2tdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXCIpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXCIpLmY7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZVRvU3RyaW5nID0gRnVuY3Rpb25Qcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIEZ1bmN0aW9uIGluc3RhbmNlcyBgLm5hbWVgIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWZ1bmN0aW9uLWluc3RhbmNlcy1uYW1lXG5pZiAoREVTQ1JJUFRPUlMgJiYgIShOQU1FIGluIEZ1bmN0aW9uUHJvdG90eXBlKSkge1xuICBkZWZpbmVQcm9wZXJ0eShGdW5jdGlvblByb3RvdHlwZSwgTkFNRSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBGdW5jdGlvblByb3RvdHlwZVRvU3RyaW5nLmNhbGwodGhpcykubWF0Y2gobmFtZVJFKVsxXTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBpc0ZvcmNlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1mb3JjZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1mb3JjZWQuanNcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVkZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWRlZmluZS5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qc1wiKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZC5qc1wiKTtcbnZhciBpc1N5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1zeW1ib2wuanNcIik7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlLmpzXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcIik7XG52YXIgY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzXCIpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1wiKS5mO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1wiKS5mO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXCIpLmY7XG52YXIgdHJpbSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zdHJpbmctdHJpbSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy10cmltLmpzXCIpLnRyaW07XG5cbnZhciBOVU1CRVIgPSAnTnVtYmVyJztcbnZhciBOYXRpdmVOdW1iZXIgPSBnbG9iYWxbTlVNQkVSXTtcbnZhciBOdW1iZXJQcm90b3R5cGUgPSBOYXRpdmVOdW1iZXIucHJvdG90eXBlO1xuXG4vLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbnZhciBCUk9LRU5fQ0xBU1NPRiA9IGNsYXNzb2YoY3JlYXRlKE51bWJlclByb3RvdHlwZSkpID09IE5VTUJFUjtcblxuLy8gYFRvTnVtYmVyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9udW1iZXJcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNTeW1ib2woYXJndW1lbnQpKSB0aHJvdyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IGEgU3ltYm9sIHZhbHVlIHRvIGEgbnVtYmVyJyk7XG4gIHZhciBpdCA9IHRvUHJpbWl0aXZlKGFyZ3VtZW50LCAnbnVtYmVyJyk7XG4gIHZhciBmaXJzdCwgdGhpcmQsIHJhZGl4LCBtYXhDb2RlLCBkaWdpdHMsIGxlbmd0aCwgaW5kZXgsIGNvZGU7XG4gIGlmICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMikge1xuICAgIGl0ID0gdHJpbShpdCk7XG4gICAgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KSB7XG4gICAgICB0aGlyZCA9IGl0LmNoYXJDb2RlQXQoMik7XG4gICAgICBpZiAodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApIHJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYgKGZpcnN0ID09PSA0OCkge1xuICAgICAgc3dpdGNoIChpdC5jaGFyQ29kZUF0KDEpKSB7XG4gICAgICAgIGNhc2UgNjY6IGNhc2UgOTg6IHJhZGl4ID0gMjsgbWF4Q29kZSA9IDQ5OyBicmVhazsgLy8gZmFzdCBlcXVhbCBvZiAvXjBiWzAxXSskL2lcbiAgICAgICAgY2FzZSA3OTogY2FzZSAxMTE6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCBvZiAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQ6IHJldHVybiAraXQ7XG4gICAgICB9XG4gICAgICBkaWdpdHMgPSBpdC5zbGljZSgyKTtcbiAgICAgIGxlbmd0aCA9IGRpZ2l0cy5sZW5ndGg7XG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG4gICAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IG1heENvZGUpIHJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbi8vIGBOdW1iZXJgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW51bWJlci1jb25zdHJ1Y3RvclxuaWYgKGlzRm9yY2VkKE5VTUJFUiwgIU5hdGl2ZU51bWJlcignIDBvMScpIHx8ICFOYXRpdmVOdW1iZXIoJzBiMScpIHx8IE5hdGl2ZU51bWJlcignKzB4MScpKSkge1xuICB2YXIgTnVtYmVyV3JhcHBlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSkge1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlO1xuICAgIHZhciBkdW1teSA9IHRoaXM7XG4gICAgcmV0dXJuIGR1bW15IGluc3RhbmNlb2YgTnVtYmVyV3JhcHBlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NMQVNTT0YgPyBmYWlscyhmdW5jdGlvbiAoKSB7IE51bWJlclByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZHVtbXkpOyB9KSA6IGNsYXNzb2YoZHVtbXkpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgTmF0aXZlTnVtYmVyKHRvTnVtYmVyKGl0KSksIGR1bW15LCBOdW1iZXJXcmFwcGVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IERFU0NSSVBUT1JTID8gZ2V0T3duUHJvcGVydHlOYW1lcyhOYXRpdmVOdW1iZXIpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVMyMDE1IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVMyMDE1IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlciwnICtcbiAgICAvLyBFU05leHRcbiAgICAnZnJvbVN0cmluZyxyYW5nZSdcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXMoTmF0aXZlTnVtYmVyLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKE51bWJlcldyYXBwZXIsIGtleSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KE51bWJlcldyYXBwZXIsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5hdGl2ZU51bWJlciwga2V5KSk7XG4gICAgfVxuICB9XG4gIE51bWJlcldyYXBwZXIucHJvdG90eXBlID0gTnVtYmVyUHJvdG90eXBlO1xuICBOdW1iZXJQcm90b3R5cGUuY29uc3RydWN0b3IgPSBOdW1iZXJXcmFwcGVyO1xuICByZWRlZmluZShnbG9iYWwsIE5VTUJFUiwgTnVtYmVyV3JhcHBlcik7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9leHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9leHBvcnQuanNcIik7XG52YXIgYXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1hc3NpZ24gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtYXNzaWduLmpzXCIpO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtYXNzaWduIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ24gfSwge1xuICBhc3NpZ246IGFzc2lnblxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmtleXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLW9iamVjdC5qc1wiKTtcbnZhciBuYXRpdmVLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMuanNcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IG5hdGl2ZUtleXMoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyB9LCB7XG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyh0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLXRhZy1zdXBwb3J0LmpzXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3JlZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVkZWZpbmUuanNcIik7XG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LXRvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcuanNcIik7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xuaWYgKCFUT19TVFJJTkdfVEFHX1NVUFBPUlQpIHtcbiAgcmVkZWZpbmUoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgdG9TdHJpbmcsIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1wiKTtcbnZhciAkdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZmFpbHMuanNcIik7XG52YXIgZmxhZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzLmpzXCIpO1xuXG52YXIgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJztcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIG5hdGl2ZVRvU3RyaW5nID0gUmVnRXhwUHJvdG90eXBlW1RPX1NUUklOR107XG5cbnZhciBOT1RfR0VORVJJQyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdGl2ZVRvU3RyaW5nLmNhbGwoeyBzb3VyY2U6ICdhJywgZmxhZ3M6ICdiJyB9KSAhPSAnL2EvYic7IH0pO1xuLy8gRkY0NC0gUmVnRXhwI3RvU3RyaW5nIGhhcyBhIHdyb25nIG5hbWVcbnZhciBJTkNPUlJFQ1RfTkFNRSA9IG5hdGl2ZVRvU3RyaW5nLm5hbWUgIT0gVE9fU1RSSU5HO1xuXG4vLyBgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZ2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChOT1RfR0VORVJJQyB8fCBJTkNPUlJFQ1RfTkFNRSkge1xuICByZWRlZmluZShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgdmFyIHAgPSAkdG9TdHJpbmcoUi5zb3VyY2UpO1xuICAgIHZhciByZiA9IFIuZmxhZ3M7XG4gICAgdmFyIGYgPSAkdG9TdHJpbmcocmYgPT09IHVuZGVmaW5lZCAmJiBSIGluc3RhbmNlb2YgUmVnRXhwICYmICEoJ2ZsYWdzJyBpbiBSZWdFeHBQcm90b3R5cGUpID8gZmxhZ3MuY2FsbChSKSA6IHJmKTtcbiAgICByZXR1cm4gJy8nICsgcCArICcvJyArIGY7XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLml0ZXJhdG9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNoYXJBdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZS5qc1wiKS5jaGFyQXQ7XG52YXIgdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8tc3RyaW5nLmpzXCIpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1wiKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3IuanNcIik7XG5cbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS1AQGl0ZXJhdG9yXG5kZWZpbmVJdGVyYXRvcihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogU1RSSU5HX0lURVJBVE9SLFxuICAgIHN0cmluZzogdG9TdHJpbmcoaXRlcmF0ZWQpLFxuICAgIGluZGV4OiAwXG4gIH0pO1xuLy8gYCVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5saW5rLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmxpbmsuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qc1wiKTtcbnZhciBjcmVhdGVIVE1MID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1odG1sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWh0bWwuanNcIik7XG52YXIgZm9yY2VkU3RyaW5nSFRNTE1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zdHJpbmctaHRtbC1mb3JjZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctaHRtbC1mb3JjZWQuanNcIik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmxpbmtgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmxpbmtcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdIVE1MTWV0aG9kKCdsaW5rJykgfSwge1xuICBsaW5rOiBmdW5jdGlvbiBsaW5rKHVybCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdhJywgJ2hyZWYnLCB1cmwpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5kZXNjcmlwdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vLyBgU3ltYm9sLnByb3RvdHlwZS5kZXNjcmlwdGlvbmAgZ2V0dGVyXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUuZGVzY3JpcHRpb25cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXCIpO1xudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZGVzY3JpcHRvcnMuanNcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qc1wiKS5mO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzLmpzXCIpO1xuXG52YXIgTmF0aXZlU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcblxuaWYgKERFU0NSSVBUT1JTICYmIHR5cGVvZiBOYXRpdmVTeW1ib2wgPT0gJ2Z1bmN0aW9uJyAmJiAoISgnZGVzY3JpcHRpb24nIGluIE5hdGl2ZVN5bWJvbC5wcm90b3R5cGUpIHx8XG4gIC8vIFNhZmFyaSAxMiBidWdcbiAgTmF0aXZlU3ltYm9sKCkuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZFxuKSkge1xuICB2YXIgRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlID0ge307XG4gIC8vIHdyYXAgU3ltYm9sIGNvbnN0cnVjdG9yIGZvciBjb3JyZWN0IHdvcmsgd2l0aCB1bmRlZmluZWQgZGVzY3JpcHRpb25cbiAgdmFyIFN5bWJvbFdyYXBwZXIgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBTdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcyBpbnN0YW5jZW9mIFN5bWJvbFdyYXBwZXJcbiAgICAgID8gbmV3IE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbilcbiAgICAgIC8vIGluIEVkZ2UgMTMsIFN0cmluZyhTeW1ib2wodW5kZWZpbmVkKSkgPT09ICdTeW1ib2wodW5kZWZpbmVkKSdcbiAgICAgIDogZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCA/IE5hdGl2ZVN5bWJvbCgpIDogTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgICBpZiAoZGVzY3JpcHRpb24gPT09ICcnKSBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmVbcmVzdWx0XSA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhTeW1ib2xXcmFwcGVyLCBOYXRpdmVTeW1ib2wpO1xuICB2YXIgc3ltYm9sUHJvdG90eXBlID0gU3ltYm9sV3JhcHBlci5wcm90b3R5cGUgPSBOYXRpdmVTeW1ib2wucHJvdG90eXBlO1xuICBzeW1ib2xQcm90b3R5cGUuY29uc3RydWN0b3IgPSBTeW1ib2xXcmFwcGVyO1xuXG4gIHZhciBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIG5hdGl2ZSA9IFN0cmluZyhOYXRpdmVTeW1ib2woJ3Rlc3QnKSkgPT0gJ1N5bWJvbCh0ZXN0KSc7XG4gIHZhciByZWdleHAgPSAvXlN5bWJvbFxcKCguKilcXClbXildKyQvO1xuICBkZWZpbmVQcm9wZXJ0eShzeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgIHZhciBzeW1ib2wgPSBpc09iamVjdCh0aGlzKSA/IHRoaXMudmFsdWVPZigpIDogdGhpcztcbiAgICAgIHZhciBzdHJpbmcgPSBzeW1ib2xUb1N0cmluZy5jYWxsKHN5bWJvbCk7XG4gICAgICBpZiAoaGFzKEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSwgc3ltYm9sKSkgcmV0dXJuICcnO1xuICAgICAgdmFyIGRlc2MgPSBuYXRpdmUgPyBzdHJpbmcuc2xpY2UoNywgLTEpIDogc3RyaW5nLnJlcGxhY2UocmVnZXhwLCAnJDEnKTtcbiAgICAgIHJldHVybiBkZXNjID09PSAnJyA/IHVuZGVmaW5lZCA6IGRlc2M7XG4gICAgfVxuICB9KTtcblxuICAkKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgIFN5bWJvbDogU3ltYm9sV3JhcHBlclxuICB9KTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kZWZpbmUtd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG5cbi8vIGBTeW1ib2wuaXRlcmF0b3JgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5pdGVyYXRvclxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZXhwb3J0LmpzXCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanNcIik7XG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1wdXJlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtcHVyZS5qc1wiKTtcbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzXCIpO1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS1zeW1ib2wuanNcIik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mYWlscy5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzXCIpO1xudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtYXJyYXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1hcnJheS5qc1wiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1vYmplY3QuanNcIik7XG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaXMtc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtc3ltYm9sLmpzXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qc1wiKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanNcIik7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QuanNcIik7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcm9wZXJ0eS1rZXkuanNcIik7XG52YXIgJHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3RvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLXN0cmluZy5qc1wiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvci5qc1wiKTtcbnZhciBuYXRpdmVPYmplY3RDcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1jcmVhdGUuanNcIik7XG52YXIgb2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9vYmplY3Qta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1rZXlzLmpzXCIpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qc1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbC5qc1wiKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMuanNcIik7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzXCIpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5LmpzXCIpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUuanNcIik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1ub24tZW51bWVyYWJsZS1wcm9wZXJ0eS5qc1wiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9yZWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZGVmaW5lLmpzXCIpO1xudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zaGFyZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQuanNcIik7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzXCIpO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRkZW4ta2V5cy5qc1wiKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvdWlkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzXCIpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzXCIpO1xudmFyIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wtd3JhcHBlZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLXdyYXBwZWQuanNcIik7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbC5qc1wiKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnLmpzXCIpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qc1wiKTtcbnZhciAkZm9yRWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24uanNcIikuZm9yRWFjaDtcblxudmFyIEhJRERFTiA9IHNoYXJlZEtleSgnaGlkZGVuJyk7XG52YXIgU1lNQk9MID0gJ1N5bWJvbCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1lNQk9MKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkc3RyaW5naWZ5ID0gZ2V0QnVpbHRJbignSlNPTicsICdzdHJpbmdpZnknKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG90eXBlU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N0cmluZy10by1zeW1ib2wtcmVnaXN0cnknKTtcbnZhciBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5Jyk7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBRT2JqZWN0ID0gZ2xvYmFsLlFPYmplY3Q7XG4vLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzNcbnZhciBVU0VfU0VUVEVSID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzY3JpcHRvciA9IERFU0NSSVBUT1JTICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdENyZWF0ZShuYXRpdmVEZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoTywgUCwgQXR0cmlidXRlcykge1xuICB2YXIgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIFApO1xuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcikgZGVsZXRlIE9iamVjdFByb3RvdHlwZVtQXTtcbiAgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yICYmIE8gIT09IE9iamVjdFByb3RvdHlwZSkge1xuICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZSwgUCwgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvcik7XG4gIH1cbn0gOiBuYXRpdmVEZWZpbmVQcm9wZXJ0eTtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnLCBkZXNjcmlwdGlvbikge1xuICB2YXIgc3ltYm9sID0gQWxsU3ltYm9sc1t0YWddID0gbmF0aXZlT2JqZWN0Q3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHNldEludGVybmFsU3RhdGUoc3ltYm9sLCB7XG4gICAgdHlwZTogU1lNQk9MLFxuICAgIHRhZzogdGFnLFxuICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICB9KTtcbiAgaWYgKCFERVNDUklQVE9SUykgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gIHJldHVybiBzeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBpZiAoTyA9PT0gT2JqZWN0UHJvdG90eXBlKSAkZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCwgQXR0cmlidXRlcyk7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5ID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghQXR0cmlidXRlcy5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhPLCBISURERU4pKSBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBISURERU4sIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB7fSkpO1xuICAgICAgT1tISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKE8sIEhJRERFTikgJiYgT1tISURERU5dW2tleV0pIE9bSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBBdHRyaWJ1dGVzID0gbmF0aXZlT2JqZWN0Q3JlYXRlKEF0dHJpYnV0ZXMsIHsgZW51bWVyYWJsZTogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjcmlwdG9yKE8sIGtleSwgQXR0cmlidXRlcyk7XG4gIH0gcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIGtleSwgQXR0cmlidXRlcyk7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBwcm9wZXJ0aWVzID0gdG9JbmRleGVkT2JqZWN0KFByb3BlcnRpZXMpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMocHJvcGVydGllcykuY29uY2F0KCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMocHJvcGVydGllcykpO1xuICAkZm9yRWFjaChrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFERVNDUklQVE9SUyB8fCAkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChwcm9wZXJ0aWVzLCBrZXkpKSAkZGVmaW5lUHJvcGVydHkoTywga2V5LCBwcm9wZXJ0aWVzW2tleV0pO1xuICB9KTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyBuYXRpdmVPYmplY3RDcmVhdGUoTykgOiAkZGVmaW5lUHJvcGVydGllcyhuYXRpdmVPYmplY3RDcmVhdGUoTyksIFByb3BlcnRpZXMpO1xufTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIFAgPSB0b1Byb3BlcnR5S2V5KFYpO1xuICB2YXIgZW51bWVyYWJsZSA9IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGhpcywgUCk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUgJiYgaGFzKEFsbFN5bWJvbHMsIFApICYmICFoYXMoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGVudW1lcmFibGUgfHwgIWhhcyh0aGlzLCBQKSB8fCAhaGFzKEFsbFN5bWJvbHMsIFApIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtQXSA/IGVudW1lcmFibGUgOiB0cnVlO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICB2YXIgaXQgPSB0b0luZGV4ZWRPYmplY3QoTyk7XG4gIHZhciBrZXkgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIGRlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG4gIGlmIChkZXNjcmlwdG9yICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIHtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSB0cnVlO1xuICB9XG4gIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaChuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhoaWRkZW5LZXlzLCBrZXkpKSByZXN1bHQucHVzaChrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pIHtcbiAgdmFyIElTX09CSkVDVF9QUk9UT1RZUEUgPSBPID09PSBPYmplY3RQcm90b3R5cGU7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoSVNfT0JKRUNUX1BST1RPVFlQRSA/IE9iamVjdFByb3RvdHlwZVN5bWJvbHMgOiB0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICghSVNfT0JKRUNUX1BST1RPVFlQRSB8fCBoYXMoT2JqZWN0UHJvdG90eXBlLCBrZXkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLWNvbnN0cnVjdG9yXG5pZiAoIU5BVElWRV9TWU1CT0wpIHtcbiAgJFN5bWJvbCA9IGZ1bmN0aW9uIFN5bWJvbCgpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yJyk7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gIWFyZ3VtZW50cy5sZW5ndGggfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAkdG9TdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgdGFnID0gdWlkKGRlc2NyaXB0aW9uKTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlKSBzZXR0ZXIuY2FsbChPYmplY3RQcm90b3R5cGVTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2NyaXB0b3IodGhpcywgdGFnLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyAmJiBVU0VfU0VUVEVSKSBzZXRTeW1ib2xEZXNjcmlwdG9yKE9iamVjdFByb3RvdHlwZSwgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiBzZXR0ZXIgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnLCBkZXNjcmlwdGlvbik7XG4gIH07XG5cbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS50YWc7XG4gIH0pO1xuXG4gIHJlZGVmaW5lKCRTeW1ib2wsICd3aXRob3V0U2V0dGVyJywgZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIHdyYXAodWlkKGRlc2NyaXB0aW9uKSwgZGVzY3JpcHRpb24pO1xuICB9KTtcblxuICBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mID0gJGRlZmluZVByb3BlcnR5O1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZiA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdlbGxLbm93blN5bWJvbChuYW1lKSwgbmFtZSk7XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtU3ltYm9sLWRlc2NyaXB0aW9uXG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoJFN5bWJvbFtQUk9UT1RZUEVdLCAnZGVzY3JpcHRpb24nLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5kZXNjcmlwdGlvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIUlTX1BVUkUpIHtcbiAgICAgIHJlZGVmaW5lKE9iamVjdFByb3RvdHlwZSwgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH1cbn1cblxuJCh7IGdsb2JhbDogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIU5BVElWRV9TWU1CT0wgfSwge1xuICBTeW1ib2w6ICRTeW1ib2xcbn0pO1xuXG4kZm9yRWFjaChvYmplY3RLZXlzKFdlbGxLbm93blN5bWJvbHNTdG9yZSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlZmluZVdlbGxLbm93blN5bWJvbChuYW1lKTtcbn0pO1xuXG4kKHsgdGFyZ2V0OiBTWU1CT0wsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfSwge1xuICAvLyBgU3ltYm9sLmZvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmZvclxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzdHJpbmcgPSAkdG9TdHJpbmcoa2V5KTtcbiAgICBpZiAoaGFzKFN0cmluZ1RvU3ltYm9sUmVnaXN0cnksIHN0cmluZykpIHJldHVybiBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ107XG4gICAgdmFyIHN5bWJvbCA9ICRTeW1ib2woc3RyaW5nKTtcbiAgICBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ10gPSBzeW1ib2w7XG4gICAgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1ib2xdID0gc3RyaW5nO1xuICAgIHJldHVybiBzeW1ib2w7XG4gIH0sXG4gIC8vIGBTeW1ib2wua2V5Rm9yYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wua2V5Zm9yXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sJyk7XG4gICAgaWYgKGhhcyhTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5LCBzeW0pKSByZXR1cm4gU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1dO1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgVVNFX1NFVFRFUiA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gZmFsc2U7IH1cbn0pO1xuXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvclxufSk7XG5cbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eXN5bWJvbHNcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gQ2hyb21lIDM4IGFuZCAzOSBgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc2AgZmFpbHMgb24gcHJpbWl0aXZlc1xuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzQ0M1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogZmFpbHMoZnVuY3Rpb24gKCkgeyBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZigxKTsgfSkgfSwge1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkge1xuICAgIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZih0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuLy8gYEpTT04uc3RyaW5naWZ5YCBtZXRob2QgYmVoYXZpb3Igd2l0aCBzeW1ib2xzXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG5pZiAoJHN0cmluZ2lmeSkge1xuICB2YXIgRk9SQ0VEX0pTT05fU1RSSU5HSUZZID0gIU5BVElWRV9TWU1CT0wgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzeW1ib2wgPSAkU3ltYm9sKCk7XG4gICAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgICByZXR1cm4gJHN0cmluZ2lmeShbc3ltYm9sXSkgIT0gJ1tudWxsXSdcbiAgICAgIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAgICAgfHwgJHN0cmluZ2lmeSh7IGE6IHN5bWJvbCB9KSAhPSAne30nXG4gICAgICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICAgICAgfHwgJHN0cmluZ2lmeShPYmplY3Qoc3ltYm9sKSkgIT0gJ3t9JztcbiAgfSk7XG5cbiAgJCh7IHRhcmdldDogJ0pTT04nLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9KU09OX1NUUklOR0lGWSB9LCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgICB2YXIgaW5kZXggPSAxO1xuICAgICAgdmFyICRyZXBsYWNlcjtcbiAgICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaW5kZXgpIGFyZ3MucHVzaChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgICAgJHJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgICAgcmV0dXJuICRzdHJpbmdpZnkuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmlmICghJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0pIHtcbiAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG59XG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCBTWU1CT0wpO1xuXG5oaWRkZW5LZXlzW0hJRERFTl0gPSB0cnVlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nbG9iYWwuanNcIik7XG52YXIgRE9NSXRlcmFibGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzXCIpO1xudmFyIGZvckVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2ggKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mb3ItZWFjaC5qc1wiKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLW5vbi1lbnVtZXJhYmxlLXByb3BlcnR5LmpzXCIpO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW0NPTExFQ1RJT05fTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlICYmIENvbGxlY3Rpb25Qcm90b3R5cGUuZm9yRWFjaCAhPT0gZm9yRWFjaCkgdHJ5IHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoQ29sbGVjdGlvblByb3RvdHlwZSwgJ2ZvckVhY2gnLCBmb3JFYWNoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBDb2xsZWN0aW9uUHJvdG90eXBlLmZvckVhY2ggPSBmb3JFYWNoO1xuICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2dsb2JhbC5qc1wiKTtcbnZhciBET01JdGVyYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMuanNcIik7XG52YXIgQXJyYXlJdGVyYXRvck1ldGhvZHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtbm9uLWVudW1lcmFibGUtcHJvcGVydHkuanNcIik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wuanNcIik7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIEFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvck1ldGhvZHMudmFsdWVzO1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW0NPTExFQ1RJT05fTkFNRV07XG4gIHZhciBDb2xsZWN0aW9uUHJvdG90eXBlID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgICAvLyBzb21lIENocm9tZSB2ZXJzaW9ucyBoYXZlIG5vbi1jb25maWd1cmFibGUgbWV0aG9kcyBvbiBET01Ub2tlbkxpc3RcbiAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtJVEVSQVRPUl0gIT09IEFycmF5VmFsdWVzKSB0cnkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdID0gQXJyYXlWYWx1ZXM7XG4gICAgfVxuICAgIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHXSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIENPTExFQ1RJT05fTkFNRSk7XG4gICAgfVxuICAgIGlmIChET01JdGVyYWJsZXNbQ09MTEVDVElPTl9OQU1FXSkgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gQXJyYXlJdGVyYXRvck1ldGhvZHMpIHtcbiAgICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pIHRyeSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvZXM2LXByb21pc2UuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cbi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgdjQuMi44KzFlNjhkY2U2XG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0IHRydWUgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdDA7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb2JqZWN0T3JGdW5jdGlvbih4KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHg7XG4gIHJldHVybiB4ICE9PSBudWxsICYmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuXG5cbnZhciBfaXNBcnJheSA9IHZvaWQgMDtcbmlmIChBcnJheS5pc0FycmF5KSB7XG4gIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbn0gZWxzZSB7XG4gIF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSA9IF9pc0FycmF5O1xuXG52YXIgbGVuID0gMDtcbnZhciB2ZXJ0eE5leHQgPSB2b2lkIDA7XG52YXIgY3VzdG9tU2NoZWR1bGVyRm4gPSB2b2lkIDA7XG5cbnZhciBhc2FwID0gZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHF1ZXVlW2xlbl0gPSBjYWxsYmFjaztcbiAgcXVldWVbbGVuICsgMV0gPSBhcmc7XG4gIGxlbiArPSAyO1xuICBpZiAobGVuID09PSAyKSB7XG4gICAgLy8gSWYgbGVuIGlzIDIsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgIC8vIElmIGFkZGl0aW9uYWwgY2FsbGJhY2tzIGFyZSBxdWV1ZWQgYmVmb3JlIHRoZSBxdWV1ZSBpcyBmbHVzaGVkLCB0aGV5XG4gICAgLy8gd2lsbCBiZSBwcm9jZXNzZWQgYnkgdGhpcyBmbHVzaCB0aGF0IHdlIGFyZSBzY2hlZHVsaW5nLlxuICAgIGlmIChjdXN0b21TY2hlZHVsZXJGbikge1xuICAgICAgY3VzdG9tU2NoZWR1bGVyRm4oZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRTY2hlZHVsZXIoc2NoZWR1bGVGbikge1xuICBjdXN0b21TY2hlZHVsZXJGbiA9IHNjaGVkdWxlRm47XG59XG5cbmZ1bmN0aW9uIHNldEFzYXAoYXNhcEZuKSB7XG4gIGFzYXAgPSBhc2FwRm47XG59XG5cbnZhciBicm93c2VyV2luZG93ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XG52YXIgYnJvd3Nlckdsb2JhbCA9IGJyb3dzZXJXaW5kb3cgfHwge307XG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgYnJvd3Nlckdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGlzTm9kZSA9IHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuXG4vLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxudmFyIGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaW1wb3J0U2NyaXB0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSAndW5kZWZpbmVkJztcblxuLy8gbm9kZVxuZnVuY3Rpb24gdXNlTmV4dFRpY2soKSB7XG4gIC8vIG5vZGUgdmVyc2lvbiAwLjEwLnggZGlzcGxheXMgYSBkZXByZWNhdGlvbiB3YXJuaW5nIHdoZW4gbmV4dFRpY2sgaXMgdXNlZCByZWN1cnNpdmVseVxuICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2N1am9qcy93aGVuL2lzc3Vlcy80MTAgZm9yIGRldGFpbHNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbi8vIHZlcnR4XG5mdW5jdGlvbiB1c2VWZXJ0eFRpbWVyKCkge1xuICBpZiAodHlwZW9mIHZlcnR4TmV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmVydHhOZXh0KGZsdXNoKTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBub2RlLmRhdGEgPSBpdGVyYXRpb25zID0gKytpdGVyYXRpb25zICUgMjtcbiAgfTtcbn1cblxuLy8gd2ViIHdvcmtlclxuZnVuY3Rpb24gdXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVNldFRpbWVvdXQoKSB7XG4gIC8vIFN0b3JlIHNldFRpbWVvdXQgcmVmZXJlbmNlIHNvIGVzNi1wcm9taXNlIHdpbGwgYmUgdW5hZmZlY3RlZCBieVxuICAvLyBvdGhlciBjb2RlIG1vZGlmeWluZyBzZXRUaW1lb3V0IChsaWtlIHNpbm9uLnVzZUZha2VUaW1lcnMoKSlcbiAgdmFyIGdsb2JhbFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWxTZXRUaW1lb3V0KGZsdXNoLCAxKTtcbiAgfTtcbn1cblxudmFyIHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBxdWV1ZVtpXTtcbiAgICB2YXIgYXJnID0gcXVldWVbaSArIDFdO1xuXG4gICAgY2FsbGJhY2soYXJnKTtcblxuICAgIHF1ZXVlW2ldID0gdW5kZWZpbmVkO1xuICAgIHF1ZXVlW2kgKyAxXSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRWZXJ0eCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdmVydHggPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpLnJlcXVpcmUoJ3ZlcnR4Jyk7XG4gICAgdmVydHhOZXh0ID0gdmVydHgucnVuT25Mb29wIHx8IHZlcnR4LnJ1bk9uQ29udGV4dDtcbiAgICByZXR1cm4gdXNlVmVydHhUaW1lcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHVzZVNldFRpbWVvdXQoKTtcbiAgfVxufVxuXG52YXIgc2NoZWR1bGVGbHVzaCA9IHZvaWQgMDtcbi8vIERlY2lkZSB3aGF0IGFzeW5jIG1ldGhvZCB0byB1c2UgdG8gdHJpZ2dlcmluZyBwcm9jZXNzaW5nIG9mIHF1ZXVlZCBjYWxsYmFja3M6XG5pZiAoaXNOb2RlKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIGlmIChpc1dvcmtlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTWVzc2FnZUNoYW5uZWwoKTtcbn0gZWxzZSBpZiAoYnJvd3NlcldpbmRvdyA9PT0gdW5kZWZpbmVkICYmIFwiZnVuY3Rpb25cIiA9PT0gJ2Z1bmN0aW9uJykge1xuICBzY2hlZHVsZUZsdXNoID0gYXR0ZW1wdFZlcnR4KCk7XG59IGVsc2Uge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzO1xuXG4gIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmIChjaGlsZFtQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWFrZVByb21pc2UoY2hpbGQpO1xuICB9XG5cbiAgdmFyIF9zdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cblxuICBpZiAoX3N0YXRlKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW19zdGF0ZSAtIDFdO1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGludm9rZUNhbGxiYWNrKF9zdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCBwYXJlbnQuX3Jlc3VsdCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZXNvbHZlKDEpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlc29sdmVcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgYHZhbHVlYFxuKi9cbmZ1bmN0aW9uIHJlc29sdmUkMShvYmplY3QpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBQUk9NSVNFX0lEID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBFTkRJTkcgPSB2b2lkIDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG5cbmZ1bmN0aW9uIHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xufVxuXG5mdW5jdGlvbiBjYW5ub3RSZXR1cm5Pd24oKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiQkMSwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4kJDEuY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbiQkMSkge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiQkMSwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiYgdGhlbiQkMSA9PT0gdGhlbiAmJiBtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yLnJlc29sdmUgPT09IHJlc29sdmUkMSkge1xuICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGVuJCQxID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoZW4kJDEpKSB7XG4gICAgICBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciB0aGVuJCQxID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICB0aGVuJCQxID0gdmFsdWUudGhlbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgdGhlbiQkMSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMCxcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlID0gdm9pZCAwLFxuICAgICAgZXJyb3IgPSB2b2lkIDAsXG4gICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICBlcnJvciA9IGU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgfVxuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIC8vIG5vb3BcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChzdWNjZWVkZWQgPT09IGZhbHNlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgdHJ5IHtcbiAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGUpO1xuICB9XG59XG5cbnZhciBpZCA9IDA7XG5mdW5jdGlvbiBuZXh0SWQoKSB7XG4gIHJldHVybiBpZCsrO1xufVxuXG5mdW5jdGlvbiBtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gIHByb21pc2VbUFJPTUlTRV9JRF0gPSBpZCsrO1xuICBwcm9taXNlLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9zdWJzY3JpYmVycyA9IFtdO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufVxuXG52YXIgRW51bWVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRW51bWVyYXRvcihDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gICAgaWYgKCF0aGlzLnByb21pc2VbUFJPTUlTRV9JRF0pIHtcbiAgICAgIG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgICAgICB0aGlzLl9lbnVtZXJhdGUoaW5wdXQpO1xuICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsaWRhdGlvbkVycm9yKCkpO1xuICAgIH1cbiAgfVxuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbiBfZW51bWVyYXRlKGlucHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uIF9lYWNoRW50cnkoZW50cnksIGkpIHtcbiAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gICAgdmFyIHJlc29sdmUkJDEgPSBjLnJlc29sdmU7XG5cblxuICAgIGlmIChyZXNvbHZlJCQxID09PSByZXNvbHZlJDEpIHtcbiAgICAgIHZhciBfdGhlbiA9IHZvaWQgMDtcbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3RoZW4gPSBlbnRyeS50aGVuO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gZTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBlbnRyeSwgX3RoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkMSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlJCQxKGVudHJ5KTtcbiAgICAgICAgfSksIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkMShlbnRyeSksIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24gX3NldHRsZWRBdChzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuXG4gICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24gX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKSB7XG4gICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEVudW1lcmF0b3I7XG59KCk7XG5cbi8qKlxuICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcbiAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgb2YgZnVsZmlsbG1lbnQgdmFsdWVzIGZvciB0aGUgcGFzc2VkIHByb21pc2VzLCBvclxuICByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBJdCBjYXN0cyBhbGxcbiAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuICBsZXQgcHJvbWlzZTMgPSByZXNvbHZlKDMpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIGxldCBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIGFsbFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgQHN0YXRpY1xuKi9cbmZ1bmN0aW9uIGFsbChlbnRyaWVzKSB7XG4gIHJldHVybiBuZXcgRW51bWVyYXRvcih0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xufVxuXG4vKipcbiAgYFByb21pc2UucmFjZWAgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoIGlzIHNldHRsZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuICBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBzZXR0bGUuXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyByZXN1bHQgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuICAgIC8vIHdhcyByZXNvbHZlZC5cbiAgfSk7XG4gIGBgYFxuXG4gIGBQcm9taXNlLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3RcbiAgc2V0dGxlZCBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZVxuICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG4gIGJlY29tZSByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICBwcm9taXNlIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb21pc2UgMicpKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG4gICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcbiAgfSk7XG4gIGBgYFxuXG4gIEFuIGV4YW1wbGUgcmVhbC13b3JsZCB1c2UgY2FzZSBpcyBpbXBsZW1lbnRpbmcgdGltZW91dHM6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBQcm9taXNlLnJhY2UoW2FqYXgoJ2Zvby5qc29uJyksIHRpbWVvdXQoNTAwMCldKVxuICBgYGBcblxuICBAbWV0aG9kIHJhY2VcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoaWNoIHNldHRsZXMgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBmaXJzdCBwYXNzZWRcbiAgcHJvbWlzZSB0byBzZXR0bGUuXG4qL1xuZnVuY3Rpb24gcmFjZShlbnRyaWVzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKCFpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIHBhc3NlZCBgcmVhc29uYC5cbiAgSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVqZWN0XG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHJlYXNvbiB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aC5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHJlYXNvbmAuXG4qL1xuZnVuY3Rpb24gcmVqZWN0JDEocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIG5lZWRzUmVzb2x2ZXIoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG59XG5cbi8qKlxuICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICBUZXJtaW5vbG9neVxuICAtLS0tLS0tLS0tLVxuXG4gIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gIEJhc2ljIFVzYWdlOlxuICAtLS0tLS0tLS0tLS1cblxuICBgYGBqc1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgIC8vIG9uIGZhaWx1cmVcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBBZHZhbmNlZCBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICBgYGBqc1xuICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgYGBganNcbiAgUHJvbWlzZS5hbGwoW1xuICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSk7XG4gIGBgYFxuXG4gIEBjbGFzcyBQcm9taXNlXG4gIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVyXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQGNvbnN0cnVjdG9yXG4qL1xuXG52YXIgUHJvbWlzZSQxID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICAgIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICAgIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJyAmJiBuZWVkc1Jlc29sdmVyKCk7XG4gICAgICB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSA/IGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IG5lZWRzTmV3KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICB9KTtcbiAgYGBgXG4gICBDaGFpbmluZ1xuICAtLS0tLS0tLVxuICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiB1c2VyLm5hbWU7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICB9KTtcbiAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gIH0pO1xuICBgYGBcbiAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIEFzc2ltaWxhdGlvblxuICAtLS0tLS0tLS0tLS1cbiAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICB9KTtcbiAgYGBgXG4gICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIFNpbXBsZSBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCByZXN1bHQ7XG4gICB0cnkge1xuICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9XG4gIH0pO1xuICBgYGBcbiAgIFByb21pc2UgRXhhbXBsZTtcbiAgIGBgYGphdmFzY3JpcHRcbiAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBzdWNjZXNzXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gZmFpbHVyZVxuICB9KTtcbiAgYGBgXG4gICBBZHZhbmNlZCBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCBhdXRob3IsIGJvb2tzO1xuICAgdHJ5IHtcbiAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuICAgfVxuICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcbiAgIH1cbiAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgfVxuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kQXV0aG9yKCkuXG4gICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAvLyBmb3VuZCBib29rc1xuICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgIEBtZXRob2QgdGhlblxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuICAvKipcbiAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuICBgYGBqc1xuICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICB9XG4gIC8vIHN5bmNocm9ub3VzXG4gIHRyeSB7XG4gIGZpbmRBdXRob3IoKTtcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfVxuICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG4gIEBtZXRob2QgY2F0Y2hcbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICBgZmluYWxseWAgd2lsbCBiZSBpbnZva2VkIHJlZ2FyZGxlc3Mgb2YgdGhlIHByb21pc2UncyBmYXRlIGp1c3QgYXMgbmF0aXZlXG4gICAgdHJ5L2NhdGNoL2ZpbmFsbHkgYmVoYXZlc1xuICBcbiAgICBTeW5jaHJvbm91cyBleGFtcGxlOlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRBdXRob3IoKSB7XG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQXV0aG9yKCk7XG4gICAgfVxuICBcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZpbmRBdXRob3IoKTsgLy8gc3VjY2VlZCBvciBmYWlsXG4gICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBhbHdheXMgcnVuc1xuICAgICAgLy8gZG9lc24ndCBhZmZlY3QgdGhlIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgQXN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpe1xuICAgICAgLy8gYXV0aG9yIHdhcyBlaXRoZXIgZm91bmQsIG9yIG5vdFxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGZpbmFsbHlcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkoY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgfTtcblxuICByZXR1cm4gUHJvbWlzZTtcbn0oKTtcblxuUHJvbWlzZSQxLnByb3RvdHlwZS50aGVuID0gdGhlbjtcblByb21pc2UkMS5hbGwgPSBhbGw7XG5Qcm9taXNlJDEucmFjZSA9IHJhY2U7XG5Qcm9taXNlJDEucmVzb2x2ZSA9IHJlc29sdmUkMTtcblByb21pc2UkMS5yZWplY3QgPSByZWplY3QkMTtcblByb21pc2UkMS5fc2V0U2NoZWR1bGVyID0gc2V0U2NoZWR1bGVyO1xuUHJvbWlzZSQxLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UkMS5fYXNhcCA9IGFzYXA7XG5cbi8qZ2xvYmFsIHNlbGYqL1xuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIHZhciBsb2NhbCA9IHZvaWQgMDtcblxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IHNlbGY7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICBpZiAoUCkge1xuICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBwcm9taXNlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNpbGVudGx5IGlnbm9yZWRcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZVRvU3RyaW5nID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGxvY2FsLlByb21pc2UgPSBQcm9taXNlJDE7XG59XG5cbi8vIFN0cmFuZ2UgY29tcGF0Li5cblByb21pc2UkMS5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuUHJvbWlzZSQxLlByb21pc2UgPSBQcm9taXNlJDE7XG5cbnJldHVybiBQcm9taXNlJDE7XG5cbn0pKSk7XG5cblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lczYtcHJvbWlzZS5tYXBcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJodG1sMmNhbnZhc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIGV4dGVybmFsIFwiaHRtbDJjYW52YXNcIiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9odG1sMmNhbnZhc19fO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCJqc3BkZlwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIGV4dGVybmFsIFwianNwZGZcIiAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9qc3BkZl9fO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0XHRmdW5jdGlvbigpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0XHR9XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQhZnVuY3Rpb24oKSB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqLCBwcm9wKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTsgfVxuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0ICovXG4vKioqKioqLyBcdCFmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpbiBzdHJpY3QgbW9kZS5cbiFmdW5jdGlvbigpIHtcblwidXNlIHN0cmljdFwiO1xuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfd29ya2VyX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3dvcmtlci5qcyAqLyBcIi4vc3JjL3dvcmtlci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGx1Z2luX2pzcGRmX3BsdWdpbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9wbHVnaW4vanNwZGYtcGx1Z2luLmpzICovIFwiLi9zcmMvcGx1Z2luL2pzcGRmLXBsdWdpbi5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGx1Z2luX3BhZ2VicmVha3NfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGx1Z2luL3BhZ2VicmVha3MuanMgKi8gXCIuL3NyYy9wbHVnaW4vcGFnZWJyZWFrcy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcGx1Z2luX2h5cGVybGlua3NfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGx1Z2luL2h5cGVybGlua3MuanMgKi8gXCIuL3NyYy9wbHVnaW4vaHlwZXJsaW5rcy5qc1wiKTtcblxuXG5cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIFBERiBmcm9tIGFuIEhUTUwgZWxlbWVudCBvciBzdHJpbmcgdXNpbmcgaHRtbDJjYW52YXMgYW5kIGpzUERGLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIGVsZW1lbnQgb3IgSFRNTCBzdHJpbmcuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdCBBbiBvYmplY3Qgb2Ygb3B0aW9uYWwgc2V0dGluZ3M6ICdtYXJnaW4nLCAnZmlsZW5hbWUnLFxuICogICAgJ2ltYWdlJyAoJ3R5cGUnIGFuZCAncXVhbGl0eScpLCBhbmQgJ2h0bWwyY2FudmFzJyAvICdqc3BkZicsIHdoaWNoIGFyZVxuICogICAgc2VudCBhcyBzZXR0aW5ncyB0byB0aGVpciBjb3JyZXNwb25kaW5nIGZ1bmN0aW9ucy5cbiAqL1xuXG52YXIgaHRtbDJwZGYgPSBmdW5jdGlvbiBodG1sMnBkZihzcmMsIG9wdCkge1xuICAvLyBDcmVhdGUgYSBuZXcgd29ya2VyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMuXG4gIHZhciB3b3JrZXIgPSBuZXcgaHRtbDJwZGYuV29ya2VyKG9wdCk7XG5cbiAgaWYgKHNyYykge1xuICAgIC8vIElmIHNyYyBpcyBzcGVjaWZpZWQsIHBlcmZvcm0gdGhlIHRyYWRpdGlvbmFsICdzaW1wbGUnIG9wZXJhdGlvbi5cbiAgICByZXR1cm4gd29ya2VyLmZyb20oc3JjKS5zYXZlKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gdGhlIHdvcmtlciBmb3IgbmV3IFByb21pc2UtYmFzZWQgb3BlcmF0aW9uLlxuICAgIHJldHVybiB3b3JrZXI7XG4gIH1cbn07XG5cbmh0bWwycGRmLldvcmtlciA9IF93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5kZWZhdWx0OyAvLyBFeHBvc2UgdGhlIGh0bWwycGRmIGZ1bmN0aW9uLlxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGh0bWwycGRmKTtcbn0oKTtcbl9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfZXhwb3J0c19fLmRlZmF1bHQ7XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7Il0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsInNlbGYiLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2pzcGRmX18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2h0bWwyY2FudmFzX18iLCJfX3dlYnBhY2tfbW9kdWxlc19fIiwiX191bnVzZWRfd2VicGFja19tb2R1bGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsInIiLCJjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19mb3JfZWFjaF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0IiwibiIsImNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfbGlua19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19saW5rX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCIsIl93b3JrZXJfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsIl91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fIiwibGlua0luZm8iLCJvcmlnIiwidG9Db250YWluZXIiLCJkZWZhdWx0IiwicHJvdG90eXBlIiwidG9QZGYiLCJjYWxsIiwidGhlbiIsInRvQ29udGFpbmVyX2h5cGVybGluayIsIm9wdCIsImVuYWJsZUxpbmtzIiwiY29udGFpbmVyIiwicHJvcCIsImxpbmtzIiwicXVlcnlTZWxlY3RvckFsbCIsImNvbnRhaW5lclJlY3QiLCJ1bml0Q29udmVydCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhZ2VTaXplIiwiayIsIkFycmF5IiwiZm9yRWFjaCIsImxpbmsiLCJjbGllbnRSZWN0cyIsImdldENsaWVudFJlY3RzIiwiaSIsImxlbmd0aCIsImNsaWVudFJlY3QiLCJsZWZ0IiwidG9wIiwicGFnZSIsIk1hdGgiLCJmbG9vciIsImlubmVyIiwiaGVpZ2h0IiwibWFyZ2luIiwicHVzaCIsInRvUGRmX2h5cGVybGluayIsImwiLCJwZGYiLCJzZXRQYWdlIiwid2lkdGgiLCJ1cmwiLCJocmVmIiwiblBhZ2VzIiwiaW50ZXJuYWwiLCJnZXROdW1iZXJPZlBhZ2VzIiwiY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiY29yZV9qc19tb2R1bGVzX2VzX3N5bWJvbF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2Rlc2NyaXB0aW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2Rlc2NyaXB0aW9uX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19hcnJheV9pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fIiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyIsImNvcmVfanNfbW9kdWxlc19lc19zdHJpbmdfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyIsImNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCIsImpzcGRmX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18iLCJqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fX2RlZmF1bHQiLCJfdHlwZW9mIiwib2JqIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJjb25zdHJ1Y3RvciIsImpzUERGIiwiZ2V0UGFnZVNpemUiLCJvcmllbnRhdGlvbiIsInVuaXQiLCJmb3JtYXQiLCJvcHRpb25zIiwidG9Mb3dlckNhc2UiLCJmb3JtYXRfYXNfc3RyaW5nIiwicGFnZUZvcm1hdHMiLCJoYXNPd25Qcm9wZXJ0eSIsInBhZ2VIZWlnaHQiLCJwYWdlV2lkdGgiLCJlcnIiLCJFcnJvciIsInRtcCIsImluZm8iLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfY29uY2F0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfY29uY2F0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19hcnJheV9zbGljZV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X3NsaWNlX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19hcnJheV9qb2luX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfam9pbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19mb3JfZWFjaF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fIiwiY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfZm9yX2VhY2hfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9rZXlzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18iLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2tleXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0IiwiX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fIiwiX3V0aWxzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18iLCJ0ZW1wbGF0ZSIsInBhZ2VicmVhayIsIm1vZGUiLCJiZWZvcmUiLCJhZnRlciIsImF2b2lkIiwidG9Db250YWluZXJfcGFnZWJyZWFrIiwicHhQYWdlSGVpZ2h0IiwicHgiLCJtb2RlU3JjIiwiY29uY2F0IiwiYXZvaWRBbGwiLCJpbmRleE9mIiwiY3NzIiwibGVnYWN5Iiwic2VsZWN0Iiwia2V5IiwiYWxsIiwic2xpY2UiLCJqb2luIiwibGVnYWN5RWxzIiwiZWxzIiwicGFnZWJyZWFrX2xvb3AiLCJlbCIsInJ1bGVzIiwic3R5bGUiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiYnJlYWtPcHQiLCJhdm9pZE9wdCIsImJyZWFrQmVmb3JlIiwicGFnZUJyZWFrQmVmb3JlIiwiYnJlYWtBZnRlciIsInBhZ2VCcmVha0FmdGVyIiwiYnJlYWtJbnNpZGUiLCJwYWdlQnJlYWtJbnNpZGUiLCJPYmplY3QiLCJrZXlzIiwic3RhcnRQYWdlIiwiZW5kUGFnZSIsImJvdHRvbSIsImFicyIsInBhZCIsImNyZWF0ZUVsZW1lbnQiLCJkaXNwbGF5IiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsIm5leHRTaWJsaW5nIiwiZCIsIm9ialR5cGUiLCJjbG9uZU5vZGUiLCJ0b1B4IiwiY29yZV9qc19tb2R1bGVzX2VzX251bWJlcl9jb25zdHJ1Y3Rvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiY29yZV9qc19tb2R1bGVzX2VzX251bWJlcl9jb25zdHJ1Y3Rvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfc3ltYm9sX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfZGVzY3JpcHRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsImNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfZGVzY3JpcHRpb25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyIsImNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyIsImNvcmVfanNfbW9kdWxlc19lc19zeW1ib2xfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X2l0ZXJhdG9yX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18iLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fIiwiY29yZV9qc19tb2R1bGVzX2VzX3N0cmluZ19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19pdGVyYXRvcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fIiwiY29yZV9qc19tb2R1bGVzX3dlYl9kb21fY29sbGVjdGlvbnNfaXRlcmF0b3JfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX19kZWZhdWx0IiwidHlwZSIsIlN0cmluZyIsIk51bWJlciIsIkZ1bmN0aW9uIiwibm9kZVR5cGUiLCJ0YWdOYW1lIiwiZG9jdW1lbnQiLCJjbGFzc05hbWUiLCJpbm5lckhUTUwiLCJzY3JpcHRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJyZW1vdmVDaGlsZCIsIm5vZGUiLCJqYXZhc2NyaXB0RW5hYmxlZCIsImNsb25lIiwiY3JlYXRlVGV4dE5vZGUiLCJub2RlVmFsdWUiLCJjaGlsZCIsImZpcnN0Q2hpbGQiLCJub2RlTmFtZSIsImFwcGVuZENoaWxkIiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInZhbHVlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJuZXdPYmoiLCJ2YWwiLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2Fzc2lnbl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiY29yZV9qc19tb2R1bGVzX2VzX29iamVjdF9hc3NpZ25fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X21hcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiY29yZV9qc19tb2R1bGVzX2VzX2FycmF5X21hcF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X2tleXNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsImNvcmVfanNfbW9kdWxlc19lc19vYmplY3Rfa2V5c19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfY29uY2F0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18iLCJjb3JlX2pzX21vZHVsZXNfZXNfYXJyYXlfY29uY2F0X2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lc19vYmplY3RfdG9fc3RyaW5nX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18iLCJjb3JlX2pzX21vZHVsZXNfZXNfb2JqZWN0X3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXNfcmVnZXhwX3RvX3N0cmluZ19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fIiwiY29yZV9qc19tb2R1bGVzX2VzX3JlZ2V4cF90b19zdHJpbmdfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzX2Z1bmN0aW9uX25hbWVfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyIsImNvcmVfanNfbW9kdWxlc19lc19mdW5jdGlvbl9uYW1lX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2NvbGxlY3Rpb25zX2Zvcl9lYWNoX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18iLCJjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9jb2xsZWN0aW9uc19mb3JfZWFjaF9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fX2RlZmF1bHQiLCJqc3BkZl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fIiwianNwZGZfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX19kZWZhdWx0IiwiaHRtbDJjYW52YXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyIsImh0bWwyY2FudmFzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19fZGVmYXVsdCIsIl91dGlsc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyIsImVzNl9wcm9taXNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fIiwiZXM2X3Byb21pc2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19fZGVmYXVsdCIsIlByb21pc2UiLCJXb3JrZXIiLCJhc3NpZ24iLCJjb252ZXJ0IiwicmVzb2x2ZSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsInNldFByb2dyZXNzIiwic2V0IiwiY3JlYXRlIiwicHJvbWlzZSIsImluaGVyaXQiLCJfX3Byb3RvX18iLCJzcmMiLCJvdmVybGF5IiwiY2FudmFzIiwiaW1nIiwicHJvZ3Jlc3MiLCJzdGF0ZSIsInN0YWNrIiwiZmlsZW5hbWUiLCJpbWFnZSIsInF1YWxpdHkiLCJodG1sMmNhbnZhcyIsImZyb20iLCJnZXRUeXBlIiwiZnJvbV9tYWluIiwiZXJyb3IiLCJ0byIsInRhcmdldCIsInRvQ2FudmFzIiwidG9JbWciLCJwcmVyZXFzIiwiY2hlY2tTcmMiLCJjaGVja1BhZ2VTaXplIiwic2V0UGFnZVNpemUiLCJ0aGVuTGlzdCIsInRvQ29udGFpbmVyX21haW4iLCJvdmVybGF5Q1NTIiwicG9zaXRpb24iLCJvdmVyZmxvdyIsInpJbmRleCIsInJpZ2h0IiwiYmFja2dyb3VuZENvbG9yIiwiY29udGFpbmVyQ1NTIiwib3BhY2l0eSIsInNvdXJjZSIsImJvZHkiLCJjaGVja0NvbnRhaW5lciIsImNvbnRhaW5zIiwidG9DYW52YXNfbWFpbiIsIm9ucmVuZGVyZWQiLCJ0b0NhbnZhc19wb3N0Iiwib25SZW5kZXJlZCIsImNoZWNrQ2FudmFzIiwidG9JbWdfbWFpbiIsImltZ0RhdGEiLCJ0b0RhdGFVUkwiLCJ0b1BkZl9tYWluIiwicHhGdWxsSGVpZ2h0IiwicmF0aW8iLCJjZWlsIiwicGFnZUNhbnZhcyIsInBhZ2VDdHgiLCJ3IiwiaCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiYWRkUGFnZSIsImFkZEltYWdlIiwib3V0cHV0Iiwib3V0cHV0SW1nIiwib3V0cHV0UGRmIiwiY2hlY2tQZGYiLCJvdXRwdXRQZGZfbWFpbiIsImNoZWNrSW1nIiwib3V0cHV0SW1nX21haW4iLCJ1bmRlZmluZWQiLCJsb2NhdGlvbiIsInNhdmUiLCJzYXZlX21haW4iLCJmbnMiLCJtYXAiLCJzZXRNYXJnaW4iLCJiaW5kIiwic2V0X2pzUERGIiwic2V0X3Byb3AiLCJzZXRfb3B0Iiwic2V0X21haW4iLCJnZXQiLCJjYmsiLCJnZXRfbWFpbiIsInNldE1hcmdpbl9tYWluIiwic2V0UGFnZVNpemVfbWFpbiIsInVwZGF0ZVByb2dyZXNzIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwidGhlbkNvcmUiLCJ0aGVuX21haW4iLCJ0aGVuX3ByZSIsInRoZW5fcG9zdCIsInRoZW5CYXNlIiwiaXNOYXRpdmUiLCJ0b1N0cmluZyIsIm5hbWUiLCJzZWxmUHJvbWlzZSIsInJldHVyblZhbCIsInRoZW5FeHRlcm5hbCIsInRoZW5MaXN0X2ZvckVhY2giLCJmbiIsImNhdGNoRXh0ZXJuYWwiLCJtc2ciLCJlcnJvcl9tYWluIiwidXNpbmciLCJzYXZlQXMiLCJleHBvcnQiLCJydW4iLCJpdCIsIlR5cGVFcnJvciIsIl9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cyIsImlzT2JqZWN0Iiwid2VsbEtub3duU3ltYm9sIiwiZGVmaW5lUHJvcGVydHlNb2R1bGUiLCJVTlNDT1BBQkxFUyIsIkFycmF5UHJvdG90eXBlIiwiZiIsImNvbmZpZ3VyYWJsZSIsIiRmb3JFYWNoIiwiYXJyYXlNZXRob2RJc1N0cmljdCIsIlNUUklDVF9NRVRIT0QiLCJjYWxsYmFja2ZuIiwiYXJndW1lbnRzIiwidG9JbmRleGVkT2JqZWN0IiwidG9MZW5ndGgiLCJ0b0Fic29sdXRlSW5kZXgiLCJjcmVhdGVNZXRob2QiLCJJU19JTkNMVURFUyIsIiR0aGlzIiwiZnJvbUluZGV4IiwiTyIsImluZGV4IiwiaW5jbHVkZXMiLCJJbmRleGVkT2JqZWN0IiwidG9PYmplY3QiLCJhcnJheVNwZWNpZXNDcmVhdGUiLCJUWVBFIiwiSVNfTUFQIiwiSVNfRklMVEVSIiwiSVNfU09NRSIsIklTX0VWRVJZIiwiSVNfRklORF9JTkRFWCIsIklTX0ZJTFRFUl9SRUpFQ1QiLCJOT19IT0xFUyIsInRoYXQiLCJzcGVjaWZpY0NyZWF0ZSIsImJvdW5kRnVuY3Rpb24iLCJyZXN1bHQiLCJmaWx0ZXIiLCJzb21lIiwiZXZlcnkiLCJmaW5kIiwiZmluZEluZGV4IiwiZmlsdGVyUmVqZWN0IiwiZmFpbHMiLCJWOF9WRVJTSU9OIiwiU1BFQ0lFUyIsIk1FVEhPRF9OQU1FIiwiYXJyYXkiLCJmb28iLCJCb29sZWFuIiwiYXJndW1lbnQiLCJtZXRob2QiLCJpc0FycmF5Iiwib3JpZ2luYWxBcnJheSIsIkMiLCJhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciIsIlRPX1NUUklOR19UQUdfU1VQUE9SVCIsImNsYXNzb2ZSYXciLCJUT19TVFJJTkdfVEFHIiwiQ09SUkVDVF9BUkdVTUVOVFMiLCJ0cnlHZXQiLCJ0YWciLCJjYWxsZWUiLCJoYXMiLCJvd25LZXlzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlIiwiZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJGIiwiZ2V0UHJvdG90eXBlT2YiLCJyZXF1aXJlT2JqZWN0Q29lcmNpYmxlIiwicXVvdCIsInN0cmluZyIsImF0dHJpYnV0ZSIsIlMiLCJwMSIsInJlcGxhY2UiLCJJdGVyYXRvclByb3RvdHlwZSIsImNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciIsInNldFRvU3RyaW5nVGFnIiwiSXRlcmF0b3JzIiwicmV0dXJuVGhpcyIsIkl0ZXJhdG9yQ29uc3RydWN0b3IiLCJOQU1FIiwibmV4dCIsIkRFU0NSSVBUT1JTIiwib2JqZWN0IiwiYml0bWFwIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwidG9Qcm9wZXJ0eUtleSIsInByb3BlcnR5S2V5IiwiJCIsImNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IiLCJzZXRQcm90b3R5cGVPZiIsImNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSIsInJlZGVmaW5lIiwiSVNfUFVSRSIsIkl0ZXJhdG9yc0NvcmUiLCJCVUdHWV9TQUZBUklfSVRFUkFUT1JTIiwiSVRFUkFUT1IiLCJLRVlTIiwiVkFMVUVTIiwiRU5UUklFUyIsIkl0ZXJhYmxlIiwiREVGQVVMVCIsIklTX1NFVCIsIkZPUkNFRCIsImdldEl0ZXJhdGlvbk1ldGhvZCIsIktJTkQiLCJkZWZhdWx0SXRlcmF0b3IiLCJJdGVyYWJsZVByb3RvdHlwZSIsInZhbHVlcyIsImVudHJpZXMiLCJJTkNPUlJFQ1RfVkFMVUVTX05BTUUiLCJuYXRpdmVJdGVyYXRvciIsImFueU5hdGl2ZUl0ZXJhdG9yIiwiQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlIiwibWV0aG9kcyIsIktFWSIsInByb3RvIiwiZm9yY2VkIiwicGF0aCIsIndyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUiLCJnbG9iYWwiLCJFWElTVFMiLCJDU1NSdWxlTGlzdCIsIkNTU1N0eWxlRGVjbGFyYXRpb24iLCJDU1NWYWx1ZUxpc3QiLCJDbGllbnRSZWN0TGlzdCIsIkRPTVJlY3RMaXN0IiwiRE9NU3RyaW5nTGlzdCIsIkRPTVRva2VuTGlzdCIsIkRhdGFUcmFuc2Zlckl0ZW1MaXN0IiwiRmlsZUxpc3QiLCJIVE1MQWxsQ29sbGVjdGlvbiIsIkhUTUxDb2xsZWN0aW9uIiwiSFRNTEZvcm1FbGVtZW50IiwiSFRNTFNlbGVjdEVsZW1lbnQiLCJNZWRpYUxpc3QiLCJNaW1lVHlwZUFycmF5IiwiTmFtZWROb2RlTWFwIiwiTm9kZUxpc3QiLCJQYWludFJlcXVlc3RMaXN0IiwiUGx1Z2luIiwiUGx1Z2luQXJyYXkiLCJTVkdMZW5ndGhMaXN0IiwiU1ZHTnVtYmVyTGlzdCIsIlNWR1BhdGhTZWdMaXN0IiwiU1ZHUG9pbnRMaXN0IiwiU1ZHU3RyaW5nTGlzdCIsIlNWR1RyYW5zZm9ybUxpc3QiLCJTb3VyY2VCdWZmZXJMaXN0IiwiU3R5bGVTaGVldExpc3QiLCJUZXh0VHJhY2tDdWVMaXN0IiwiVGV4dFRyYWNrTGlzdCIsIlRvdWNoTGlzdCIsImdldEJ1aWx0SW4iLCJ1c2VyQWdlbnQiLCJwcm9jZXNzIiwiRGVubyIsInZlcnNpb25zIiwidmVyc2lvbiIsInY4IiwibWF0Y2giLCJzcGxpdCIsInNldEdsb2JhbCIsImNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMiLCJpc0ZvcmNlZCIsIlRBUkdFVCIsIkdMT0JBTCIsIlNUQVRJQyIsInN0YXQiLCJ0YXJnZXRQcm9wZXJ0eSIsInNvdXJjZVByb3BlcnR5IiwiZGVzY3JpcHRvciIsIm5vVGFyZ2V0R2V0Iiwic2hhbSIsImV4ZWMiLCJhRnVuY3Rpb24iLCJhIiwiYiIsImMiLCJhcHBseSIsInZhcmlhYmxlIiwibmFtZXNwYWNlIiwiY2hlY2siLCJnbG9iYWxUaGlzIiwiaGFzT3duIiwiY2xhc3NvZiIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZHVtbXkiLCJXcmFwcGVyIiwiTmV3VGFyZ2V0IiwiTmV3VGFyZ2V0UHJvdG90eXBlIiwic3RvcmUiLCJmdW5jdGlvblRvU3RyaW5nIiwiaW5zcGVjdFNvdXJjZSIsIk5BVElWRV9XRUFLX01BUCIsIm9iamVjdEhhcyIsInNoYXJlZCIsInNoYXJlZEtleSIsImhpZGRlbktleXMiLCJPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCIsIldlYWtNYXAiLCJlbmZvcmNlIiwiZ2V0dGVyRm9yIiwid21nZXQiLCJ3bWhhcyIsIndtc2V0IiwibWV0YWRhdGEiLCJmYWNhZGUiLCJTVEFURSIsImFyZyIsInJlcGxhY2VtZW50IiwiZmVhdHVyZSIsImRldGVjdGlvbiIsImRhdGEiLCJub3JtYWxpemUiLCJQT0xZRklMTCIsIk5BVElWRSIsIlVTRV9TWU1CT0xfQVNfVUlEIiwiJFN5bWJvbCIsIlByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSIsImFycmF5SXRlcmF0b3IiLCJORVdfSVRFUkFUT1JfUFJPVE9UWVBFIiwidGVzdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbCIsIm9iamVjdEtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSIsIiRhc3NpZ24iLCJBIiwiQiIsImFscGhhYmV0IiwiY2hyIiwiVCIsImFyZ3VtZW50c0xlbmd0aCIsImoiLCJhbk9iamVjdCIsImRlZmluZVByb3BlcnRpZXMiLCJlbnVtQnVnS2V5cyIsImh0bWwiLCJkb2N1bWVudENyZWF0ZUVsZW1lbnQiLCJHVCIsIkxUIiwiUFJPVE9UWVBFIiwiU0NSSVBUIiwiSUVfUFJPVE8iLCJFbXB0eUNvbnN0cnVjdG9yIiwic2NyaXB0VGFnIiwiY29udGVudCIsIk51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgiLCJhY3RpdmVYRG9jdW1lbnQiLCJ3cml0ZSIsImNsb3NlIiwidGVtcCIsInBhcmVudFdpbmRvdyIsIk51bGxQcm90b09iamVjdFZpYUlGcmFtZSIsImlmcmFtZSIsIkpTIiwiaWZyYW1lRG9jdW1lbnQiLCJjb250ZW50V2luZG93Iiwib3BlbiIsIk51bGxQcm90b09iamVjdCIsIkFjdGl2ZVhPYmplY3QiLCJkb21haW4iLCJQcm9wZXJ0aWVzIiwiSUU4X0RPTV9ERUZJTkUiLCIkZGVmaW5lUHJvcGVydHkiLCJQIiwiQXR0cmlidXRlcyIsIiRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCIkZ2V0T3duUHJvcGVydHlOYW1lcyIsIndpbmRvd05hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldFdpbmRvd05hbWVzIiwiaW50ZXJuYWxPYmplY3RLZXlzIiwiQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSIiwiT2JqZWN0UHJvdG90eXBlIiwibmFtZXMiLCIkcHJvcGVydHlJc0VudW1lcmFibGUiLCJOQVNIT1JOX0JVRyIsIlYiLCJhUG9zc2libGVQcm90b3R5cGUiLCJDT1JSRUNUX1NFVFRFUiIsInNldHRlciIsImlucHV0IiwicHJlZiIsInZhbHVlT2YiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlIiwiSW50ZXJuYWxTdGF0ZU1vZHVsZSIsImdldEludGVybmFsU3RhdGUiLCJlbmZvcmNlSW50ZXJuYWxTdGF0ZSIsIlRFTVBMQVRFIiwidW5zYWZlIiwic2ltcGxlIiwiaWdub3JlQ2FzZSIsIm11bHRpbGluZSIsImRvdEFsbCIsInVuaWNvZGUiLCJzdGlja3kiLCJUQUciLCJ1aWQiLCJTSEFSRUQiLCJjb3B5cmlnaHQiLCJ0b0ludGVnZXIiLCJDT05WRVJUX1RPX1NUUklORyIsInBvcyIsInNpemUiLCJmaXJzdCIsInNlY29uZCIsImNoYXJDb2RlQXQiLCJjaGFyQXQiLCJjb2RlQXQiLCJ3aGl0ZXNwYWNlcyIsIndoaXRlc3BhY2UiLCJsdHJpbSIsIlJlZ0V4cCIsInJ0cmltIiwic3RhcnQiLCJlbmQiLCJ0cmltIiwibWF4IiwibWluIiwiaW50ZWdlciIsImlzTmFOIiwiaXNTeW1ib2wiLCJvcmRpbmFyeVRvUHJpbWl0aXZlIiwiVE9fUFJJTUlUSVZFIiwiZXhvdGljVG9QcmltIiwidG9QcmltaXRpdmUiLCJpZCIsInBvc3RmaXgiLCJyYW5kb20iLCJOQVRJVkVfU1lNQk9MIiwiV2VsbEtub3duU3ltYm9sc1N0b3JlIiwiY3JlYXRlV2VsbEtub3duU3ltYm9sIiwid2l0aG91dFNldHRlciIsImNyZWF0ZVByb3BlcnR5IiwiYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCIsIklTX0NPTkNBVF9TUFJFQURBQkxFIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCIsIklTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQiLCJTUEVDSUVTX1NVUFBPUlQiLCJpc0NvbmNhdFNwcmVhZGFibGUiLCJzcHJlYWRhYmxlIiwibGVuIiwiRSIsImFkZFRvVW5zY29wYWJsZXMiLCJkZWZpbmVJdGVyYXRvciIsIkFSUkFZX0lURVJBVE9SIiwic2V0SW50ZXJuYWxTdGF0ZSIsIml0ZXJhdGVkIiwia2luZCIsImRvbmUiLCJBcmd1bWVudHMiLCJuYXRpdmVKb2luIiwiRVMzX1NUUklOR1MiLCJzZXBhcmF0b3IiLCIkbWFwIiwiSEFTX1NQRUNJRVNfU1VQUE9SVCIsIm5hdGl2ZVNsaWNlIiwiZmluIiwiQ29uc3RydWN0b3IiLCJGdW5jdGlvblByb3RvdHlwZSIsIkZ1bmN0aW9uUHJvdG90eXBlVG9TdHJpbmciLCJuYW1lUkUiLCJpbmhlcml0SWZSZXF1aXJlZCIsIk5VTUJFUiIsIk5hdGl2ZU51bWJlciIsIk51bWJlclByb3RvdHlwZSIsIkJST0tFTl9DTEFTU09GIiwidG9OdW1iZXIiLCJ0aGlyZCIsInJhZGl4IiwibWF4Q29kZSIsImRpZ2l0cyIsImNvZGUiLCJOYU4iLCJwYXJzZUludCIsIk51bWJlcldyYXBwZXIiLCJuYXRpdmVLZXlzIiwiRkFJTFNfT05fUFJJTUlUSVZFUyIsIiR0b1N0cmluZyIsImZsYWdzIiwiVE9fU1RSSU5HIiwiUmVnRXhwUHJvdG90eXBlIiwibmF0aXZlVG9TdHJpbmciLCJOT1RfR0VORVJJQyIsIklOQ09SUkVDVF9OQU1FIiwiUiIsInAiLCJyZiIsIlNUUklOR19JVEVSQVRPUiIsInBvaW50IiwiY3JlYXRlSFRNTCIsImZvcmNlZFN0cmluZ0hUTUxNZXRob2QiLCJOYXRpdmVTeW1ib2wiLCJkZXNjcmlwdGlvbiIsIkVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSIsIlN5bWJvbFdyYXBwZXIiLCJzeW1ib2xQcm90b3R5cGUiLCJzeW1ib2xUb1N0cmluZyIsIm5hdGl2ZSIsInJlZ2V4cCIsImRlc2MiLCJkZWZpbmVXZWxsS25vd25TeW1ib2wiLCJuYXRpdmVPYmplY3RDcmVhdGUiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwiLCJISURERU4iLCJTWU1CT0wiLCIkc3RyaW5naWZ5IiwibmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwibmF0aXZlRGVmaW5lUHJvcGVydHkiLCJuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzIiwibmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUiLCJBbGxTeW1ib2xzIiwiT2JqZWN0UHJvdG90eXBlU3ltYm9scyIsIlN0cmluZ1RvU3ltYm9sUmVnaXN0cnkiLCJTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5IiwiUU9iamVjdCIsIlVTRV9TRVRURVIiLCJmaW5kQ2hpbGQiLCJzZXRTeW1ib2xEZXNjcmlwdG9yIiwiT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciIsIndyYXAiLCIkZGVmaW5lUHJvcGVydGllcyIsInByb3BlcnRpZXMiLCIkZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiJGNyZWF0ZSIsIklTX09CSkVDVF9QUk9UT1RZUEUiLCJrZXlGb3IiLCJzeW0iLCJ1c2VTZXR0ZXIiLCJ1c2VTaW1wbGUiLCJGT1JDRURfSlNPTl9TVFJJTkdJRlkiLCJyZXBsYWNlciIsInNwYWNlIiwiYXJncyIsIiRyZXBsYWNlciIsIkRPTUl0ZXJhYmxlcyIsIkNPTExFQ1RJT05fTkFNRSIsIkNvbGxlY3Rpb24iLCJDb2xsZWN0aW9uUHJvdG90eXBlIiwiQXJyYXlJdGVyYXRvck1ldGhvZHMiLCJBcnJheVZhbHVlcyIsIm9iamVjdE9yRnVuY3Rpb24iLCJ4IiwiaXNGdW5jdGlvbiIsIl9pc0FycmF5IiwidmVydHhOZXh0IiwiY3VzdG9tU2NoZWR1bGVyRm4iLCJhc2FwIiwiY2FsbGJhY2siLCJxdWV1ZSIsImZsdXNoIiwic2NoZWR1bGVGbHVzaCIsInNldFNjaGVkdWxlciIsInNjaGVkdWxlRm4iLCJzZXRBc2FwIiwiYXNhcEZuIiwiYnJvd3NlcldpbmRvdyIsImJyb3dzZXJHbG9iYWwiLCJCcm93c2VyTXV0YXRpb25PYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJXZWJLaXRNdXRhdGlvbk9ic2VydmVyIiwiaXNOb2RlIiwiaXNXb3JrZXIiLCJVaW50OENsYW1wZWRBcnJheSIsImltcG9ydFNjcmlwdHMiLCJNZXNzYWdlQ2hhbm5lbCIsInVzZU5leHRUaWNrIiwibmV4dFRpY2siLCJ1c2VWZXJ0eFRpbWVyIiwidXNlU2V0VGltZW91dCIsInVzZU11dGF0aW9uT2JzZXJ2ZXIiLCJpdGVyYXRpb25zIiwib2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsInVzZU1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQxIiwib25tZXNzYWdlIiwicG9ydDIiLCJwb3N0TWVzc2FnZSIsImdsb2JhbFNldFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYXR0ZW1wdFZlcnR4IiwidmVydHgiLCJydW5Pbkxvb3AiLCJydW5PbkNvbnRleHQiLCJlIiwib25GdWxmaWxsbWVudCIsIm9uUmVqZWN0aW9uIiwicGFyZW50Iiwibm9vcCIsIlBST01JU0VfSUQiLCJtYWtlUHJvbWlzZSIsIl9zdGF0ZSIsImludm9rZUNhbGxiYWNrIiwiX3Jlc3VsdCIsInN1YnNjcmliZSIsInJlc29sdmUkMSIsInN1YnN0cmluZyIsIlBFTkRJTkciLCJGVUxGSUxMRUQiLCJSRUpFQ1RFRCIsInNlbGZGdWxmaWxsbWVudCIsImNhbm5vdFJldHVybk93biIsInRyeVRoZW4iLCJ0aGVuJCQxIiwiZnVsZmlsbG1lbnRIYW5kbGVyIiwicmVqZWN0aW9uSGFuZGxlciIsImhhbmRsZUZvcmVpZ25UaGVuYWJsZSIsInRoZW5hYmxlIiwic2VhbGVkIiwiZnVsZmlsbCIsInJlYXNvbiIsInJlamVjdCIsIl9sYWJlbCIsImhhbmRsZU93blRoZW5hYmxlIiwiaGFuZGxlTWF5YmVUaGVuYWJsZSIsIm1heWJlVGhlbmFibGUiLCJwdWJsaXNoUmVqZWN0aW9uIiwiX29uZXJyb3IiLCJwdWJsaXNoIiwiX3N1YnNjcmliZXJzIiwic3Vic2NyaWJlcnMiLCJzZXR0bGVkIiwiZGV0YWlsIiwiaGFzQ2FsbGJhY2siLCJzdWNjZWVkZWQiLCJpbml0aWFsaXplUHJvbWlzZSIsInJlc29sdmVyIiwicmVzb2x2ZVByb21pc2UiLCJyZWplY3RQcm9taXNlIiwibmV4dElkIiwidmFsaWRhdGlvbkVycm9yIiwiRW51bWVyYXRvciIsIl9pbnN0YW5jZUNvbnN0cnVjdG9yIiwiX3JlbWFpbmluZyIsIl9lbnVtZXJhdGUiLCJfZWFjaEVudHJ5IiwiZW50cnkiLCJyZXNvbHZlJCQxIiwiX3RoZW4iLCJkaWRFcnJvciIsIl9zZXR0bGVkQXQiLCJQcm9taXNlJDEiLCJfd2lsbFNldHRsZUF0IiwiZW51bWVyYXRvciIsInJhY2UiLCJfIiwicmVqZWN0JDEiLCJuZWVkc1Jlc29sdmVyIiwibmVlZHNOZXciLCJjYXRjaCIsIl9jYXRjaCIsImZpbmFsbHkiLCJfZmluYWxseSIsIl9zZXRTY2hlZHVsZXIiLCJfc2V0QXNhcCIsIl9hc2FwIiwicG9seWZpbGwiLCJsb2NhbCIsInByb21pc2VUb1N0cmluZyIsImNhc3QiLCJfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18iLCJtb2R1bGVJZCIsImNhY2hlZE1vZHVsZSIsImdldHRlciIsIl9fZXNNb2R1bGUiLCJkZWZpbml0aW9uIiwibyIsInRvU3RyaW5nVGFnIiwiX3dvcmtlcl9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiX3BsdWdpbl9qc3BkZl9wbHVnaW5fanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsIl9wbHVnaW5fcGFnZWJyZWFrc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fIiwiX3BsdWdpbl9oeXBlcmxpbmtzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18iLCJodG1sMnBkZiIsIndvcmtlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/html2pdf.js/dist/html2pdf.js\n");

/***/ })

};
;